var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_compressed_decoder.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Sven Stucki - svstucki@student.ethz.ch                     //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Compressed instruction decoder                             //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Decodes RISC-V compressed instructions into their RV32     //\n//                 equivalent. This module is fully combinatorial.            //\n//                 Float extensions added                                     //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_compressed_decoder #(\n    parameter FPU   = 0,\n    parameter ZFINX = 0\n) (\n    input  logic [31:0] instr_i,\n    output logic [31:0] instr_o,\n    output logic        is_compressed_o,\n    output logic        illegal_instr_o\n);\n\n  import cv32e40p_pkg::*;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  //   ____                                                 _   ____                     _            //\n  //  / ___|___  _ __ ___  _ __  _ __ ___  ___ ___  ___  __| | |  _ \\  ___  ___ ___   __| | ___ _ __  //\n  // | |   / _ \\| '_ ` _ \\| '_ \\| '__/ _ \\/ __/ __|/ _ \\/ _` | | | | |/ _ \\/ __/ _ \\ / _` |/ _ \\ '__| //\n  // | |__| (_) | | | | | | |_) | | |  __/\\__ \\__ \\  __/ (_| | | |_| |  __/ (_| (_) | (_| |  __/ |    //\n  //  \\____\\___/|_| |_| |_| .__/|_|  \\___||___/___/\\___|\\__,_| |____/ \\___|\\___\\___/ \\__,_|\\___|_|    //\n  //                      |_|                                                                         //\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  always_comb begin\n    illegal_instr_o = 1'b0;\n    instr_o         = '0;\n\n    unique case (instr_i[1:0])\n      // C0\n      2'b00: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            // c.addi4spn -> addi rd', x2, imm\n            instr_o = {\n              2'b0,\n              instr_i[10:7],\n              instr_i[12:11],\n              instr_i[5],\n              instr_i[6],\n              2'b00,\n              5'h02,\n              3'b000,\n              2'b01,\n              instr_i[4:2],\n              OPCODE_OPIMM\n            };\n            if (instr_i[12:5] == 8'b0) illegal_instr_o = 1'b1;\n          end\n\n          3'b001: begin\n            // c.fld -> fld rd', imm(rs1')\n            if (FPU == 1 && ZFINX == 0)\n              // instr_i[12:10]-> offset[5:3],  instr_i[6:5]-> offset[7:6]\n              instr_o = {\n                4'b0,\n                instr_i[6:5],\n                instr_i[12:10],\n                3'b000,\n                2'b01,\n                instr_i[9:7],\n                3'b011,\n                2'b01,\n                instr_i[4:2],\n                OPCODE_LOAD_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b010: begin\n            // c.lw -> lw rd', imm(rs1')\n            instr_o = {\n              5'b0,\n              instr_i[5],\n              instr_i[12:10],\n              instr_i[6],\n              2'b00,\n              2'b01,\n              instr_i[9:7],\n              3'b010,\n              2'b01,\n              instr_i[4:2],\n              OPCODE_LOAD\n            };\n          end\n\n          3'b011: begin\n            // c.flw -> flw rd', imm(rs1')\n            if (FPU == 1 && ZFINX == 0)\n              instr_o = {\n                5'b0,\n                instr_i[5],\n                instr_i[12:10],\n                instr_i[6],\n                2'b00,\n                2'b01,\n                instr_i[9:7],\n                3'b010,\n                2'b01,\n                instr_i[4:2],\n                OPCODE_LOAD_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b101: begin\n            // c.fsd -> fsd rs2', imm(rs1')\n            if (FPU == 1 && ZFINX == 0)\n              // instr_i[12:10] -> offset[5:3], instr_i[6:5] -> offset[7:6]\n              instr_o = {\n                4'b0,\n                instr_i[6:5],\n                instr_i[12],\n                2'b01,\n                instr_i[4:2],\n                2'b01,\n                instr_i[9:7],\n                3'b011,\n                instr_i[11:10],\n                3'b000,\n                OPCODE_STORE_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b110: begin\n            // c.sw -> sw rs2', imm(rs1')\n            instr_o = {\n              5'b0,\n              instr_i[5],\n              instr_i[12],\n              2'b01,\n              instr_i[4:2],\n              2'b01,\n              instr_i[9:7],\n              3'b010,\n              instr_i[11:10],\n              instr_i[6],\n              2'b00,\n              OPCODE_STORE\n            };\n          end\n\n          3'b111: begin\n            // c.fsw -> fsw rs2', imm(rs1')\n            if (FPU == 1 && ZFINX == 0)\n              instr_o = {\n                5'b0,\n                instr_i[5],\n                instr_i[12],\n                2'b01,\n                instr_i[4:2],\n                2'b01,\n                instr_i[9:7],\n                3'b010,\n                instr_i[11:10],\n                instr_i[6],\n                2'b00,\n                OPCODE_STORE_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n          default: begin\n            illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n\n      // C1\n      2'b01: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            // c.addi -> addi rd, rd, nzimm\n            // c.nop\n            instr_o = {\n              {6{instr_i[12]}},\n              instr_i[12],\n              instr_i[6:2],\n              instr_i[11:7],\n              3'b0,\n              instr_i[11:7],\n              OPCODE_OPIMM\n            };\n          end\n\n          3'b001, 3'b101: begin\n            // 001: c.jal -> jal x1, imm\n            // 101: c.j   -> jal x0, imm\n            instr_o = {\n              instr_i[12],\n              instr_i[8],\n              instr_i[10:9],\n              instr_i[6],\n              instr_i[7],\n              instr_i[2],\n              instr_i[11],\n              instr_i[5:3],\n              {9{instr_i[12]}},\n              4'b0,\n              ~instr_i[15],\n              OPCODE_JAL\n            };\n          end\n\n          3'b010: begin\n            if (instr_i[11:7] == 5'b0) begin\n              // Hint -> addi x0, x0, nzimm\n              instr_o = {\n                {6{instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], OPCODE_OPIMM\n              };\n            end else begin\n              // c.li -> addi rd, x0, nzimm\n              instr_o = {\n                {6{instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], OPCODE_OPIMM\n              };\n            end\n          end\n\n          3'b011: begin\n            if ({instr_i[12], instr_i[6:2]} == 6'b0) begin\n              illegal_instr_o = 1'b1;\n            end else begin\n              if (instr_i[11:7] == 5'h02) begin\n                // c.addi16sp -> addi x2, x2, nzimm\n                instr_o = {\n                  {3{instr_i[12]}},\n                  instr_i[4:3],\n                  instr_i[5],\n                  instr_i[2],\n                  instr_i[6],\n                  4'b0,\n                  5'h02,\n                  3'b000,\n                  5'h02,\n                  OPCODE_OPIMM\n                };\n              end else if (instr_i[11:7] == 5'b0) begin\n                // Hint -> lui x0, imm\n                instr_o = {{15{instr_i[12]}}, instr_i[6:2], instr_i[11:7], OPCODE_LUI};\n              end else begin\n                // c.lui -> lui rd, imm\n                instr_o = {{15{instr_i[12]}}, instr_i[6:2], instr_i[11:7], OPCODE_LUI};\n              end\n            end\n          end\n\n          3'b100: begin\n            unique case (instr_i[11:10])\n              2'b00, 2'b01: begin\n                // 00: c.srli -> srli rd, rd, shamt\n                // 01: c.srai -> srai rd, rd, shamt\n                if (instr_i[12] == 1'b1) begin\n                  // Reserved for future custom extensions (instr_o don't care)\n                  instr_o = {\n                    1'b0,\n                    instr_i[10],\n                    5'b0,\n                    instr_i[6:2],\n                    2'b01,\n                    instr_i[9:7],\n                    3'b101,\n                    2'b01,\n                    instr_i[9:7],\n                    OPCODE_OPIMM\n                  };\n                  illegal_instr_o = 1'b1;\n                end else begin\n                  if (instr_i[6:2] == 5'b0) begin\n                    // Hint\n                    instr_o = {\n                      1'b0,\n                      instr_i[10],\n                      5'b0,\n                      instr_i[6:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b101,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OPIMM\n                    };\n                  end else begin\n                    instr_o = {\n                      1'b0,\n                      instr_i[10],\n                      5'b0,\n                      instr_i[6:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b101,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OPIMM\n                    };\n                  end\n                end\n              end\n\n              2'b10: begin\n                // c.andi -> andi rd, rd, imm\n                instr_o = {\n                  {6{instr_i[12]}},\n                  instr_i[12],\n                  instr_i[6:2],\n                  2'b01,\n                  instr_i[9:7],\n                  3'b111,\n                  2'b01,\n                  instr_i[9:7],\n                  OPCODE_OPIMM\n                };\n              end\n\n              2'b11: begin\n                unique case ({\n                  instr_i[12], instr_i[6:5]\n                })\n                  3'b000: begin\n                    // c.sub -> sub rd', rd', rs2'\n                    instr_o = {\n                      2'b01,\n                      5'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b000,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OP\n                    };\n                  end\n\n                  3'b001: begin\n                    // c.xor -> xor rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b100,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OP\n                    };\n                  end\n\n                  3'b010: begin\n                    // c.or  -> or  rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b110,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OP\n                    };\n                  end\n\n                  3'b011: begin\n                    // c.and -> and rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b111,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OP\n                    };\n                  end\n\n                  3'b100, 3'b101, 3'b110, 3'b111: begin\n                    // 100: c.subw\n                    // 101: c.addw\n                    illegal_instr_o = 1'b1;\n                  end\n                endcase\n              end\n            endcase\n          end\n\n          3'b110, 3'b111: begin\n            // 0: c.beqz -> beq rs1', x0, imm\n            // 1: c.bnez -> bne rs1', x0, imm\n            instr_o = {\n              {4{instr_i[12]}},\n              instr_i[6:5],\n              instr_i[2],\n              5'b0,\n              2'b01,\n              instr_i[9:7],\n              2'b00,\n              instr_i[13],\n              instr_i[11:10],\n              instr_i[4:3],\n              instr_i[12],\n              OPCODE_BRANCH\n            };\n          end\n        endcase\n      end\n\n      // C2\n      2'b10: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            if (instr_i[12] == 1'b1) begin\n              // Reserved for future extensions (instr_o don't care)\n              instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], OPCODE_OPIMM};\n              illegal_instr_o = 1'b1;\n            end else begin\n              if ((instr_i[6:2] == 5'b0) || (instr_i[11:7] == 5'b0)) begin\n                // Hint -> slli rd, rd, shamt \n                instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], OPCODE_OPIMM};\n              end else begin\n                // c.slli -> slli rd, rd, shamt\n                instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], OPCODE_OPIMM};\n              end\n            end\n          end\n\n          3'b001: begin\n            // c.fldsp -> fld rd, imm(x2)\n            if (FPU == 1 && ZFINX == 0)\n              // instr_i[6:5] -> offset[4:3], instr_i[4:2] -> offset[8:6], instr_i[12] -> offset[5]\n              instr_o = {\n                3'b0,\n                instr_i[4:2],\n                instr_i[12],\n                instr_i[6:5],\n                3'b000,\n                5'h02,\n                3'b011,\n                instr_i[11:7],\n                OPCODE_LOAD_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b010: begin\n            // c.lwsp -> lw rd, imm(x2)\n            instr_o = {\n              4'b0,\n              instr_i[3:2],\n              instr_i[12],\n              instr_i[6:4],\n              2'b00,\n              5'h02,\n              3'b010,\n              instr_i[11:7],\n              OPCODE_LOAD\n            };\n            if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;\n          end\n\n          3'b011: begin\n            // c.flwsp -> flw rd, imm(x2)\n            if (FPU == 1 && ZFINX == 0)\n              instr_o = {\n                4'b0,\n                instr_i[3:2],\n                instr_i[12],\n                instr_i[6:4],\n                2'b00,\n                5'h02,\n                3'b010,\n                instr_i[11:7],\n                OPCODE_LOAD_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b100: begin\n            if (instr_i[12] == 1'b0) begin\n              if (instr_i[6:2] == 5'b0) begin\n                // c.jr -> jalr x0, rd/rs1, 0\n                instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, OPCODE_JALR};\n                // c.jr with rs1 = 0 is reserved\n                if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;\n              end else begin\n                if (instr_i[11:7] == 5'b0) begin\n                  // Hint -> add x0, x0, rs2\n                  instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], OPCODE_OP};\n                end else begin\n                  // c.mv -> add rd, x0, rs2\n                  instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], OPCODE_OP};\n                end\n              end\n            end else begin\n              if (instr_i[6:2] == 5'b0) begin\n                if (instr_i[11:7] == 5'b0) begin\n                  // c.ebreak -> ebreak\n                  instr_o = {32'h00_10_00_73};\n                end else begin\n                  // c.jalr -> jalr x1, rs1, 0\n                  instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, OPCODE_JALR};\n                end\n              end else begin\n                if (instr_i[11:7] == 5'b0) begin\n                  // Hint -> add x0, x0, rs2\n                  instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], OPCODE_OP};\n                end else begin\n                  // c.add -> add rd, rd, rs2\n                  instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], OPCODE_OP};\n                end\n              end\n            end\n          end\n\n          3'b101: begin\n            // c.fsdsp -> fsd rs2, imm(x2)\n            if (FPU == 1 && ZFINX == 0)\n              // instr_i[12:10] -> offset[5:3], instr_i[9:7] -> offset[8:6]\n              instr_o = {\n                3'b0,\n                instr_i[9:7],\n                instr_i[12],\n                instr_i[6:2],\n                5'h02,\n                3'b011,\n                instr_i[11:10],\n                3'b000,\n                OPCODE_STORE_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n          3'b110: begin\n            // c.swsp -> sw rs2, imm(x2)\n            instr_o = {\n              4'b0,\n              instr_i[8:7],\n              instr_i[12],\n              instr_i[6:2],\n              5'h02,\n              3'b010,\n              instr_i[11:9],\n              2'b00,\n              OPCODE_STORE\n            };\n          end\n\n          3'b111: begin\n            // c.fswsp -> fsw rs2, imm(x2)\n            if (FPU == 1 && ZFINX == 0)\n              instr_o = {\n                4'b0,\n                instr_i[8:7],\n                instr_i[12],\n                instr_i[6:2],\n                5'h02,\n                3'b010,\n                instr_i[11:9],\n                2'b00,\n                OPCODE_STORE_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n      default: begin\n        // 32 bit (or more) instruction\n        instr_o = instr_i;\n      end\n    endcase\n  end\n\n  assign is_compressed_o = (instr_i[1:0] != 2'b11);\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);