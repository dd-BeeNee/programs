var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_common_cells/src/lzc.sv","src":"// Copyright (c) 2018 - 2019 ETH Zurich, University of Bologna\n// All rights reserved.\n//\n// This code is under development and not yet released to the public.\n// Until it is released, the code is under the copyright of ETH Zurich and\n// the University of Bologna, and may contain confidential and/or unpublished\n// work. Any reuse/redistribution is strictly forbidden without written\n// permission from ETH Zurich.\n//\n// Bug fixes and contributions will eventually be released under the\n// SolderPad open hardware license in the context of the PULP platform\n// (http://www.pulp-platform.org), under the copyright of ETH Zurich and the\n// University of Bologna.\n\n/// A trailing zero counter / leading zero counter.\n/// Set MODE to 0 for trailing zero counter => cnt_o is the number of trailing zeros (from the LSB)\n/// Set MODE to 1 for leading zero counter  => cnt_o is the number of leading zeros  (from the MSB)\n/// If the input does not contain a zero, `empty_o` is asserted. Additionally `cnt_o` contains\n/// the maximum number of zeros - 1. For example:\n///   in_i = 000_0000, empty_o = 1, cnt_o = 6 (mode = 0)\n///   in_i = 000_0001, empty_o = 0, cnt_o = 0 (mode = 0)\n///   in_i = 000_1000, empty_o = 0, cnt_o = 3 (mode = 0)\n/// Furthermore, this unit contains a more efficient implementation for Verilator (simulation only).\n/// This speeds up simulation significantly.\nmodule lzc #(\n  /// The width of the input vector.\n  parameter int unsigned WIDTH = 2,\n  /// Mode selection: 0 -> trailing zero, 1 -> leading zero\n  parameter bit          MODE  = 1'b0,\n  /// Dependent parameter. Do **not** change!\n  ///\n  /// Width of the output signal with the zero count.\n  parameter int unsigned CNT_WIDTH = cf_math_pkg::idx_width(WIDTH)\n) (\n  /// Input vector to be counted.\n  input  logic [WIDTH-1:0]     in_i,\n  /// Count of the leading / trailing zeros.\n  output logic [CNT_WIDTH-1:0] cnt_o,\n  /// Counter is empty: Asserted if all bits in in_i are zero.\n  output logic                 empty_o\n);\n\n  if (WIDTH == 1) begin : gen_degenerate_lzc\n\n    assign cnt_o[0] = !in_i[0];\n    assign empty_o = !in_i[0];\n\n  end else begin : gen_lzc\n\n    localparam int unsigned NumLevels = $clog2(WIDTH);\n\n    // pragma translate_off\n    initial begin\n      assert(WIDTH > 0) else $fatal(1, \"input must be at least one bit wide\");\n    end\n    // pragma translate_on\n\n    logic [WIDTH-1:0][NumLevels-1:0] index_lut;\n    logic [2**NumLevels-1:0] sel_nodes;\n    logic [2**NumLevels-1:0][NumLevels-1:0] index_nodes;\n\n    logic [WIDTH-1:0] in_tmp;\n\n    // reverse vector if required\n    always_comb begin : flip_vector\n      for (int unsigned i = 0; i < WIDTH; i++) begin\n        in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];\n      end\n    end\n\n    for (genvar j = 0; unsigned'(j) < WIDTH; j++) begin : g_index_lut\n      assign index_lut[j] = (NumLevels)'(unsigned'(j));\n    end\n\n    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : g_levels\n      if (unsigned'(level) == NumLevels - 1) begin : g_last_level\n        for (genvar k = 0; k < 2 ** level; k++) begin : g_level\n          // if two successive indices are still in the vector...\n          if (unsigned'(k) * 2 < WIDTH - 1) begin : g_reduce\n            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2] | in_tmp[k * 2 + 1];\n            assign index_nodes[2 ** level - 1 + k] = (in_tmp[k * 2] == 1'b1)\n              ? index_lut[k * 2] :\n                index_lut[k * 2 + 1];\n          end\n          // if only the first index is still in the vector...\n          if (unsigned'(k) * 2 == WIDTH - 1) begin : g_base\n            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2];\n            assign index_nodes[2 ** level - 1 + k] = index_lut[k * 2];\n          end\n          // if index is out of range\n          if (unsigned'(k) * 2 > WIDTH - 1) begin : g_out_of_range\n            assign sel_nodes[2 ** level - 1 + k] = 1'b0;\n            assign index_nodes[2 ** level - 1 + k] = '0;\n          end\n        end\n      end else begin : g_not_last_level\n        for (genvar l = 0; l < 2 ** level; l++) begin : g_level\n          assign sel_nodes[2 ** level - 1 + l] =\n              sel_nodes[2 ** (level + 1) - 1 + l * 2] | sel_nodes[2 ** (level + 1) - 1 + l * 2 + 1];\n          assign index_nodes[2 ** level - 1 + l] = (sel_nodes[2 ** (level + 1) - 1 + l * 2] == 1'b1)\n            ? index_nodes[2 ** (level + 1) - 1 + l * 2] :\n              index_nodes[2 ** (level + 1) - 1 + l * 2 + 1];\n        end\n      end\n    end\n\n    assign cnt_o = NumLevels > unsigned'(0) ? index_nodes[0] : {($clog2(WIDTH)) {1'b0}};\n    assign empty_o = NumLevels > unsigned'(0) ? ~sel_nodes[0] : ~(|in_i);\n\n  end : gen_lzc\n\nendmodule : lzc\n","lang":"verilog"};
processSrcData(g_data);