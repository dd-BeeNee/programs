var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/src/fpnew_rounding.sv","src":"// Copyright 2019 ETH Zurich and University of Bologna.\n//\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// SPDX-License-Identifier: SHL-0.51\n\n// Author: Stefan Mach <smach@iis.ee.ethz.ch>\n\nmodule fpnew_rounding #(\n  parameter int unsigned AbsWidth=2 // Width of the abolute value, without sign bit\n) (\n  // Input value\n  input logic [AbsWidth-1:0]   abs_value_i,             // absolute value without sign\n  input logic                  sign_i,\n  // Rounding information\n  input logic [1:0]            round_sticky_bits_i,     // round and sticky bits {RS}\n  input fpnew_pkg::roundmode_e rnd_mode_i,\n  input logic                  effective_subtraction_i, // sign of inputs affects rounding of zeroes\n  // Output value\n  output logic [AbsWidth-1:0]  abs_rounded_o,           // absolute value without sign\n  output logic                 sign_o,\n  // Output classification\n  output logic                 exact_zero_o             // output is an exact zero\n);\n\n  logic round_up; // Rounding decision\n\n  // Take the rounding decision according to RISC-V spec\n  // RoundMode | Mnemonic | Meaning\n  // :--------:|:--------:|:-------\n  //    000    |   RNE    | Round to Nearest, ties to Even\n  //    001    |   RTZ    | Round towards Zero\n  //    010    |   RDN    | Round Down (towards -\\infty)\n  //    011    |   RUP    | Round Up (towards \\infty)\n  //    100    |   RMM    | Round to Nearest, ties to Max Magnitude\n  //    101    |   ROD    | Round towards odd (this mode is not define in RISC-V FP-SPEC)\n  //  others   |          | *invalid*\n  always_comb begin : rounding_decision\n    unique case (rnd_mode_i)\n      fpnew_pkg::RNE: // Decide accoring to round/sticky bits\n        unique case (round_sticky_bits_i)\n          2'b00,\n          2'b01: round_up = 1'b0;           // < ulp/2 away, round down\n          2'b10: round_up = abs_value_i[0]; // = ulp/2 away, round towards even result\n          2'b11: round_up = 1'b1;           // > ulp/2 away, round up\n          default: round_up = fpnew_pkg::DONT_CARE;\n        endcase\n      fpnew_pkg::RTZ: round_up = 1'b0; // always round down\n      fpnew_pkg::RDN: round_up = (| round_sticky_bits_i) ? sign_i  : 1'b0; // to 0 if +, away if -\n      fpnew_pkg::RUP: round_up = (| round_sticky_bits_i) ? ~sign_i : 1'b0; // to 0 if -, away if +\n      fpnew_pkg::RMM: round_up = round_sticky_bits_i[1]; // round down if < ulp/2 away, else up\n      fpnew_pkg::ROD: round_up = ~abs_value_i[0] & (| round_sticky_bits_i);\n      default: round_up = fpnew_pkg::DONT_CARE; // propagate x\n    endcase\n  end\n\n  // Perform the rounding, exponent change and overflow to inf happens automagically\n  assign abs_rounded_o = abs_value_i + round_up;\n\n  // True zero result is a zero result without dirty round/sticky bits\n  assign exact_zero_o = (abs_value_i == '0) && (round_sticky_bits_i == '0);\n\n  // In case of effective subtraction (thus signs of addition operands must have differed) and a\n  // true zero result, the result sign is '-' in case of RDN and '+' for other modes.\n  assign sign_o = (exact_zero_o && effective_subtraction_i)\n                  ? (rnd_mode_i == fpnew_pkg::RDN)\n                  : sign_i;\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);