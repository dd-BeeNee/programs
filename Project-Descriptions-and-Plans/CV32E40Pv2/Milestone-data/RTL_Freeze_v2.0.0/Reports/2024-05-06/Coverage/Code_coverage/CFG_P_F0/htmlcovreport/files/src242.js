var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_decoder.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer        Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Matthias Baer - baermatt@student.ethz.ch                   //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Decoder                                                    //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Decoder                                                    //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_decoder\n  import cv32e40p_pkg::*;\n  import cv32e40p_apu_core_pkg::*;\n  import cv32e40p_fpu_pkg::*;\n#(\n  parameter COREV_PULP        = 1,              // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding cv.elw)\n  parameter COREV_CLUSTER     = 0,              // PULP ISA Extension cv.elw (need COREV_PULP = 1)\n  parameter A_EXTENSION       = 0,\n  parameter FPU               = 0,\n  parameter FPU_ADDMUL_LAT    = 0,\n  parameter FPU_OTHERS_LAT    = 0,\n  parameter ZFINX             = 0,\n  parameter PULP_SECURE       = 0,\n  parameter USE_PMP           = 0,\n  parameter APU_WOP_CPU       = 6,\n  parameter DEBUG_TRIGGER_EN  = 1\n)\n(\n  // signals running to/from controller\n  input  logic        deassert_we_i,           // deassert we, we are stalled or not active\n\n  output logic        illegal_insn_o,          // illegal instruction encountered\n  output logic        ebrk_insn_o,             // trap instruction encountered\n\n  output logic        mret_insn_o,             // return from exception instruction encountered (M)\n  output logic        uret_insn_o,             // return from exception instruction encountered (S)\n  output logic        dret_insn_o,             // return from debug (M)\n\n  output logic        mret_dec_o,              // return from exception instruction encountered (M) without deassert\n  output logic        uret_dec_o,              // return from exception instruction encountered (S) without deassert\n  output logic        dret_dec_o,              // return from debug (M) without deassert\n\n  output logic        ecall_insn_o,            // environment call (syscall) instruction encountered\n  output logic        wfi_o       ,            // pipeline flush is requested\n\n  output logic        fencei_insn_o,           // fence.i instruction\n\n  output logic        rega_used_o,             // rs1 is used by current instruction\n  output logic        regb_used_o,             // rs2 is used by current instruction\n  output logic        regc_used_o,             // rs3 is used by current instruction\n\n  output logic        reg_fp_a_o,              // fp reg a is used\n  output logic        reg_fp_b_o,              // fp reg b is used\n  output logic        reg_fp_c_o,              // fp reg c is used\n  output logic        reg_fp_d_o,              // fp reg d is used\n\n  output logic [ 0:0] bmask_a_mux_o,           // bit manipulation mask a mux\n  output logic [ 1:0] bmask_b_mux_o,           // bit manipulation mask b mux\n  output logic        alu_bmask_a_mux_sel_o,   // bit manipulation mask a mux (reg or imm)\n  output logic        alu_bmask_b_mux_sel_o,   // bit manipulation mask b mux (reg or imm)\n\n  // from IF/ID pipeline\n  input  logic [31:0] instr_rdata_i,           // instruction read from instr memory/cache\n  input  logic        illegal_c_insn_i,        // compressed instruction decode failed\n\n  // ALU signals\n  output logic        alu_en_o,                // ALU enable\n  output alu_opcode_e alu_operator_o, // ALU operation selection\n  output logic [2:0]  alu_op_a_mux_sel_o,      // operand a selection: reg value, PC, immediate or zero\n  output logic [2:0]  alu_op_b_mux_sel_o,      // operand b selection: reg value or immediate\n  output logic [1:0]  alu_op_c_mux_sel_o,      // operand c selection: reg value or jump target\n  output logic        alu_vec_o,               // vectorial instruction\n  output logic [1:0]  alu_vec_mode_o,          // selects between 32 bit, 16 bit and 8 bit vectorial modes\n  output logic        scalar_replication_o,    // scalar replication enable\n  output logic        scalar_replication_c_o,  // scalar replication enable for operand C\n  output logic [0:0]  imm_a_mux_sel_o,         // immediate selection for operand a\n  output logic [3:0]  imm_b_mux_sel_o,         // immediate selection for operand b\n  output logic [1:0]  regc_mux_o,              // register c selection: S3, RD or 0\n  output logic        is_clpx_o,               // whether the instruction is complex (pulpv3) or not\n  output logic        is_subrot_o,\n\n  // MUL related control signals\n  output mul_opcode_e mult_operator_o,         // Multiplication operation selection\n  output logic        mult_int_en_o,           // perform integer multiplication\n  output logic        mult_dot_en_o,           // perform dot multiplication\n  output logic [0:0]  mult_imm_mux_o,          // Multiplication immediate mux selector\n  output logic        mult_sel_subword_o,      // Select subwords for 16x16 bit of multiplier\n  output logic [1:0]  mult_signed_mode_o,      // Multiplication in signed mode\n  output logic [1:0]  mult_dot_signed_o,       // Dot product in signed mode\n\n  // FPU\n  input  logic            fs_off_i, // Floating-Point State field from MSTATUS\n  input  logic [C_RM-1:0] frm_i,    // Rounding mode from float CSR\n\n  output logic [cv32e40p_fpu_pkg::FP_FORMAT_BITS-1:0]  fpu_dst_fmt_o,   // fpu destination format\n  output logic [cv32e40p_fpu_pkg::FP_FORMAT_BITS-1:0]  fpu_src_fmt_o,   // fpu source format\n  output logic [cv32e40p_fpu_pkg::INT_FORMAT_BITS-1:0] fpu_int_fmt_o,   // fpu integer format (for casts)\n\n  // APU\n  output logic                   apu_en_o,\n  output logic [APU_WOP_CPU-1:0] apu_op_o,\n  output logic [1:0]             apu_lat_o,\n  output logic [2:0]             fp_rnd_mode_o,\n\n  // register file related signals\n  output logic        regfile_mem_we_o,        // write enable for regfile\n  output logic        regfile_alu_we_o,        // write enable for 2nd regfile port\n  output logic        regfile_alu_we_dec_o,    // write enable for 2nd regfile port without deassert\n  output logic        regfile_alu_waddr_sel_o, // Select register write address for ALU/MUL operations\n\n  // CSR manipulation\n  output logic        csr_access_o,            // access to CSR\n  output logic        csr_status_o,            // access to xstatus CSR\n  output csr_opcode_e csr_op_o,                // operation to perform on CSR\n  input  PrivLvl_t    current_priv_lvl_i,      // The current privilege level\n\n  // LD/ST unit signals\n  output logic        data_req_o,              // start transaction to data memory\n  output logic        data_we_o,               // data memory write enable\n  output logic        prepost_useincr_o,       // when not active bypass the alu result for address calculation\n  output logic [1:0]  data_type_o,             // data type on data memory: byte, half word or word\n  output logic [1:0]  data_sign_extension_o,   // sign extension on read data from data memory / NaN boxing\n  output logic [1:0]  data_reg_offset_o,       // offset in byte inside register for stores\n  output logic        data_load_event_o,       // data request is in the special event range\n\n  // Atomic memory access\n  output logic [5:0] atop_o,\n\n  // hwloop signals\n  output logic [2:0]  hwlp_we_o,               // write enable for hwloop regs\n  output logic [1:0]  hwlp_target_mux_sel_o,   // selects immediate for hwloop target\n  output logic [1:0]  hwlp_start_mux_sel_o,    // selects hwloop start address input\n  output logic        hwlp_cnt_mux_sel_o,      // selects hwloop counter input\n\n  input  logic        debug_mode_i,            // processor is in debug mode\n  input  logic        debug_wfi_no_sleep_i,    // do not let WFI cause sleep\n\n  // jump/branches\n  output logic [1:0]  ctrl_transfer_insn_in_dec_o,  // control transfer instruction without deassert\n  output logic [1:0]  ctrl_transfer_insn_in_id_o,   // control transfer instructio is decoded\n  output logic [1:0]  ctrl_transfer_target_mux_sel_o,        // jump target selection\n\n  // HPM related control signals\n  input  logic [31:0] mcounteren_i\n);\n\n  // write enable/request control\n  logic       regfile_mem_we;\n  logic       regfile_alu_we;\n  logic       data_req;\n  logic [2:0] hwlp_we;\n  logic       csr_illegal;\n  logic [1:0] ctrl_transfer_insn;\n\n  csr_opcode_e csr_op;\n\n  logic       alu_en;\n  logic       mult_int_en;\n  logic       mult_dot_en;\n  logic       apu_en;\n\n  // this instruction needs floating-point rounding-mode verification\n  logic check_fprm;\n\n  logic [cv32e40p_fpu_pkg::OP_BITS-1:0] fpu_op;     // fpu operation\n  logic                                 fpu_op_mod; // fpu operation modifier\n  logic                                 fpu_vec_op; // fpu vectorial operation\n  // unittypes for latencies to help us decode for APU\n  enum logic[1:0] {ADDMUL, DIVSQRT, NONCOMP, CONV} fp_op_group;\n\n\n  /////////////////////////////////////////////\n  //   ____                     _            //\n  //  |  _ \\  ___  ___ ___   __| | ___ _ __  //\n  //  | | | |/ _ \\/ __/ _ \\ / _` |/ _ \\ '__| //\n  //  | |_| |  __/ (_| (_) | (_| |  __/ |    //\n  //  |____/ \\___|\\___\\___/ \\__,_|\\___|_|    //\n  //                                         //\n  /////////////////////////////////////////////\n\n  always_comb\n  begin: instruction_decoder\n    ctrl_transfer_insn             = BRANCH_NONE;\n    ctrl_transfer_target_mux_sel_o = JT_JAL;\n\n    alu_en                         = 1'b1;\n    alu_operator_o                 = ALU_SLTU;\n    alu_op_a_mux_sel_o             = OP_A_REGA_OR_FWD;\n    alu_op_b_mux_sel_o             = OP_B_REGB_OR_FWD;\n    alu_op_c_mux_sel_o             = OP_C_REGC_OR_FWD;\n    alu_vec_o                      = 1'b0;\n    alu_vec_mode_o                 = VEC_MODE32;\n    scalar_replication_o           = 1'b0;\n    scalar_replication_c_o         = 1'b0;\n    regc_mux_o                     = REGC_ZERO;\n    imm_a_mux_sel_o                = IMMA_ZERO;\n    imm_b_mux_sel_o                = IMMB_I;\n\n    mult_int_en                    = 1'b0;\n    mult_dot_en                    = 1'b0;\n    mult_operator_o                = MUL_I;\n    mult_imm_mux_o                 = MIMM_ZERO;\n    mult_signed_mode_o             = 2'b00;\n    mult_sel_subword_o             = 1'b0;\n    mult_dot_signed_o              = 2'b00;\n\n    apu_en                         = 1'b0;\n    apu_op_o                       = '0;\n    apu_lat_o                      = '0;\n    fp_rnd_mode_o                  = '0;\n    fpu_op                         = cv32e40p_fpu_pkg::SGNJ;\n    fpu_op_mod                     = 1'b0;\n    fpu_vec_op                     = 1'b0;\n    fpu_dst_fmt_o                  = cv32e40p_fpu_pkg::FP32;\n    fpu_src_fmt_o                  = cv32e40p_fpu_pkg::FP32;\n    fpu_int_fmt_o                  = cv32e40p_fpu_pkg::INT32;\n    check_fprm                     = 1'b0;\n    fp_op_group                    = ADDMUL;\n\n    regfile_mem_we                 = 1'b0;\n    regfile_alu_we                 = 1'b0;\n    regfile_alu_waddr_sel_o        = 1'b1;\n\n    prepost_useincr_o              = 1'b1;\n\n    hwlp_we                        = 3'b0;\n    hwlp_target_mux_sel_o          = 2'b0;\n    hwlp_start_mux_sel_o           = 2'b0;\n    hwlp_cnt_mux_sel_o             = 1'b0;\n\n    csr_access_o                   = 1'b0;\n    csr_status_o                   = 1'b0;\n    csr_illegal                    = 1'b0;\n    csr_op                         = CSR_OP_READ;\n    mret_insn_o                    = 1'b0;\n    uret_insn_o                    = 1'b0;\n\n    dret_insn_o                    = 1'b0;\n\n    data_we_o                      = 1'b0;\n    data_type_o                    = 2'b00;\n    data_sign_extension_o          = 2'b00;\n    data_reg_offset_o              = 2'b00;\n    data_req                       = 1'b0;\n    data_load_event_o              = 1'b0;\n\n    atop_o                         = 6'b000000;\n\n    illegal_insn_o                 = 1'b0;\n    ebrk_insn_o                    = 1'b0;\n    ecall_insn_o                   = 1'b0;\n    wfi_o                          = 1'b0;\n\n    fencei_insn_o                  = 1'b0;\n\n    rega_used_o                    = 1'b0;\n    regb_used_o                    = 1'b0;\n    regc_used_o                    = 1'b0;\n    reg_fp_a_o                     = 1'b0;\n    reg_fp_b_o                     = 1'b0;\n    reg_fp_c_o                     = 1'b0;\n    reg_fp_d_o                     = 1'b0;\n\n    bmask_a_mux_o                  = BMASK_A_ZERO;\n    bmask_b_mux_o                  = BMASK_B_ZERO;\n    alu_bmask_a_mux_sel_o          = BMASK_A_IMM;\n    alu_bmask_b_mux_sel_o          = BMASK_B_IMM;\n\n    is_clpx_o                      = 1'b0;\n    is_subrot_o                    = 1'b0;\n\n    mret_dec_o                     = 1'b0;\n    uret_dec_o                     = 1'b0;\n    dret_dec_o                     = 1'b0;\n\n    unique case (instr_rdata_i[6:0])\n\n      //////////////////////////////////////\n      //      _ _   _ __  __ ____  ____   //\n      //     | | | | |  \\/  |  _ \\/ ___|  //\n      //  _  | | | | | |\\/| | |_) \\___ \\  //\n      // | |_| | |_| | |  | |  __/ ___) | //\n      //  \\___/ \\___/|_|  |_|_|   |____/  //\n      //                                  //\n      //////////////////////////////////////\n\n      OPCODE_JAL: begin   // Jump and Link\n        ctrl_transfer_target_mux_sel_o = JT_JAL;\n        ctrl_transfer_insn    = BRANCH_JAL;\n        // Calculate and store PC+4\n        alu_op_a_mux_sel_o  = OP_A_CURRPC;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMMB_PCINCR;\n        alu_operator_o      = ALU_ADD;\n        regfile_alu_we      = 1'b1;\n        // Calculate jump target (= PC + UJ imm)\n      end\n\n      OPCODE_JALR: begin  // Jump and Link Register\n        ctrl_transfer_target_mux_sel_o = JT_JALR;\n        ctrl_transfer_insn    = BRANCH_JALR;\n        // Calculate and store PC+4\n        alu_op_a_mux_sel_o  = OP_A_CURRPC;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMMB_PCINCR;\n        alu_operator_o      = ALU_ADD;\n        regfile_alu_we      = 1'b1;\n        // Calculate jump target (= RS1 + I imm)\n        rega_used_o         = 1'b1;\n\n        if (instr_rdata_i[14:12] != 3'b0) begin\n          ctrl_transfer_insn = BRANCH_NONE;\n          regfile_alu_we     = 1'b0;\n          illegal_insn_o     = 1'b1;\n        end\n      end\n\n      OPCODE_BRANCH: begin // Branch\n        ctrl_transfer_target_mux_sel_o = JT_COND;\n        ctrl_transfer_insn             = BRANCH_COND;\n        alu_op_c_mux_sel_o             = OP_C_JT;\n        rega_used_o                    = 1'b1;\n        regb_used_o                    = 1'b1;\n\n        unique case (instr_rdata_i[14:12])\n          3'b000 : alu_operator_o = ALU_EQ;\n          3'b001 : alu_operator_o = ALU_NE;\n          3'b100 : alu_operator_o = ALU_LTS;\n          3'b101 : alu_operator_o = ALU_GES;\n          3'b110 : alu_operator_o = ALU_LTU;\n          3'b111 : alu_operator_o = ALU_GEU;\n          default: illegal_insn_o = 1'b1;\n        endcase\n      end\n\n\n      //////////////////////////////////\n      //  _     ____    ______ _____  //\n      // | |   |  _ \\  / / ___|_   _| //\n      // | |   | | | |/ /\\___ \\ | |   //\n      // | |___| |_| / /  ___) || |   //\n      // |_____|____/_/  |____/ |_|   //\n      //                              //\n      //////////////////////////////////\n\n      OPCODE_STORE: begin\n        data_req           = 1'b1;\n        data_we_o          = 1'b1;\n        rega_used_o        = 1'b1;\n        regb_used_o        = 1'b1;\n        alu_operator_o     = ALU_ADD;\n        // pass write data through ALU operand c\n        alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n        // offset from immediate\n        imm_b_mux_sel_o    = IMMB_S;\n        alu_op_b_mux_sel_o = OP_B_IMM;\n\n        // store size\n        unique case (instr_rdata_i[14:12])\n          3'b000 : data_type_o = 2'b10; // SB\n          3'b001 : data_type_o = 2'b01; // SH\n          3'b010 : data_type_o = 2'b00; // SW\n          default: begin\n            illegal_insn_o = 1'b1;\n            data_req       = 1'b0;\n            data_we_o      = 1'b0;\n          end\n        endcase\n      end\n\n      OPCODE_LOAD: begin\n        data_req           = 1'b1;\n        regfile_mem_we     = 1'b1;\n        rega_used_o        = 1'b1;\n        alu_operator_o     = ALU_ADD;\n        // offset from immediate\n        alu_op_b_mux_sel_o = OP_B_IMM;\n        imm_b_mux_sel_o    = IMMB_I;\n\n        // sign/zero extension\n        data_sign_extension_o = {1'b0,~instr_rdata_i[14]};\n\n        // load size\n        unique case (instr_rdata_i[14:12])\n          3'b000, 3'b100: data_type_o = 2'b10; // LB/LBU\n          3'b001, 3'b101: data_type_o = 2'b01; // LH/LHU\n          3'b010        : data_type_o = 2'b00; // LW\n          default: begin\n            illegal_insn_o = 1'b1;\n          end\n        endcase\n      end\n\n      OPCODE_AMO: begin\n        if (A_EXTENSION) begin : decode_amo\n          if (instr_rdata_i[14:12] == 3'b010) begin // RV32A Extension (word)\n            data_req          = 1'b1;\n            data_type_o       = 2'b00;\n            rega_used_o       = 1'b1;\n            regb_used_o       = 1'b1;\n            regfile_mem_we    = 1'b1;\n            prepost_useincr_o = 1'b0; // only use alu_operand_a as address (not a+b)\n            alu_op_a_mux_sel_o = OP_A_REGA_OR_FWD;\n\n            data_sign_extension_o = 1'b1;\n\n            // Apply AMO instruction at `atop_o`.\n            atop_o = {1'b1, instr_rdata_i[31:27]};\n\n            unique case (instr_rdata_i[31:27])\n              AMO_LR: begin\n                data_we_o = 1'b0;\n              end\n              AMO_SC,\n              AMO_SWAP,\n              AMO_ADD,\n              AMO_XOR,\n              AMO_AND,\n              AMO_OR,\n              AMO_MIN,\n              AMO_MAX,\n              AMO_MINU,\n              AMO_MAXU: begin\n                data_we_o = 1'b1;\n                alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD; // pass write data through ALU operand c\n              end\n              default : illegal_insn_o = 1'b1;\n            endcase\n          end\n          else begin\n            illegal_insn_o = 1'b1;\n          end\n        end else begin : no_decode_amo\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      //////////////////////////\n      //     _    _    _   _  //\n      //    / \\  | |  | | | | //\n      //   / _ \\ | |  | | | | //\n      //  / ___ \\| |__| |_| | //\n      // /_/   \\_\\_____\\___/  //\n      //                      //\n      //////////////////////////\n\n      OPCODE_LUI: begin  // Load Upper Immediate\n        alu_op_a_mux_sel_o  = OP_A_IMM;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_a_mux_sel_o     = IMMA_ZERO;\n        imm_b_mux_sel_o     = IMMB_U;\n        alu_operator_o      = ALU_ADD;\n        regfile_alu_we      = 1'b1;\n      end\n\n      OPCODE_AUIPC: begin  // Add Upper Immediate to PC\n        alu_op_a_mux_sel_o  = OP_A_CURRPC;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMMB_U;\n        alu_operator_o      = ALU_ADD;\n        regfile_alu_we      = 1'b1;\n      end\n\n      OPCODE_OPIMM: begin // Register-Immediate ALU Operations\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMMB_I;\n        regfile_alu_we      = 1'b1;\n        rega_used_o         = 1'b1;\n\n        unique case (instr_rdata_i[14:12])\n          3'b000: alu_operator_o = ALU_ADD;  // Add Immediate\n          3'b010: alu_operator_o = ALU_SLTS; // Set to one if Lower Than Immediate\n          3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned\n          3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate\n          3'b110: alu_operator_o = ALU_OR;   // Or with Immediate\n          3'b111: alu_operator_o = ALU_AND;  // And with Immediate\n\n          3'b001: begin\n            alu_operator_o = ALU_SLL;  // Shift Left Logical by Immediate\n            if (instr_rdata_i[31:25] != 7'b0)\n              illegal_insn_o = 1'b1;\n          end\n\n          3'b101: begin\n            if (instr_rdata_i[31:25] == 7'b0)\n              alu_operator_o = ALU_SRL;  // Shift Right Logical by Immediate\n            else if (instr_rdata_i[31:25] == 7'b010_0000)\n              alu_operator_o = ALU_SRA;  // Shift Right Arithmetically by Immediate\n            else\n              illegal_insn_o = 1'b1;\n          end\n\n\n        endcase\n      end\n\n      OPCODE_OP: begin\n\n        // PREFIX 11\n        if (instr_rdata_i[31:30] == 2'b11) begin\n          illegal_insn_o = 1'b1;\n\n        // PREFIX 10\n        end else if (instr_rdata_i[31:30] == 2'b10) begin\n          if (instr_rdata_i[29:25] == 5'b00000) begin\n            illegal_insn_o = 1'b1;\n\n          ///////////////////////\n          // VECTORIAL FLOAT OPS\n          ///////////////////////\n          end else begin\n            // Vectorial FP\n            if (FPU == 1 && C_XFVEC == 1) begin\n\n              // using APU instead of ALU\n              alu_en           = 1'b0;\n              apu_en           = 1'b1;\n              // by default, set all registers to FP registers and use 2\n              rega_used_o      = 1'b1;\n              regb_used_o      = 1'b1;\n              if (ZFINX == 0) begin\n                reg_fp_a_o     = 1'b1;\n                reg_fp_b_o     = 1'b1;\n                reg_fp_d_o     = 1'b1;\n              end else begin\n                reg_fp_a_o     = 1'b0;\n                reg_fp_b_o     = 1'b0;\n                reg_fp_d_o     = 1'b0;\n              end\n              fpu_vec_op       = 1'b1;\n              // replication bit comes from instruction (can change for some ops)\n              scalar_replication_o = instr_rdata_i[14];\n              // by default we need to verify rm is legal but assume it is for now\n              check_fprm       = 1'b1;\n              fp_rnd_mode_o    = frm_i; // all vectorial ops have rm from fcsr\n\n              // Decode Formats\n              unique case (instr_rdata_i[13:12])\n                // FP32\n                2'b00: begin\n                  fpu_dst_fmt_o  = cv32e40p_fpu_pkg::FP32;\n                  alu_vec_mode_o = VEC_MODE32;\n                end\n                // FP16ALT\n                2'b01: begin\n                  fpu_dst_fmt_o  = cv32e40p_fpu_pkg::FP16ALT;\n                  alu_vec_mode_o = VEC_MODE16;\n                end\n                // FP16\n                2'b10: begin\n                  fpu_dst_fmt_o  = cv32e40p_fpu_pkg::FP16;\n                  alu_vec_mode_o = VEC_MODE16;\n                end\n                // FP8\n                2'b11: begin\n                  fpu_dst_fmt_o  = cv32e40p_fpu_pkg::FP8;\n                  alu_vec_mode_o = VEC_MODE8;\n                end\n              endcase\n\n              // By default, src=dst\n              fpu_src_fmt_o = fpu_dst_fmt_o;\n\n              // decode vectorial FP instruction\n              unique case (instr_rdata_i[29:25]) inside\n                // vfadd.vfmt - Vectorial FP Addition\n                5'b00001: begin\n                  fpu_op      = cv32e40p_fpu_pkg::ADD;\n                  fp_op_group = ADDMUL;\n                  // FPnew needs addition operands as operand B and C\n                  alu_op_b_mux_sel_o     = OP_B_REGA_OR_FWD;\n                  alu_op_c_mux_sel_o     = OP_C_REGB_OR_FWD;\n                  scalar_replication_o   = 1'b0;\n                  scalar_replication_c_o = instr_rdata_i[14];\n                end\n                // vfsub.vfmt - Vectorial FP Subtraction\n                5'b00010: begin\n                  fpu_op      = cv32e40p_fpu_pkg::ADD;\n                  fpu_op_mod  = 1'b1;\n                  fp_op_group = ADDMUL;\n                  // FPnew needs addition operands as operand B and C\n                  alu_op_b_mux_sel_o     = OP_B_REGA_OR_FWD;\n                  alu_op_c_mux_sel_o     = OP_C_REGB_OR_FWD;\n                  scalar_replication_o   = 1'b0;\n                  scalar_replication_c_o = instr_rdata_i[14];\n                end\n                // vfmul.vfmt - Vectorial FP Multiplication\n                5'b00011: begin\n                  fpu_op      = cv32e40p_fpu_pkg::MUL;\n                  fp_op_group = ADDMUL;\n                end\n                // vfdiv.vfmt - Vectorial FP Division\n                5'b00100: begin\n                  fpu_op      = cv32e40p_fpu_pkg::DIV;\n                  fp_op_group = DIVSQRT;\n                end\n                // vfmin.vfmt - Vectorial FP Minimum\n                5'b00101: begin\n                  fpu_op        = cv32e40p_fpu_pkg::MINMAX;\n                  fp_rnd_mode_o = 3'b000; // min\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0; // instruction encoded in rm\n                end\n                // vfmax.vfmt - Vectorial FP Maximum\n                5'b00110: begin\n                  fpu_op        = cv32e40p_fpu_pkg::MINMAX;\n                  fp_rnd_mode_o = 3'b001; // max\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0; // instruction encoded in rm\n                end\n                // vfsqrt.vfmt - Vectorial FP Square Root\n                5'b00111: begin\n                  regb_used_o = 1'b0;\n                  fpu_op      = cv32e40p_fpu_pkg::SQRT;\n                  fp_op_group = DIVSQRT;\n                  // rs2 and R must be zero\n                  if ((instr_rdata_i[24:20] != 5'b00000) || instr_rdata_i[14]) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                // vfmac.vfmt - Vectorial FP Multiply-Accumulate\n                5'b01000: begin\n                  regc_used_o = 1'b1;\n                  regc_mux_o  = REGC_RD; // third operand is rd\n                  if (ZFINX == 0) begin\n                    reg_fp_c_o = 1'b1;\n                  end else begin\n                    reg_fp_c_o = 1'b0;\n                  end\n                  fpu_op      = cv32e40p_fpu_pkg::FMADD;\n                  fp_op_group = ADDMUL;\n                end\n                // vfmre.vfmt - Vectorial FP Multiply-Reduce\n                5'b01001: begin\n                  regc_used_o = 1'b1;\n                  regc_mux_o  = REGC_RD; // third operand is rd\n                  if (ZFINX == 0) begin\n                    reg_fp_c_o = 1'b1;\n                  end else begin\n                    reg_fp_c_o = 1'b0;\n                  end\n                  fpu_op      = cv32e40p_fpu_pkg::FMADD;\n                  fpu_op_mod  = 1'b1;\n                  fp_op_group = ADDMUL;\n                end\n                // Moves, Conversions, Classifications\n                5'b01100: begin\n                  regb_used_o          = 1'b0;\n                  scalar_replication_o = 1'b0;\n                  // Decode Operation in rs2\n                  unique case (instr_rdata_i[24:20]) inside\n                    // vfmv.{x.vfmt/vfmt.x} - Vectorial FP Reg <-> GP Reg Moves\n                    5'b00000: begin\n                      alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n                      fpu_op             = cv32e40p_fpu_pkg::SGNJ;\n                      fp_rnd_mode_o      = 3'b011;  // passthrough without checking nan-box\n                      fp_op_group        = NONCOMP;\n                      check_fprm         = 1'b0;\n                      // GP reg to FP reg\n                      if (instr_rdata_i[14]) begin\n                        reg_fp_a_o       = 1'b0; // go from integer regfile\n                        fpu_op_mod       = 1'b0; // nan-box result\n                      end\n                      // FP reg to GP reg\n                      else begin\n                        reg_fp_d_o       = 1'b0; // go to integer regfile\n                        fpu_op_mod       = 1'b1; // sign-extend result\n                      end\n                    end\n                    // vfclass.vfmt - Vectorial FP Classifications\n                    5'b00001: begin\n                      reg_fp_d_o    = 1'b0; // go to integer regfile\n                      fpu_op        = cv32e40p_fpu_pkg::CLASSIFY;\n                      fp_rnd_mode_o = 3'b000;\n                      fp_op_group   = NONCOMP;\n                      check_fprm    = 1'b0;\n                      // R must not be set\n                      if (instr_rdata_i[14]) illegal_insn_o = 1'b1;\n                    end\n                    // vfcvt.{x.vfmt/vfmt.x} - Vectorial FP <-> Int Conversions\n                    5'b0001?: begin\n                      fp_op_group = CONV;\n                      fpu_op_mod  = instr_rdata_i[14]; // signed/unsigned switch\n                      // Integer width matches FP width\n                      unique case (instr_rdata_i[13:12])\n                        // FP32\n                        2'b00 : fpu_int_fmt_o = cv32e40p_fpu_pkg::INT32;\n                        // FP16[ALT]\n                        2'b01,\n                        2'b10: fpu_int_fmt_o = cv32e40p_fpu_pkg::INT16;\n                        // FP8\n                        2'b11: fpu_int_fmt_o = cv32e40p_fpu_pkg::INT8;\n                      endcase\n                      // Int to FP conversion\n                      if (instr_rdata_i[20]) begin\n                        reg_fp_a_o = 1'b0; // go from integer regfile\n                        fpu_op     = cv32e40p_fpu_pkg::I2F;\n                      end\n                      // FP to Int conversion\n                      else begin\n                        reg_fp_d_o = 1'b0; // go to integer regfile\n                        fpu_op     = cv32e40p_fpu_pkg::F2I;\n                      end\n                    end\n                    // vfcvt.vfmt.vfmt - Vectorial FP <-> FP Conversions\n                    5'b001??: begin\n                      fpu_op      = cv32e40p_fpu_pkg::F2F;\n                      fp_op_group = CONV;\n                      // check source format\n                      unique case (instr_rdata_i[21:20])\n                        // Only process instruction if corresponding extension is active (static)\n                        2'b00: begin\n                          fpu_src_fmt_o = cv32e40p_fpu_pkg::FP32;\n                          if (~C_RVF) illegal_insn_o = 1'b1;\n                        end\n                        2'b01: begin\n                          fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                          if (~C_XF16ALT) illegal_insn_o = 1'b1;\n                        end\n                        2'b10: begin\n                          fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16;\n                          if (~C_XF16) illegal_insn_o = 1'b1;\n                        end\n                        2'b11: begin\n                          fpu_src_fmt_o = cv32e40p_fpu_pkg::FP8;\n                          if (~C_XF8) illegal_insn_o = 1'b1;\n                        end\n                      endcase\n                      // R must not be set\n                      if (instr_rdata_i[14]) illegal_insn_o = 1'b1;\n                    end\n                    // others\n                    default : illegal_insn_o = 1'b1;\n                  endcase\n                end\n                // vfsgnj.vfmt - Vectorial FP Sign Injection\n                5'b01101: begin\n                  fpu_op        = cv32e40p_fpu_pkg::SGNJ;\n                  fp_rnd_mode_o = 3'b000; // sgnj\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfsgnjn.vfmt - Vectorial FP Negated Sign Injection\n                5'b01110: begin\n                  fpu_op        = cv32e40p_fpu_pkg::SGNJ;\n                  fp_rnd_mode_o = 3'b001; // sgnjn\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfsgnjx.vfmt - Vectorial FP Xored Sign Injection\n                5'b01111: begin\n                  fpu_op        = cv32e40p_fpu_pkg::SGNJ;\n                  fp_rnd_mode_o = 3'b010; // sgnjx\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfeq.vfmt - Vectorial FP Equals\n                5'b10000: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fp_rnd_mode_o = 3'b010; // eq\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfne.vfmt - Vectorial FP Not Equals\n                5'b10001: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fpu_op_mod    = 1'b1; // invert output\n                  fp_rnd_mode_o = 3'b010; // eq\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vflt.vfmt - Vectorial FP Less Than\n                5'b10010: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fp_rnd_mode_o = 3'b001; // lt\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfge.vfmt - Vectorial FP Greater Than or Equals\n                5'b10011: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fpu_op_mod    = 1'b1; // invert output\n                  fp_rnd_mode_o = 3'b001; // lt\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfle.vfmt - Vectorial FP Less Than or Equals\n                5'b10100: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fp_rnd_mode_o = 3'b000; // le\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfgt.vfmt - Vectorial FP Greater Than\n                5'b10101: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fpu_op_mod    = 1'b1; // invert output\n                  fp_rnd_mode_o = 3'b000; // le\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfcpk{a-d}.vfmt.s/d\n                5'b110??: begin\n                  // vfcpk{{a/c}/{b/d}} selection in R bit\n                  fpu_op_mod           = instr_rdata_i[14];\n                  fp_op_group          = CONV;\n                  scalar_replication_o = 1'b0;\n\n                  if (instr_rdata_i[25]) fpu_op = cv32e40p_fpu_pkg::CPKCD; // vfcpk{c/d}\n                  else fpu_op = cv32e40p_fpu_pkg::CPKAB; // vfcpk{a/b}\n\n                  // vfcpk{a-d}.vfmt.d - from double\n                  if (instr_rdata_i[26]) begin\n                    fpu_src_fmt_o  = cv32e40p_fpu_pkg::FP64;\n                    if (~C_RVD) illegal_insn_o = 1'b1;\n                  end\n                  // vfcpk{a-d}.vfmt.s\n                  else begin\n                    fpu_src_fmt_o  = cv32e40p_fpu_pkg::FP32;\n                    if (~C_RVF) illegal_insn_o = 1'b1;\n                  end\n                  // Resolve legal vfcpk / format combinations (mostly static)\n                  if (fpu_op == cv32e40p_fpu_pkg::CPKCD) begin // vfcpk{c/d} not possible unless FP8 and FLEN>=64\n                    if (~C_XF8 || ~C_RVD) illegal_insn_o = 1'b1;\n                  end else begin\n                    if (instr_rdata_i[14]) begin // vfcpkb\n                      // vfcpkb not possible for FP32\n                      if (fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP32) illegal_insn_o = 1'b1;\n                      // vfcpkb not possible for FP16[ALT] if not RVD\n                      if (~C_RVD && (fpu_dst_fmt_o != cv32e40p_fpu_pkg::FP8)) illegal_insn_o = 1'b1;\n                    end\n                  end\n                end\n                // Rest are illegal instructions\n                default: begin\n                  illegal_insn_o = 1'b1;\n                end\n              endcase\n\n              // check enabled formats (static)\n              // need RVD for F vectors\n              if ((~C_RVF || ~C_RVD) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP32) illegal_insn_o = 1'b1;\n              // need RVF for F16 vectors\n              if ((~C_XF16 || ~C_RVF) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16) illegal_insn_o = 1'b1;\n              // need RVF for F16 vectors\n              if ((~C_XF16ALT || ~C_RVF) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16ALT) begin\n                illegal_insn_o = 1'b1;\n              end\n              // need F16 for F8 vectors\n              if ((~C_XF8 || (~C_XF16 && ~C_XF16ALT)) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP8) begin\n                illegal_insn_o = 1'b1;\n              end\n\n              // check rounding mode\n              if (check_fprm) begin\n                unique case (frm_i) inside\n                  [3'b000:3'b100] : ; //legal rounding modes\n                  default         : illegal_insn_o = 1'b1;\n                endcase\n              end\n\n              // Set latencies for FPnew from config. The C_LAT constants contain the number\n              // of pipeline registers. the APU takes the following values:\n              // 1 = single cycle (no latency), 2 = one pipestage, 3 = two or more pipestages\n              case (fp_op_group)\n                // ADDMUL has format dependent latency\n                ADDMUL : begin\n                  unique case (fpu_dst_fmt_o)\n                    cv32e40p_fpu_pkg::FP32    : apu_lat_o = (FPU_ADDMUL_LAT<2)? FPU_ADDMUL_LAT+1: 2'h3;\n                    cv32e40p_fpu_pkg::FP16    : apu_lat_o = (C_LAT_FP16<2)    ? C_LAT_FP16+1    : 2'h3;\n                    cv32e40p_fpu_pkg::FP16ALT : apu_lat_o = (C_LAT_FP16ALT<2) ? C_LAT_FP16ALT+1 : 2'h3;\n                    cv32e40p_fpu_pkg::FP8     : apu_lat_o = (C_LAT_FP8<2)     ? C_LAT_FP8+1     : 2'h3;\n                    default : ;\n                  endcase\n                end\n                // DIVSQRT is iterative and takes more than 2 cycles\n                DIVSQRT : apu_lat_o = 2'h3;\n                // NONCOMP uses the same latency for all formats\n                NONCOMP : apu_lat_o = (FPU_OTHERS_LAT<2) ? FPU_OTHERS_LAT+1 : 2'h3;\n                // CONV uses the same latency for all formats\n                CONV    : apu_lat_o = (FPU_OTHERS_LAT<2) ? FPU_OTHERS_LAT+1 : 2'h3;\n              endcase\n\n              // Set FPnew OP and OPMOD as the APU op\n              apu_op_o = {fpu_vec_op, fpu_op_mod, fpu_op};\n\n            // no FPU or FPU and no Vectors\n            end else begin\n              illegal_insn_o = 1'b1;\n            end\n          end // Vectorial Float Ops\n\n        end  // PREFIX 10\n\n        // PREFIX 00/01\n        else begin\n          regfile_alu_we = 1'b1;\n          rega_used_o    = 1'b1;\n\n          if (~instr_rdata_i[28]) regb_used_o = 1'b1;\n\n          unique case ({instr_rdata_i[30:25], instr_rdata_i[14:12]})\n            // RV32I ALU operations\n            {6'b00_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add\n            {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub\n            {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLTS;  // Set Lower Than\n            {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned\n            {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor\n            {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or\n            {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And\n            {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical\n            {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical\n            {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic\n\n            // supported RV32M instructions\n            {6'b00_0001, 3'b000}: begin // mul\n              alu_en          = 1'b0;\n              mult_int_en     = 1'b1;\n              mult_operator_o = MUL_MAC32;\n              regc_mux_o      = REGC_ZERO;\n            end\n            {6'b00_0001, 3'b001}: begin // mulh\n              alu_en             = 1'b0;\n              mult_int_en        = 1'b1;\n              regc_used_o        = 1'b1;\n              regc_mux_o         = REGC_ZERO;\n              mult_signed_mode_o = 2'b11;\n              mult_operator_o    = MUL_H;\n            end\n            {6'b00_0001, 3'b010}: begin // mulhsu\n              alu_en             = 1'b0;\n              mult_int_en        = 1'b1;\n              regc_used_o        = 1'b1;\n              regc_mux_o         = REGC_ZERO;\n              mult_signed_mode_o = 2'b01;\n              mult_operator_o    = MUL_H;\n            end\n            {6'b00_0001, 3'b011}: begin // mulhu\n              alu_en             = 1'b0;\n              mult_int_en        = 1'b1;\n              regc_used_o        = 1'b1;\n              regc_mux_o         = REGC_ZERO;\n              mult_signed_mode_o = 2'b00;\n              mult_operator_o    = MUL_H;\n            end\n            {6'b00_0001, 3'b100}: begin // div\n              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              regb_used_o        = 1'b1;\n              alu_operator_o     = ALU_DIV;\n            end\n            {6'b00_0001, 3'b101}: begin // divu\n              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              regb_used_o        = 1'b1;\n              alu_operator_o     = ALU_DIVU;\n            end\n            {6'b00_0001, 3'b110}: begin // rem\n              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              regb_used_o        = 1'b1;\n              alu_operator_o     = ALU_REM;\n            end\n            {6'b00_0001, 3'b111}: begin // remu\n              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              regb_used_o        = 1'b1;\n              alu_operator_o     = ALU_REMU;\n            end\n\n            default: begin\n              illegal_insn_o = 1'b1;\n            end\n          endcase\n        end\n      end\n\n      ////////////////////////////\n      //  ______ _____  _    _  //\n      // |  ____|  __ \\| |  | | //\n      // | |__  | |__) | |  | | //\n      // |  __| |  ___/| |  | | //\n      // | |    | |    | |__| | //\n      // |_|    |_|     \\____/  //\n      //                        //\n      ////////////////////////////\n\n      // Floating Point arithmetic\n      OPCODE_OP_FP: begin\n        if (FPU == 1 && (ZFINX == 1 || fs_off_i == 1'b0)) begin\n\n          // using APU instead of ALU\n          alu_en           = 1'b0;\n          apu_en           = 1'b1;\n          // by default, set all registers to FP registers and use 2\n          rega_used_o      = 1'b1;\n          regb_used_o      = 1'b1;\n          if (ZFINX == 0) begin\n            reg_fp_a_o     = 1'b1;\n            reg_fp_b_o     = 1'b1;\n            reg_fp_d_o     = 1'b1;\n          end else begin\n            reg_fp_a_o     = 1'b0;\n            reg_fp_b_o     = 1'b0;\n            reg_fp_d_o     = 1'b0;\n          end\n          // by default we need to verify rm is legal but assume it is for now\n          check_fprm       = 1'b1;\n          fp_rnd_mode_o    = instr_rdata_i[14:12];\n\n          // Decode Formats (preliminary, can change for some ops)\n          unique case (instr_rdata_i[26:25])\n            // FP32\n            2'b00: fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP32;\n            // FP64\n            2'b01: fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP64;\n            // FP16 or FP16ALT\n            2'b10: begin\n              // FP16alt encoded in rm field\n              if (instr_rdata_i[14:12] == 3'b101) fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n              // this can still change to FP16ALT\n              else fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16;\n            end\n            // FP8\n            2'b11: fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP8;\n          endcase\n\n          // By default, src=dst\n          fpu_src_fmt_o = fpu_dst_fmt_o;\n\n          // decode FP instruction\n          unique case (instr_rdata_i[31:27])\n            // fadd.fmt - FP Addition\n            5'b00000: begin\n              fpu_op             = cv32e40p_fpu_pkg::ADD;\n              fp_op_group        = ADDMUL;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n            end\n            // fsub.fmt - FP Subtraction\n            5'b00001: begin\n              fpu_op             = cv32e40p_fpu_pkg::ADD;\n              fpu_op_mod         = 1'b1;\n              fp_op_group        = ADDMUL;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n            end\n            // fmul.fmt - FP Multiplication\n            5'b00010: begin\n              fpu_op      = cv32e40p_fpu_pkg::MUL;\n              fp_op_group = ADDMUL;\n            end\n            // fdiv.fmt - FP Division\n            5'b00011: begin\n              fpu_op      = cv32e40p_fpu_pkg::DIV;\n              fp_op_group = DIVSQRT;\n            end\n            // fsqrt.fmt - FP Square Root\n            5'b01011: begin\n              regb_used_o = 1'b0;\n              fpu_op      = cv32e40p_fpu_pkg::SQRT;\n              fp_op_group = DIVSQRT;\n              // rs2 must be zero\n              if (instr_rdata_i[24:20] != 5'b00000) illegal_insn_o = 1'b1;\n            end\n            // fsgn{j[n]/jx}.fmt - FP Sign Injection\n            5'b00100: begin\n              fpu_op        = cv32e40p_fpu_pkg::SGNJ;\n              fp_op_group   = NONCOMP;\n              check_fprm    = 1'b0; // instruction encoded in rm, do the check here\n              if (C_XF16ALT) begin  // FP16ALT instructions encoded in rm separately (static)\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b010], [3'b100:3'b110]})) begin\n                  illegal_insn_o = 1'b1;\n                end\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end else begin\n                  fp_rnd_mode_o = {1'b0, instr_rdata_i[13:12]};\n                end\n              end else begin\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b010]})) illegal_insn_o = 1'b1;\n              end\n            end\n            // fmin/fmax.fmt - FP Minimum / Maximum\n            5'b00101: begin\n              fpu_op        = cv32e40p_fpu_pkg::MINMAX;\n              fp_op_group   = NONCOMP;\n              check_fprm    = 1'b0; // instruction encoded in rm, do the check here\n              if (C_XF16ALT) begin  // FP16ALT instructions encoded in rm separately (static)\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b001], [3'b100:3'b101]})) begin\n                  illegal_insn_o = 1'b1;\n                end\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end else begin\n                  fp_rnd_mode_o = {1'b0, instr_rdata_i[13:12]};\n                end\n              end else begin\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b001]})) illegal_insn_o = 1'b1;\n              end\n            end\n            // fcvt.fmt.fmt - FP to FP Conversion\n            5'b01000: begin\n              regb_used_o   = 1'b0;\n              fpu_op        = cv32e40p_fpu_pkg::F2F;\n              fp_op_group   = CONV;\n              // bits [22:20] used, other bits must be 0\n              if (instr_rdata_i[24:23]) illegal_insn_o = 1'b1;\n              // check source format\n              unique case (instr_rdata_i[22:20])\n                // Only process instruction if corresponding extension is active (static)\n                3'b000: begin\n                  if (!(C_RVF && (C_XF16 || C_XF16ALT || C_XF8))) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP32;\n                end\n                3'b001: begin\n                  if (~C_RVD) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP64;\n                end\n                3'b010: begin\n                  if (~C_XF16) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16;\n                end\n                3'b110: begin\n                  if (~C_XF16ALT) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end\n                3'b011: begin\n                  if (~C_XF8) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP8;\n                end\n                default: illegal_insn_o = 1'b1;\n              endcase\n            end\n            // fmulex.s.fmt - FP Expanding Multiplication to FP32\n            5'b01001: begin\n              if (~C_XF16 && ~C_XF16ALT && ~C_XF8) illegal_insn_o = 1;\n              fpu_op        = cv32e40p_fpu_pkg::MUL;\n              fp_op_group   = ADDMUL;\n              // set dst format to FP32\n              fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP32;\n            end\n            // fmacex.s.fmt - FP Expanding Multipy-Accumulate to FP32\n            5'b01010: begin\n              if (~C_XF16 && ~C_XF16ALT && ~C_XF8) illegal_insn_o = 1;\n              regc_used_o = 1'b1;\n              regc_mux_o  = REGC_RD; // third operand is rd\n              if (ZFINX == 0) begin\n                reg_fp_c_o = 1'b1;\n              end else begin\n                reg_fp_c_o = 1'b0;\n              end\n              fpu_op      = cv32e40p_fpu_pkg::FMADD;\n              fp_op_group = ADDMUL;\n              // set dst format to FP32\n              fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP32;\n            end\n            // feq/flt/fle.fmt - FP Comparisons\n            5'b10100: begin\n              fpu_op        = cv32e40p_fpu_pkg::CMP;\n              fp_op_group   = NONCOMP;\n              reg_fp_d_o    = 1'b0; // go to integer regfile\n              check_fprm    = 1'b0; // instruction encoded in rm, do the check here\n              if (C_XF16ALT) begin  // FP16ALT instructions encoded in rm separately (static)\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b010], [3'b100:3'b110]})) begin\n                  illegal_insn_o = 1'b1;\n                end\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end else begin\n                  fp_rnd_mode_o = {1'b0, instr_rdata_i[13:12]};\n                end\n              end else begin\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b010]})) illegal_insn_o = 1'b1;\n              end\n            end\n            // fcvt.ifmt.fmt - FP to Int Conversion\n            5'b11000: begin\n              regb_used_o = 1'b0;\n              reg_fp_d_o  = 1'b0; // go to integer regfile\n              fpu_op      = cv32e40p_fpu_pkg::F2I;\n              fp_op_group = CONV;\n              fpu_op_mod  = instr_rdata_i[20]; // signed/unsigned switch\n\n              unique case (instr_rdata_i[26:25]) //fix for casting to different formats other than FP32\n                2'b00: begin\n                  if (~C_RVF) illegal_insn_o = 1;\n                  else fpu_src_fmt_o = cv32e40p_fpu_pkg::FP32;\n                end\n                2'b01: begin\n                  if (~C_RVD) illegal_insn_o = 1;\n                  else fpu_src_fmt_o = cv32e40p_fpu_pkg::FP64;\n                end\n                2'b10: begin\n                  if (instr_rdata_i[14:12] == 3'b101) begin\n                    if (~C_XF16ALT) illegal_insn_o = 1;\n                    else fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  end else if (~C_XF16) begin\n                    illegal_insn_o = 1;\n                  end else begin\n                    fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16;\n                  end\n                end\n                2'b11: begin\n                  if (~C_XF8) illegal_insn_o = 1;\n                  else fpu_src_fmt_o = cv32e40p_fpu_pkg::FP8;\n                end\n              endcase // unique case (instr_rdata_i[26:25])\n              // bits [21:20] used, other bits must be 0\n              if (instr_rdata_i[24:21]) illegal_insn_o = 1'b1;   // in RV32, no casts to L allowed.\n            end\n            // fcvt.fmt.ifmt - Int to FP Conversion\n            5'b11010: begin\n              regb_used_o = 1'b0;\n              reg_fp_a_o  = 1'b0; // go from integer regfile\n              fpu_op      = cv32e40p_fpu_pkg::I2F;\n              fp_op_group = CONV;\n              fpu_op_mod  = instr_rdata_i[20]; // signed/unsigned switch\n              // bits [21:20] used, other bits must be 0\n              if (instr_rdata_i[24:21]) illegal_insn_o = 1'b1;   // in RV32, no casts to L allowed.\n            end\n            // move and class\n            5'b11100: begin\n              regb_used_o = 1'b0;\n              reg_fp_d_o  = 1'b0; // go to integer regfile\n              fp_op_group = NONCOMP;\n              check_fprm  = 1'b0; // instruction encoded in rm, do the check here\n              // fmv.x.fmt - FPR to GPR Move\n              if ((ZFINX == 0 && instr_rdata_i[14:12] == 3'b000) || (C_XF16ALT && instr_rdata_i[14:12] == 3'b100)) begin\n                alu_op_b_mux_sel_o  = OP_B_REGA_OR_FWD; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n                fpu_op              = cv32e40p_fpu_pkg::SGNJ; // mapped to SGNJ-passthrough since no recoding\n                fpu_op_mod          = 1'b1;    // sign-extend result\n                fp_rnd_mode_o       = 3'b011;  // passthrough without checking nan-box\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end\n              // fclass.fmt - FP Classify\n              end else if (instr_rdata_i[14:12] == 3'b001 || (C_XF16ALT && instr_rdata_i[14:12] == 3'b101)) begin\n                fpu_op        = cv32e40p_fpu_pkg::CLASSIFY;\n                fp_rnd_mode_o = 3'b000;\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end\n              end else begin\n                illegal_insn_o = 1'b1;\n              end\n              // rs2 must be zero\n              if (instr_rdata_i[24:20]) illegal_insn_o = 1'b1;\n            end\n            // fmv.fmt.x - GPR to FPR Move\n            5'b11110: begin\n              regb_used_o         = 1'b0;\n              reg_fp_a_o          = 1'b0; // go from integer regfile\n              alu_op_b_mux_sel_o  = OP_B_REGA_OR_FWD; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n              fpu_op              = cv32e40p_fpu_pkg::SGNJ; // mapped to SGNJ-passthrough since no recoding\n              fpu_op_mod          = 1'b0;    // nan-box result\n              fp_op_group         = NONCOMP;\n              fp_rnd_mode_o       = 3'b011;  // passthrough without checking nan-box\n              check_fprm          = 1'b0; // instruction encoded in rm, do the check here\n              if ((ZFINX == 0 && instr_rdata_i[14:12] == 3'b000) || (C_XF16ALT && instr_rdata_i[14:12] == 3'b100)) begin\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end\n              end else begin\n                illegal_insn_o = 1'b1;\n              end\n              // rs2 must be zero\n              if (instr_rdata_i[24:20] != 5'b00000) illegal_insn_o = 1'b1;\n            end\n            // Rest are illegal instructions\n            default: illegal_insn_o = 1'b1;\n          endcase\n\n          // check enabled formats (static)\n          if (~C_RVF && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP32) illegal_insn_o = 1'b1;\n          if ((~C_RVD) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP64) illegal_insn_o = 1'b1;\n          if ((~C_XF16) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16) illegal_insn_o = 1'b1;\n          if ((~C_XF16ALT) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16ALT) begin\n            illegal_insn_o = 1'b1;\n          end\n          if ((~C_XF8) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP8) illegal_insn_o = 1'b1;\n\n          // check rounding mode\n          if (check_fprm) begin\n            unique case (instr_rdata_i[14:12]) inside\n              3'b000, 3'b001, 3'b010, 3'b011, 3'b100: ; //legal rounding modes\n              3'b101: begin      // Alternative Half-Precsision encded as fmt=10 and rm=101\n                if (~C_XF16ALT || fpu_dst_fmt_o != cv32e40p_fpu_pkg::FP16ALT) illegal_insn_o = 1'b1;\n                // actual rounding mode from frm csr\n                unique case (frm_i) inside\n                  3'b000, 3'b001, 3'b010, 3'b011, 3'b100 : fp_rnd_mode_o = frm_i; //legal rounding modes\n                  default                                : illegal_insn_o = 1'b1;\n                endcase\n              end\n              3'b111: begin\n                // rounding mode from frm csr\n                unique case (frm_i) inside\n                  3'b000, 3'b001, 3'b010, 3'b011, 3'b100 : fp_rnd_mode_o = frm_i; //legal rounding modes\n                  default                                : illegal_insn_o = 1'b1;\n                endcase\n              end\n              default : illegal_insn_o = 1'b1;\n            endcase\n          end\n\n          // Set latencies for FPnew from config. The C_LAT constants contain the number\n          // of pipeline registers. the APU takes the following values:\n          // 1 = single cycle (no latency), 2 = one pipestage, 3 = two or more pipestages\n          case (fp_op_group)\n            // ADDMUL has format dependent latency\n            ADDMUL : begin\n              unique case (fpu_dst_fmt_o)\n                cv32e40p_fpu_pkg::FP32    : apu_lat_o = (FPU_ADDMUL_LAT<2)? FPU_ADDMUL_LAT+1: 2'h3;\n                cv32e40p_fpu_pkg::FP64    : apu_lat_o = (C_LAT_FP64<2)    ? C_LAT_FP64+1    : 2'h3;\n                cv32e40p_fpu_pkg::FP16    : apu_lat_o = (C_LAT_FP16<2)    ? C_LAT_FP16+1    : 2'h3;\n                cv32e40p_fpu_pkg::FP16ALT : apu_lat_o = (C_LAT_FP16ALT<2) ? C_LAT_FP16ALT+1 : 2'h3;\n                cv32e40p_fpu_pkg::FP8     : apu_lat_o = (C_LAT_FP8<2)     ? C_LAT_FP8+1     : 2'h3;\n                default : ;\n              endcase\n            end\n            // DIVSQRT is iterative and takes more than 2 cycles\n            DIVSQRT : apu_lat_o = 2'h3;\n            // NONCOMP uses the same latency for all formats\n            NONCOMP : apu_lat_o = (FPU_OTHERS_LAT<2) ? FPU_OTHERS_LAT+1 : 2'h3;\n            // CONV uses the same latency for all formats\n            CONV    : apu_lat_o = (FPU_OTHERS_LAT<2) ? FPU_OTHERS_LAT+1 : 2'h3;\n            default: ;\n          endcase\n\n          // Set FPnew OP and OPMOD as the APU op\n          apu_op_o = {fpu_vec_op, fpu_op_mod, fpu_op};\n\n        // No FPU or (ZFINX == 0 && MSTATUS.FS == FS_OFF)\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      // Floating Point fused arithmetic\n      OPCODE_OP_FMADD,\n      OPCODE_OP_FMSUB,\n      OPCODE_OP_FNMSUB,\n      OPCODE_OP_FNMADD : begin\n        if (FPU == 1 && (ZFINX == 1 || fs_off_i == 1'b0)) begin\n          // using APU instead of ALU\n          alu_en        = 1'b0;\n          apu_en        = 1'b1;\n          // all registers are FP registers and use three\n          rega_used_o   = 1'b1;\n          regb_used_o   = 1'b1;\n          regc_used_o   = 1'b1;\n          regc_mux_o    = REGC_S4;\n          if (ZFINX == 0) begin\n            reg_fp_a_o  = 1'b1;\n            reg_fp_b_o  = 1'b1;\n            reg_fp_c_o  = 1'b1;\n            reg_fp_d_o  = 1'b1;\n          end else begin\n            reg_fp_a_o  = 1'b0;\n            reg_fp_b_o  = 1'b0;\n            reg_fp_c_o  = 1'b0;\n            reg_fp_d_o  = 1'b0;\n          end\n          fp_rnd_mode_o = instr_rdata_i[14:12];\n\n          // Decode Formats\n          unique case (instr_rdata_i[26:25])\n            // FP32\n            2'b00 : fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP32;\n            // FP64\n            2'b01 : fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP64;\n            // FP16 or FP16ALT\n            2'b10 : begin\n              // FP16alt encoded in rm field\n              if (instr_rdata_i[14:12] == 3'b101) fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n              else fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16;\n            end\n            // FP8\n            2'b11 : fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP8;\n          endcase\n\n          // By default, src=dst\n          fpu_src_fmt_o = fpu_dst_fmt_o;\n\n          // decode FP intstruction\n          unique case (instr_rdata_i[6:0])\n            // fmadd.fmt - FP Fused multiply-add\n            OPCODE_OP_FMADD : begin\n              fpu_op     = cv32e40p_fpu_pkg::FMADD;\n            end\n            // fmsub.fmt - FP Fused multiply-subtract\n            OPCODE_OP_FMSUB : begin\n              fpu_op     = cv32e40p_fpu_pkg::FMADD;\n              fpu_op_mod = 1'b1;\n            end\n            // fnmsub.fmt - FP Negated fused multiply-subtract\n            OPCODE_OP_FNMSUB : begin\n              fpu_op     = cv32e40p_fpu_pkg::FNMSUB;\n            end\n            // fnmadd.fmt - FP Negated fused multiply-add\n            OPCODE_OP_FNMADD : begin\n              fpu_op     = cv32e40p_fpu_pkg::FNMSUB;\n              fpu_op_mod = 1'b1;\n            end\n            default : ;\n          endcase\n\n          // check enabled formats (static)\n          if (~C_RVF && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP32) illegal_insn_o = 1'b1;\n          if ((~C_RVD) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP64) illegal_insn_o = 1'b1;\n          if ((~C_XF16) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16) illegal_insn_o = 1'b1;\n          if ((~C_XF16ALT) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16ALT) begin\n            illegal_insn_o = 1'b1;\n          end\n          if ((~C_XF8) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP8) illegal_insn_o = 1'b1;\n\n          // check rounding mode\n          unique case (instr_rdata_i[14:12]) inside\n            3'b000, 3'b001, 3'b010, 3'b011, 3'b100: ; //legal rounding modes\n            3'b101: begin      // Alternative Half-Precsision encded as fmt=10 and rm=101\n              if (~C_XF16ALT || fpu_dst_fmt_o != cv32e40p_fpu_pkg::FP16ALT) illegal_insn_o = 1'b1;\n              // actual rounding mode from frm csr\n              unique case (frm_i) inside\n                3'b000, 3'b001, 3'b010, 3'b011, 3'b100 : fp_rnd_mode_o = frm_i; //legal rounding modes\n                default         : illegal_insn_o = 1'b1;\n              endcase\n            end\n            3'b111: begin\n              // rounding mode from frm csr\n              unique case (frm_i) inside\n                3'b000, 3'b001, 3'b010, 3'b011, 3'b100 : fp_rnd_mode_o = frm_i; //legal rounding modes\n                default         : illegal_insn_o = 1'b1;\n              endcase\n            end\n            default : illegal_insn_o = 1'b1;\n          endcase\n\n          // Set latencies for FPnew from config. The C_LAT constants contain the number\n          // of pipeline registers. the APU takes the following values:\n          // 1 = single cycle (no latency), 2 = one pipestage, 3 = two or more pipestages\n          // format dependent latency\n          unique case (fpu_dst_fmt_o)\n            cv32e40p_fpu_pkg::FP32    : apu_lat_o = (FPU_ADDMUL_LAT<2)? FPU_ADDMUL_LAT+1: 2'h3;\n            cv32e40p_fpu_pkg::FP64    : apu_lat_o = (C_LAT_FP64<2)    ? C_LAT_FP64+1    : 2'h3;\n            cv32e40p_fpu_pkg::FP16    : apu_lat_o = (C_LAT_FP16<2)    ? C_LAT_FP16+1    : 2'h3;\n            cv32e40p_fpu_pkg::FP16ALT : apu_lat_o = (C_LAT_FP16ALT<2) ? C_LAT_FP16ALT+1 : 2'h3;\n            cv32e40p_fpu_pkg::FP8     : apu_lat_o = (C_LAT_FP8<2)     ? C_LAT_FP8+1     : 2'h3;\n            default : ;\n          endcase\n\n          // Set FPnew OP and OPMOD as the APU op\n          apu_op_o = {fpu_vec_op, fpu_op_mod, fpu_op};\n\n        // No FPU or (ZFINX == 0 && MSTATUS.FS == FS_OFF)\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_STORE_FP: begin\n        if (FPU == 1 && ZFINX == 0 && fs_off_i == 1'b0) begin\n          data_req            = 1'b1;\n          data_we_o           = 1'b1;\n          rega_used_o         = 1'b1;\n          regb_used_o         = 1'b1;\n          alu_operator_o      = ALU_ADD;\n          reg_fp_b_o          = 1'b1;\n\n          // offset from immediate\n          imm_b_mux_sel_o     = IMMB_S;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n\n          // pass write data through ALU operand c\n          alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n\n          // Decode data type\n          unique case (instr_rdata_i[14:12])\n            // fsb - FP8 store\n            3'b000 : if (C_XF8) data_type_o = 2'b10;\n                     else illegal_insn_o = 1'b1;\n            // fsh - FP16 store\n            3'b001 : if (C_XF16 | C_XF16ALT) data_type_o = 2'b01;\n                     else illegal_insn_o = 1'b1;\n            // fsw - FP32 store\n            3'b010 : if (C_RVF) data_type_o = 2'b00;\n                     else illegal_insn_o = 1'b1;\n            // fsd - FP64 store\n            3'b011 : if (C_RVD) data_type_o = 2'b00; // 64bit stores unsupported!\n                     else illegal_insn_o = 1'b1;\n            default: illegal_insn_o = 1'b1;\n          endcase\n\n          // sanitize memory bus signals for illegal instr (not sure if needed??)\n          if (illegal_insn_o) begin\n            data_req       = 1'b0;\n            data_we_o      = 1'b0;\n          end\n        // No FPU or ZFINX or MSTATUS.FS == FS_OFF\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_LOAD_FP: begin\n        if (FPU == 1 && ZFINX == 0 && fs_off_i == 1'b0) begin\n          data_req            = 1'b1;\n          regfile_mem_we      = 1'b1;\n          reg_fp_d_o          = 1'b1;\n          rega_used_o         = 1'b1;\n          alu_operator_o      = ALU_ADD;\n\n          // offset from immediate\n          imm_b_mux_sel_o     = IMMB_I;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n\n          // NaN boxing\n          data_sign_extension_o = 2'b10;\n\n          // Decode data type\n          unique case (instr_rdata_i[14:12])\n            // flb - FP8 load\n            3'b000 : if (C_XF8) data_type_o = 2'b10;\n                     else illegal_insn_o = 1'b1;\n            // flh - FP16 load\n            3'b001 : if (C_XF16 | C_XF16ALT) data_type_o = 2'b01;\n                     else illegal_insn_o = 1'b1;\n            // flw - FP32 load\n            3'b010 : if (C_RVF) data_type_o = 2'b00;\n                     else illegal_insn_o = 1'b1;\n            // fld - FP64 load\n            3'b011 : if (C_RVD) data_type_o = 2'b00; // 64bit loads unsupported!\n                     else illegal_insn_o = 1'b1;\n            default: illegal_insn_o = 1'b1;\n          endcase\n        // No FPU or ZFINX or MSTATUS.FS == FS_OFF\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_CUSTOM_0: begin\n        if (COREV_PULP && instr_rdata_i[14:13] != 2'b11) begin // cv.l[bhw][u] and cv.elw\n          data_req           = 1'b1;\n          regfile_mem_we     = 1'b1;\n          rega_used_o        = 1'b1;\n          alu_operator_o     = ALU_ADD;\n          // offset from immediate\n          alu_op_b_mux_sel_o = OP_B_IMM;\n          imm_b_mux_sel_o    = IMMB_I;\n\n          // post-increment setup\n          if (instr_rdata_i[13:12] != 2'b11) begin\n            prepost_useincr_o       = 1'b0;\n            regfile_alu_waddr_sel_o = 1'b0;\n            regfile_alu_we          = 1'b1;\n          end\n\n          // sign/zero extension\n          data_sign_extension_o = {1'b0,~instr_rdata_i[14]};\n\n          // load size\n          unique case (instr_rdata_i[13:12])\n            2'b00  : data_type_o = 2'b10; // LB/LBU\n            2'b01  : data_type_o = 2'b01; // LH/LHU\n            default: data_type_o = 2'b00; // LW/ELW\n          endcase\n\n          // special cv.elw (event load)\n          if (instr_rdata_i[13:12] == 2'b11) begin\n            if (COREV_CLUSTER) begin\n              data_load_event_o = 1'b1;\n            end else begin\n              // cv.elw only valid for COREV_CLUSTER = 1\n              illegal_insn_o    = 1'b1;\n            end\n          end\n        end else if (COREV_PULP) begin   // cv.beqimm and cv.bneimm \n          ctrl_transfer_target_mux_sel_o = JT_COND;\n          ctrl_transfer_insn             = BRANCH_COND;\n          alu_op_c_mux_sel_o             = OP_C_JT;\n          rega_used_o                    = 1'b1;\n          // offset from immediate\n          alu_op_b_mux_sel_o             = OP_B_IMM;\n          imm_b_mux_sel_o                = IMMB_BI;\n\n          if (instr_rdata_i[12] == 1'b0) begin // cv.beqimm\n            alu_operator_o      = ALU_EQ;\n          end else begin                       // cv.bneimm\n            alu_operator_o      = ALU_NE;\n          end\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_CUSTOM_1: begin\n        if (COREV_PULP) begin\n          unique case (instr_rdata_i[14:12])\n            3'b000, 3'b001, 3'b010: begin  // Immediate Post-Incremented Store\n              data_req                = 1'b1;\n              data_we_o               = 1'b1;\n              rega_used_o             = 1'b1;\n              regb_used_o             = 1'b1;\n              alu_operator_o          = ALU_ADD;\n              // pass write data through ALU operand c\n              alu_op_c_mux_sel_o      = OP_C_REGB_OR_FWD;\n              // offset from immediate\n              imm_b_mux_sel_o         = IMMB_S;\n              alu_op_b_mux_sel_o      = OP_B_IMM;\n\n              // post-increment setup\n              prepost_useincr_o       = 1'b0;\n              regfile_alu_waddr_sel_o = 1'b0;\n              regfile_alu_we          = 1'b1;\n\n              // store size\n              unique case (instr_rdata_i[13:12])\n                2'b00  : data_type_o = 2'b10; // SB\n                2'b01  : data_type_o = 2'b01; // SH\n                default: data_type_o = 2'b00; // SW\n              endcase\n            end\n\n            3'b011 : begin // Plane A\n              unique case (instr_rdata_i[31:25])\n                7'b0000000, 7'b0000001, 7'b0000010, 7'b0000011,         // Register Post-Incremented          Load\n                7'b0000100, 7'b0000101, 7'b0000110, 7'b0000111,         // Register Indexed                   Load\n                7'b0001000, 7'b0001001, 7'b0001010, 7'b0001011,         // Register Post-Incremented Unsigned Load\n                7'b0001100, 7'b0001101, 7'b0001110, 7'b0001111: begin   // Register Indexed          Unsigned Load\n                  data_req           = 1'b1;\n                  regfile_mem_we     = 1'b1;\n                  rega_used_o        = 1'b1;\n                  alu_operator_o     = ALU_ADD;\n                  // offset from RS2\n                  regb_used_o        = 1'b1;\n                  alu_op_b_mux_sel_o = OP_B_REGB_OR_FWD;\n\n                  // post-increment setup\n                  if (instr_rdata_i[27] == 1'b0) begin\n                    prepost_useincr_o       = 1'b0;\n                    regfile_alu_waddr_sel_o = 1'b0;\n                    regfile_alu_we          = 1'b1;\n                  end\n\n                  // sign/zero extension\n                  data_sign_extension_o = {1'b0,~instr_rdata_i[28]};\n\n                  // load size\n                  unique case ({instr_rdata_i[28],instr_rdata_i[26:25]})\n                    3'b000 : data_type_o = 2'b10; // LB\n                    3'b001 : data_type_o = 2'b01; // LH\n                    3'b010 : data_type_o = 2'b00; // LW\n                    3'b100 : data_type_o = 2'b10; // LBU\n                    3'b101 : data_type_o = 2'b01; // LHU\n                    default: begin\n                      illegal_insn_o = 1'b1;\n                      data_req       = 1'b0;\n                      regfile_mem_we = 1'b0;\n                      regfile_alu_we = 1'b0;\n                    end\n                  endcase\n                end\n\n                7'b0010000, 7'b0010001, 7'b0010010, 7'b0010011,         // Register Post-Incremented Store\n                7'b0010100, 7'b0010101, 7'b0010110, 7'b0010111: begin   // Register Indexed          Store\n                  data_req           = 1'b1;\n                  data_we_o          = 1'b1;\n                  rega_used_o        = 1'b1;\n                  regb_used_o        = 1'b1;\n                  alu_operator_o     = ALU_ADD;\n                  // pass write data through ALU operand c\n                  alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n                  // offset from register\n                  regc_used_o        = 1'b1;\n                  alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;\n                  regc_mux_o         = REGC_RD;\n\n                  // post-increment setup\n                  if (instr_rdata_i[27] == 1'b0) begin\n                    prepost_useincr_o       = 1'b0;\n                    regfile_alu_waddr_sel_o = 1'b0;\n                    regfile_alu_we          = 1'b1;\n                  end\n\n                  // store size\n                  unique case (instr_rdata_i[26:25])\n                    2'b00  : data_type_o = 2'b10; // SB\n                    2'b01  : data_type_o = 2'b01; // SH\n                    2'b10  : data_type_o = 2'b00; // SW\n                    default: begin\n                      illegal_insn_o = 1'b1;\n                      data_req       = 1'b0;\n                      data_we_o      = 1'b0;\n                      data_type_o    = 2'b00;\n                    end\n                  endcase\n                end\n\n                7'b0011000, 7'b0011001, 7'b0011010, 7'b0011011,\n                7'b0011100, 7'b0011101, 7'b0011110, 7'b0011111: begin   // Register Bit-Manipulation\n                  regfile_alu_we        = 1'b1;\n                  rega_used_o           = 1'b1;\n                  regb_used_o           = 1'b1;\n\n                  bmask_a_mux_o         = BMASK_A_S3;\n                  bmask_b_mux_o         = BMASK_B_S2;\n                  alu_op_b_mux_sel_o    = OP_B_IMM;\n                  alu_bmask_a_mux_sel_o = BMASK_A_REG;\n\n                  unique case (instr_rdata_i[27:25])\n                    3'b000: begin                                      // cv.extractr\n                      alu_operator_o        = ALU_BEXT;\n                      imm_b_mux_sel_o       = IMMB_S2;\n                      bmask_b_mux_o         = BMASK_B_ZERO;\n                      alu_op_b_mux_sel_o    = OP_B_BMASK;\n                    end\n                    3'b001: begin                                      // cv.extractur\n                      alu_operator_o        = ALU_BEXTU;\n                      imm_b_mux_sel_o       = IMMB_S2;\n                      bmask_b_mux_o         = BMASK_B_ZERO;\n                      alu_op_b_mux_sel_o    = OP_B_BMASK;\n                    end\n                    3'b010: begin                                      // cv.insertr\n                      alu_operator_o        = ALU_BINS;\n                      imm_b_mux_sel_o       = IMMB_S2;\n                      regc_used_o           = 1'b1;\n                      regc_mux_o            = REGC_RD;\n                      alu_op_b_mux_sel_o    = OP_B_BMASK;\n                      alu_bmask_b_mux_sel_o = BMASK_B_REG;\n                    end\n                    3'b100: begin                                      // cv.bclrr\n                      alu_operator_o        = ALU_BCLR;\n                      alu_bmask_b_mux_sel_o = BMASK_B_REG;\n                    end\n                    3'b101: begin                                      // cv.bsetr\n                      alu_operator_o        = ALU_BSET;\n                      alu_bmask_b_mux_sel_o = BMASK_B_REG;\n                    end\n                    default: illegal_insn_o = 1'b1;\n                  endcase\n                end\n\n                7'b0100000, 7'b0100001, 7'b0100010, 7'b0100011,\n                7'b0100100, 7'b0100101, 7'b0100110, 7'b0100111,\n                7'b0101000, 7'b0101001, 7'b0101010, 7'b0101011,\n                7'b0101100, 7'b0101101, 7'b0101110, 7'b0101111,\n                7'b0110000, 7'b0110001, 7'b0110010, 7'b0110011,\n                7'b0110100, 7'b0110101, 7'b0110110, 7'b0110111,\n                7'b0111000, 7'b0111001, 7'b0111010, 7'b0111011,\n                7'b0111100, 7'b0111101, 7'b0111110, 7'b0111111: begin  // General ALU\n                  regfile_alu_we = 1'b1;\n                  rega_used_o    = 1'b1;\n                  regb_used_o    = 1'b1;\n\n                  unique case (instr_rdata_i[29:25])\n                    5'b00000: alu_operator_o = ALU_ROR;                // cv.ror\n                    5'b00001: begin                                    // cv.ff1\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_FF1;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b00010: begin                                    // cv.fl1\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_FL1;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b00011: begin                                    // cv.clb\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_CLB;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b00100: begin                                    // cv.cnt\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_CNT;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b01000: begin                                    // cv.abs\n                      alu_operator_o = ALU_ABS;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b01001: alu_operator_o = ALU_SLETS;              // cv.slet\n                    5'b01010: alu_operator_o = ALU_SLETU;              // cv.sletu\n                    5'b01011: alu_operator_o = ALU_MIN;                // cv.min\n                    5'b01100: alu_operator_o = ALU_MINU;               // cv.minu\n                    5'b01101: alu_operator_o = ALU_MAX;                // cv.max\n                    5'b01110: alu_operator_o = ALU_MAXU;               // cv.maxu\n                    5'b10000: begin                                    // cv.exths\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_EXTS;\n                      alu_vec_mode_o = VEC_MODE16;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b10001: begin                                    // cv.exthz\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_EXT;\n                      alu_vec_mode_o = VEC_MODE16;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b10010: begin                                    // cv.extbs\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_EXTS;\n                      alu_vec_mode_o = VEC_MODE8;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b10011: begin                                    // cv.extbz\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_EXT;\n                      alu_vec_mode_o = VEC_MODE8;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b11000: begin                                    // cv.clip\n                      regb_used_o        = 1'b0;\n                      alu_operator_o     = ALU_CLIP;\n                      alu_op_b_mux_sel_o = OP_B_IMM;\n                      imm_b_mux_sel_o    = IMMB_CLIP;\n                    end\n                    5'b11001: begin                                    // cv.clipu\n                      regb_used_o        = 1'b0;\n                      alu_operator_o     = ALU_CLIPU;\n                      alu_op_b_mux_sel_o = OP_B_IMM;\n                      imm_b_mux_sel_o    = IMMB_CLIP;\n                    end\n                    5'b11010: alu_operator_o = ALU_CLIP;               // cv.clipr\n                    5'b11011: alu_operator_o = ALU_CLIPU;              // cv.clipur\n                    default : illegal_insn_o = 1'b1;\n                  endcase\n                end\n\n                7'b1000000, 7'b1000001, 7'b1000010, 7'b1000011,\n                7'b1000100, 7'b1000101, 7'b1000110, 7'b1000111: begin  // Add/Sub with Normalization and Rounding\n                  regfile_alu_we        = 1'b1;\n                  rega_used_o           = 1'b1;\n                  regb_used_o           = 1'b1;\n                  regc_used_o           = 1'b1;\n                  regc_mux_o            = REGC_RD;\n                  bmask_a_mux_o         = BMASK_A_ZERO;\n                  bmask_b_mux_o         = BMASK_B_S3;\n                  alu_bmask_b_mux_sel_o = BMASK_B_REG;\n                  alu_op_a_mux_sel_o    = OP_A_REGC_OR_FWD;\n                  alu_op_b_mux_sel_o    = OP_B_REGA_OR_FWD;\n\n                  unique case (instr_rdata_i[27:25])\n                    3'b001:  alu_operator_o = ALU_ADDU;                 // cv.adduNr\n                    3'b010:  alu_operator_o = ALU_ADDR;                 // cv.addRNr\n                    3'b011:  alu_operator_o = ALU_ADDUR;                // cv.adduRNr\n                    3'b100:  alu_operator_o = ALU_SUB;                  // cv.subNr\n                    3'b101:  alu_operator_o = ALU_SUBU;                 // cv.subuNr\n                    3'b110:  alu_operator_o = ALU_SUBR;                 // cv.subRNr\n                    3'b111:  alu_operator_o = ALU_SUBUR;                // cv.subuRNr\n                    default: alu_operator_o = ALU_ADD;                  // cv.addNr\n                  endcase\n                end\n\n                7'b1001000, 7'b1001001: begin\n                  alu_en          = 1'b0;\n                  mult_int_en     = 1'b1;\n                  regfile_alu_we  = 1'b1;\n                  rega_used_o     = 1'b1;\n                  regb_used_o     = 1'b1;\n                  regc_used_o     = 1'b1;\n                  regc_mux_o      = REGC_RD;\n\n                  if (instr_rdata_i[25] == 1'b0) begin\n                    mult_operator_o = MUL_MAC32;                       // cv.mac\n                  end else begin\n                    mult_operator_o = MUL_MSU32;                       // cv.msu\n                  end\n                end\n\n                default: illegal_insn_o = 1'b1;\n              endcase\n            end // Plane A\n\n            ///////////////////////////////////////////////\n            //  _   ___        ___     ___   ___  ____   //\n            // | | | \\ \\      / / |   / _ \\ / _ \\|  _ \\  //\n            // | |_| |\\ \\ /\\ / /| |  | | | | | | | |_) | //\n            // |  _  | \\ V  V / | |__| |_| | |_| |  __/  //\n            // |_| |_|  \\_/\\_/  |_____\\___/ \\___/|_|     //\n            //                                           //\n            ///////////////////////////////////////////////\n            3'b100 : begin // Plane B\n              hwlp_target_mux_sel_o = 2'b0;\n\n              unique case (instr_rdata_i[11:8])\n                4'b0000: begin\n                  // lp.starti: set start address to PC + I-type immediate\n                  hwlp_we[0]           = 1'b1;\n                  hwlp_start_mux_sel_o = 2'b0;\n                  if (instr_rdata_i[19:15] != 5'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0001: begin\n                  // lp.start: set start address to rs1 content\n                  hwlp_we[0]           = 1'b1;\n                  hwlp_start_mux_sel_o = 2'b10;\n                  rega_used_o          = 1'b1;\n                  if (instr_rdata_i[31:20] != 12'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0010: begin\n                  // lp.endi: set end address to PC + I-type immediate - 4\n                  hwlp_we[1] = 1'b1;\n                  if (instr_rdata_i[19:15] != 5'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0011: begin\n                  // lp.end: set end address to (rs1 - 4) content\n                  hwlp_we[1]            = 1'b1;\n                  hwlp_target_mux_sel_o = 2'b10;\n                  rega_used_o           = 1'b1;\n                  if (instr_rdata_i[31:20] != 12'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0100: begin\n                  // lp.counti: initialize counter from I-type immediate\n                  hwlp_we[2]         = 1'b1;\n                  hwlp_cnt_mux_sel_o = 1'b0;\n                  if (instr_rdata_i[19:15] != 5'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0101: begin\n                  // lp.count: initialize counter from rs1\n                  hwlp_we[2]         = 1'b1;\n                  hwlp_cnt_mux_sel_o = 1'b1;\n                  rega_used_o        = 1'b1;\n                  if (instr_rdata_i[31:20] != 12'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0110: begin\n                  // lp.setupi: initialize counter from immediate, set start address to\n                  // next instruction and end address to PC + I-type immediate - 4\n                  hwlp_we               = 3'b111;\n                  hwlp_target_mux_sel_o = 2'b01;\n                  hwlp_start_mux_sel_o  = 2'b01;\n                  hwlp_cnt_mux_sel_o    = 1'b0;\n                end\n                4'b0111: begin\n                  // lp.setup: initialize counter from rs1, set start address to\n                  // next instruction and end address to PC + I-type immediate - 4\n                  hwlp_we              = 3'b111;\n                  hwlp_start_mux_sel_o = 2'b01;\n                  hwlp_cnt_mux_sel_o   = 1'b1;\n                  rega_used_o          = 1'b1;\n                end\n                default: begin\n                  illegal_insn_o = 1'b1;\n                end\n              endcase\n            end // Plane B\n\n            default: illegal_insn_o = 1'b1;\n          endcase\n\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_CUSTOM_2: begin  // PULP specific ALU instructions with two source operands and one immediate\n        if (COREV_PULP) begin\n          regfile_alu_we = 1'b1;\n          rega_used_o    = 1'b1;\n          regb_used_o    = 1'b1;\n\n          unique case (instr_rdata_i[14:13])\n            2'b00: begin\n              // Bit Manipulation instructions\n              regb_used_o         = 1'b0;\n              bmask_a_mux_o       = BMASK_A_S3;\n              bmask_b_mux_o       = BMASK_B_S2;\n              alu_op_b_mux_sel_o  = OP_B_IMM;\n     \n              unique case ({instr_rdata_i[31:30], instr_rdata_i[12]})\n                {2'b00, 1'b0}: begin                                       // cv.extract\n                  alu_operator_o  = ALU_BEXT;\n                  imm_b_mux_sel_o = IMMB_S2;\n                  bmask_b_mux_o   = BMASK_B_ZERO;\n                end\n                {2'b01, 1'b0}: begin                                       // cv.extractu\n                  alu_operator_o  = ALU_BEXTU;\n                  imm_b_mux_sel_o = IMMB_S2;\n                  bmask_b_mux_o   = BMASK_B_ZERO;\n                end\n                {2'b10, 1'b0}: begin                                       // cv.insert\n                  alu_operator_o  = ALU_BINS;\n                  imm_b_mux_sel_o = IMMB_S2;\n                  regc_used_o     = 1'b1;\n                  regc_mux_o      = REGC_RD;\n                end\n                {2'b00, 1'b1}: begin                                       // cv.bclr\n                  alu_operator_o = ALU_BCLR;\n                end\n                {2'b01, 1'b1}: begin                                       // cv.bset\n                  alu_operator_o = ALU_BSET;\n                end\n                {2'b11, 1'b1}: begin                                       // cv.bitrev\n                  alu_operator_o        = ALU_BREV;\n                  // Enable write back to RD\n                  regc_used_o           = 1'b1;\n                  regc_mux_o            = REGC_RD;\n                  // Extract the source register on operand a\n                  imm_b_mux_sel_o       = IMMB_S2;\n                  // Map the radix to bmask_a immediate\n                  alu_bmask_a_mux_sel_o = BMASK_A_IMM;\n                  if (instr_rdata_i[29:27] != 3'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                default: illegal_insn_o = 1'b1;\n              endcase\n            end\n\n            2'b01: begin\n              // ADD/SUB with normalization and rounding\n              bmask_a_mux_o  = BMASK_A_ZERO;\n              bmask_b_mux_o  = BMASK_B_S3;\n\n              // decide between using unsigned and rounding, and combinations\n              unique case ({instr_rdata_i[31:30], instr_rdata_i[12]})\n                {2'b01, 1'b0}: alu_operator_o = ALU_ADDU;                  // cv.adduN\n                {2'b10, 1'b0}: alu_operator_o = ALU_ADDR;                  // cv.addRN\n                {2'b11, 1'b0}: alu_operator_o = ALU_ADDUR;                 // cv.adduRN\n                {2'b00, 1'b1}: alu_operator_o = ALU_SUB;                   // cv.subN\n                {2'b01, 1'b1}: alu_operator_o = ALU_SUBU;                  // cv.subuN\n                {2'b10, 1'b1}: alu_operator_o = ALU_SUBR;                  // cv.subRN\n                {2'b11, 1'b1}: alu_operator_o = ALU_SUBUR;                 // cv.subuRN\n                default      : alu_operator_o = ALU_ADD;                   // cv.addN\n              endcase\n\n            end\n\n            default: begin\n              // MUL/MAC with subword selection\n              alu_en             = 1'b0;\n              mult_int_en        = 1'b1;\n\n              mult_imm_mux_o     = MIMM_S3;\n              mult_sel_subword_o = instr_rdata_i[30];                      // cv.mulhhsN, cv.mulhhsRN, cv.mulhhuN, cv.mulhhuRN\n                                                                           // cv.machhsN, cv.machhsRN, cv.machhuN, cv.machhuRN\n              mult_signed_mode_o = {2{~instr_rdata_i[12]}};                // cv.mulsN,   cv.mulhhsN,  cv.mulsRN,  cv.mulhhsRN\n                                                                           // cv.macsN,   cv.machhsN,  cv.macsRN,  cv.machhsRN\n\n              if (instr_rdata_i[13]) begin                                 // cv.macsN,   cv.machhsN,  cv.macsRN,  cv.machhsRN\n                                                                           // cv.macuN,   cv.machhuN,  cv.macuRN,  cv.machhuRN\n                regc_used_o = 1'b1;\n                regc_mux_o  = REGC_RD;\n              end else begin                                               // cv.mulsN,   cv.mulhhsN,  cv.mulsRN,  cv.mulhhsRN\n                                                                           // cv.muluN,   cv.mulhhuN,  cv.muluRN,  cv.mulhhuRN\n                regc_mux_o  = REGC_ZERO;\n              end\n\n              if (instr_rdata_i[31]) begin                                 // cv.mulsRN,  cv.mulhhsRN, cv.muluRN,  cv.mulhhuRN\n                                                                           // cv.macsRN,  cv.machhsRN, cv.macuRN,  cv.machhuRN\n                mult_operator_o = MUL_IR;\n              end else begin                                               // cv.mulsN,   cv.mulhhsN,  cv.muluN,   cv.mulhhuN\n                                                                           // cv.macsN,   cv.machhsN,  cv.macuN,   cv.machhuN\n                mult_operator_o = MUL_I;\n              end\n            end\n          endcase\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_CUSTOM_3: begin\n        if (COREV_PULP) begin\n          regfile_alu_we      = 1'b1;\n          rega_used_o         = 1'b1;\n          imm_b_mux_sel_o     = IMMB_VS;\n\n          alu_vec_o = 1'b1;\n          // vector size\n          if (instr_rdata_i[12]) begin\n            alu_vec_mode_o  = VEC_MODE8;\n            mult_operator_o = MUL_DOT8;\n          end else begin\n            alu_vec_mode_o  = VEC_MODE16;\n            mult_operator_o = MUL_DOT16;\n          end\n\n          // distinguish normal vector, sc and sci modes\n          if (instr_rdata_i[14]) begin\n            scalar_replication_o = 1'b1;\n\n            if (instr_rdata_i[13]) begin\n              // immediate scalar replication, .sci\n              alu_op_b_mux_sel_o = OP_B_IMM;\n            end else begin\n              // register scalar replication, .sc\n              regb_used_o = 1'b1;\n            end\n          end else begin\n            // normal register use\n            regb_used_o = 1'b1;\n          end\n\n          // now decode the instruction\n          unique case (instr_rdata_i[31:26])\n            6'b00000_0: begin // cv.add\n              alu_operator_o = ALU_ADD;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00001_0: begin // cv.sub\n              alu_operator_o = ALU_SUB;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00010_0: begin // cv.avg\n              alu_operator_o = ALU_ADD;\n              imm_b_mux_sel_o = IMMB_VS;\n              bmask_b_mux_o = BMASK_B_ONE;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00011_0: begin // cv.avgu\n             alu_operator_o = ALU_ADDU;\n             imm_b_mux_sel_o = IMMB_VU;\n             bmask_b_mux_o = BMASK_B_ONE;\n             if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n               illegal_insn_o = 1'b1;\n             end\n             if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                 instr_rdata_i[25] != 1'b0) begin\n               illegal_insn_o = 1'b1;\n             end\n            end\n            6'b00100_0: begin // cv.min\n             alu_operator_o = ALU_MIN;\n             imm_b_mux_sel_o = IMMB_VS;\n             if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n               illegal_insn_o = 1'b1;\n             end\n             if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                 instr_rdata_i[25] != 1'b0) begin\n               illegal_insn_o = 1'b1;\n             end\n            end\n            6'b00101_0: begin // cv.minu\n              alu_operator_o = ALU_MINU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00110_0: begin // cv.max\n              alu_operator_o = ALU_MAX;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00111_0: begin // cv.maxu\n              alu_operator_o = ALU_MAXU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01000_0: begin // cv.srl\n              alu_operator_o = ALU_SRL;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n              // Imm6 restrictions\n              if ((instr_rdata_i[14:12] == 3'b110 && instr_rdata_i[24:23] != 2'b0) ||\n                  (instr_rdata_i[14:12] == 3'b111 && instr_rdata_i[24:22] != 3'b0)) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01001_0: begin // cv.sra\n              alu_operator_o = ALU_SRA;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n              // Imm6 restrictions\n              if ((instr_rdata_i[14:12] == 3'b110 && instr_rdata_i[24:23] != 2'b0) ||\n                  (instr_rdata_i[14:12] == 3'b111 && instr_rdata_i[24:22] != 3'b0)) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01010_0: begin // cv.sll\n              alu_operator_o = ALU_SLL;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n              // Imm6 restrictions\n              if ((instr_rdata_i[14:12] == 3'b110 && instr_rdata_i[24:23] != 2'b0) ||\n                  (instr_rdata_i[14:12] == 3'b111 && instr_rdata_i[24:22] != 3'b0)) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01011_0: begin // cv.or\n              alu_operator_o = ALU_OR;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01100_0: begin // cv.xor\n              alu_operator_o = ALU_XOR;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01101_0: begin // cv.and\n              alu_operator_o = ALU_AND;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01110_0: begin // cv.abs\n              alu_operator_o = ALU_ABS;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] != 3'b000 && instr_rdata_i[14:12] != 3'b001) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[25:20] != 6'b000000) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10000_0: begin // cv.dotup\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b00;\n              imm_b_mux_sel_o   = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10001_0: begin // cv.dotusp\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b01;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10010_0: begin // cv.dotsp\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b11;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10011_0: begin // cv.sdotup\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b00;\n              regc_used_o       = 1'b1;\n              regc_mux_o        = REGC_RD;\n              imm_b_mux_sel_o   = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10100_0: begin // cv.sdotusp\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b01;\n              regc_used_o       = 1'b1;\n              regc_mux_o        = REGC_RD;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10101_0: begin // cv.sdotsp\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b11;\n              regc_used_o       = 1'b1;\n              regc_mux_o        = REGC_RD;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10111_0: begin\n              unique case (instr_rdata_i[14:13])\n                2'b00: alu_operator_o = ALU_EXTS; // cv.extract\n                2'b01: alu_operator_o = ALU_EXT;  // cv.extractu\n                2'b10: begin                      // cv.insert\n                  alu_operator_o     = ALU_INS;\n                  regc_used_o        = 1'b1;\n                  regc_mux_o         = REGC_RD;\n                  alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;\n                end\n                default: illegal_insn_o = 1'b1;\n              endcase\n              // Imm6 restrictions\n              if ((instr_rdata_i[12] == 1'b0 && instr_rdata_i[24:20] != 5'b0) ||\n                  (instr_rdata_i[12] == 1'b1 && instr_rdata_i[24:21] != 4'b0)) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11000_0: begin // cv.shuffle, cv.shuffleI0\n              alu_operator_o       = ALU_SHUF;\n              imm_b_mux_sel_o      = IMMB_SHUF;\n              regb_used_o          = 1'b1;\n              scalar_replication_o = 1'b0;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011 ||\n                  instr_rdata_i[14:12] == 3'b100 || instr_rdata_i[14:12] == 3'b101) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n              // Imm6 restriction\n              if (instr_rdata_i[14:12] == 3'b110 && instr_rdata_i[24:21] != 4'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11001_0,\n            6'b11010_0,\n            6'b11011_0: begin // cv.shuffleI1 cv.shuffleI2 cv.shuffleI3\n              alu_operator_o       = ALU_SHUF;\n              imm_b_mux_sel_o      = IMMB_SHUF;\n              regb_used_o          = 1'b1;\n              scalar_replication_o = 1'b0;\n              if (instr_rdata_i[14:12] != 3'b111) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11100_0: begin // cv.shuffle2\n              alu_operator_o       = ALU_SHUF2;\n              regb_used_o          = 1'b1;\n              regc_used_o          = 1'b1;\n              regc_mux_o           = REGC_RD;\n              scalar_replication_o = 1'b0;\n              if (instr_rdata_i[14:12] != 3'b000 && instr_rdata_i[14:12] != 3'b001) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11110_0: begin // cv.pack, cv.pack.h\n              alu_operator_o = instr_rdata_i[25] ? ALU_PCKHI : ALU_PCKLO;\n              regb_used_o    = 1'b1;\n              if (instr_rdata_i[14:12] != 3'b000) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11111_0: begin // cv.packhi, cv.packlo\n              alu_operator_o = instr_rdata_i[25] ? ALU_PCKHI : ALU_PCKLO;\n              regb_used_o    = 1'b1;\n              regc_used_o    = 1'b1;\n              regc_mux_o     = REGC_RD;\n              if (instr_rdata_i[14:12] != 3'b001) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n\n            // Comparisons, always have bit 26 set\n            6'b00000_1: begin // cv.cmpeq\n              alu_operator_o  = ALU_EQ;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00001_1: begin // cv.cmpne\n              alu_operator_o  = ALU_NE;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00010_1: begin // cv.cmpgt\n              alu_operator_o  = ALU_GTS;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00011_1: begin // cv.cmpge\n              alu_operator_o  = ALU_GES;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00100_1: begin // cv.cmplt\n              alu_operator_o  = ALU_LTS;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00101_1: begin // cv.cmple\n              alu_operator_o  = ALU_LES;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00110_1: begin // cv.cmpgtu\n              alu_operator_o  = ALU_GTU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00111_1: begin // cv.cmpgeu\n              alu_operator_o  = ALU_GEU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01000_1: begin // cv.cmpltu\n              alu_operator_o  = ALU_LTU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01001_1: begin // cv.cmpleu\n              alu_operator_o  = ALU_LEU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n\n            /*  Complex instructions */\n            6'b01010_1: begin // cv.cplxmul.{r,i}.{/,div2,div4,div8}\n              alu_en               = 1'b0;\n              mult_dot_en          = 1'b1;\n              mult_dot_signed_o    = 2'b11;\n              is_clpx_o            = 1'b1;\n              regc_used_o          = 1'b1;\n              regc_mux_o           = REGC_RD;\n              scalar_replication_o = 1'b0;\n              alu_op_b_mux_sel_o   = OP_B_REGB_OR_FWD;\n              regb_used_o          = 1'b1;\n              illegal_insn_o       = instr_rdata_i[12];\n            end\n            6'b01011_1: begin // cv.cplxconj\n              alu_operator_o       = ALU_ABS;\n              is_clpx_o            = 1'b1;\n              scalar_replication_o = 1'b0;\n              regb_used_o          = 1'b0;\n              if (instr_rdata_i[14:12] != 3'b000 || instr_rdata_i[25:20] != 6'b000000) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01100_1: begin // cv.subrotmj.{/,div2,div4,div8}\n              alu_operator_o       = ALU_SUB;\n              is_clpx_o            = 1'b1;\n              scalar_replication_o = 1'b0;\n              alu_op_b_mux_sel_o   = OP_B_REGB_OR_FWD;\n              regb_used_o          = 1'b1;\n              is_subrot_o          = 1'b1;\n              if (instr_rdata_i[12] != 1'b0 || instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01101_1: begin // cv.add.{div2,div4,div8}\n              alu_operator_o       = ALU_ADD;\n              is_clpx_o            = 1'b1;\n              scalar_replication_o = 1'b0;\n              alu_op_b_mux_sel_o   = OP_B_REGB_OR_FWD;\n              regb_used_o          = 1'b1;\n              if (instr_rdata_i[12] != 1'b0 || instr_rdata_i[14:12] == 3'b000 ||\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01110_1: begin // cv.sub.{div2,div4,div8}\n              alu_operator_o       = ALU_SUB;\n              is_clpx_o            = 1'b1;\n              scalar_replication_o = 1'b0;\n              alu_op_b_mux_sel_o   = OP_B_REGB_OR_FWD;\n              regb_used_o          = 1'b1;\n              if (instr_rdata_i[12] != 1'b0 || instr_rdata_i[14:12] == 3'b000 ||\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n\n            default: illegal_insn_o = 1'b1;\n          endcase\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      ////////////////////////////////////////////////\n      //  ____  ____  _____ ____ ___    _    _      //\n      // / ___||  _ \\| ____/ ___|_ _|  / \\  | |     //\n      // \\___ \\| |_) |  _|| |    | |  / _ \\ | |     //\n      //  ___) |  __/| |__| |___ | | / ___ \\| |___  //\n      // |____/|_|   |_____\\____|___/_/   \\_\\_____| //\n      //                                            //\n      ////////////////////////////////////////////////\n\n      OPCODE_FENCE: begin\n        unique case (instr_rdata_i[14:12])\n          3'b000: begin // FENCE (FENCE.I instead, a bit more conservative)\n            // flush pipeline\n            fencei_insn_o = 1'b1;\n          end\n\n          3'b001: begin // FENCE.I\n            // flush prefetch buffer, flush pipeline\n            fencei_insn_o = 1'b1;\n          end\n\n          default: illegal_insn_o =  1'b1;\n        endcase\n      end\n\n      OPCODE_SYSTEM: begin\n        if (instr_rdata_i[14:12] == 3'b000)\n        begin\n          // non CSR related SYSTEM instructions\n          if ( {instr_rdata_i[19:15], instr_rdata_i[11:7]} == '0)\n          begin\n            unique case (instr_rdata_i[31:20])\n              12'h000:  // ECALL\n              begin\n                // environment (system) call\n                ecall_insn_o  = 1'b1;\n              end\n\n              12'h001:  // ebreak\n              begin\n                // debugger trap\n                ebrk_insn_o = 1'b1;\n              end\n\n              12'h302:  // mret\n              begin\n                illegal_insn_o = (PULP_SECURE) ? current_priv_lvl_i != PRIV_LVL_M : 1'b0;\n                mret_insn_o    = ~illegal_insn_o;\n                mret_dec_o     = 1'b1;\n              end\n\n              12'h002:  // uret\n              begin\n                illegal_insn_o = (PULP_SECURE) ? 1'b0 : 1'b1;\n                uret_insn_o    = ~illegal_insn_o;\n                uret_dec_o     = 1'b1;\n              end\n\n              12'h7b2:  // dret\n              begin\n                illegal_insn_o = !debug_mode_i;\n                dret_insn_o    =  debug_mode_i;\n                dret_dec_o     =  1'b1;\n              end\n\n              12'h105:  // wfi\n              begin\n                wfi_o = 1'b1;\n                if (debug_wfi_no_sleep_i) begin\n                  // Treat as NOP (do not cause sleep mode entry)\n                  // Using decoding similar to ADDI, but without register reads/writes,\n                  // i.e. keep regfile_alu_we = 0, rega_used_o = 0\n                  alu_op_b_mux_sel_o = OP_B_IMM;\n                  imm_b_mux_sel_o = IMMB_I;\n                  alu_operator_o = ALU_ADD;\n                end\n              end\n\n              default: illegal_insn_o = 1'b1;\n            endcase\n          end else illegal_insn_o = 1'b1;\n        end\n        else\n        begin\n          // instruction to read/modify CSR\n          csr_access_o        = 1'b1;\n          regfile_alu_we      = 1'b1;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n          imm_a_mux_sel_o     = IMMA_Z;\n          imm_b_mux_sel_o     = IMMB_I;    // CSR address is encoded in I imm\n\n          if (instr_rdata_i[14] == 1'b1) begin\n            // rs1 field is used as immediate\n            alu_op_a_mux_sel_o = OP_A_IMM;\n          end else begin\n            rega_used_o        = 1'b1;\n            alu_op_a_mux_sel_o = OP_A_REGA_OR_FWD;\n          end\n\n          // instr_rdata_i[19:14] = rs or immediate value\n          //   if set or clear with rs == x0 or imm == 0,\n          //   then do not perform a write action\n          unique case (instr_rdata_i[13:12])\n            2'b01:   csr_op = CSR_OP_WRITE;\n            2'b10:   csr_op = instr_rdata_i[19:15] == 5'b0 ? CSR_OP_READ : CSR_OP_SET;\n            2'b11:   csr_op = instr_rdata_i[19:15] == 5'b0 ? CSR_OP_READ : CSR_OP_CLEAR;\n            default: csr_illegal = 1'b1;\n          endcase\n\n          if (instr_rdata_i[29:28] > current_priv_lvl_i) begin\n            // No access to higher privilege CSR\n            csr_illegal = 1'b1;\n          end\n\n          // Determine if CSR access is illegal\n          case (instr_rdata_i[31:20])\n            // Floating point\n            CSR_FFLAGS :\n                if (FPU == 0 || fs_off_i == 1'b1) csr_illegal = 1'b1;\n\n            CSR_FRM,\n              CSR_FCSR :\n                if (FPU == 0 || fs_off_i == 1'b1) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  // FRM updated value needed by following FPU instruction\n                  if (csr_op != CSR_OP_READ) csr_status_o = 1'b1;\n                end\n\n            //  Writes to read only CSRs results in illegal instruction\n            CSR_MVENDORID,\n              CSR_MARCHID,\n              CSR_MIMPID,\n              CSR_MHARTID :\n                if (csr_op != CSR_OP_READ) csr_illegal = 1'b1;\n\n            // These are valid CSR registers\n            CSR_MSTATUS,\n              CSR_MEPC,\n              CSR_MTVEC,\n              CSR_MCAUSE :\n                // Not illegal, but treat as status CSR for side effect handling\n                csr_status_o = 1'b1;\n\n            // These are valid CSR registers\n            CSR_MISA,\n              CSR_MIE,\n              CSR_MSCRATCH,\n              CSR_MTVAL,\n              CSR_MIP :\n                ; // do nothing, not illegal\n\n            // Hardware Performance Monitor\n            CSR_MCYCLE,\n              CSR_MINSTRET,\n              CSR_MHPMCOUNTER3,\n              CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,\n              CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,\n              CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,\n              CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,\n              CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,\n              CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,\n              CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31,\n              CSR_MCYCLEH,\n              CSR_MINSTRETH,\n              CSR_MHPMCOUNTER3H,\n              CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,\n              CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,\n              CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,\n              CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,\n              CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,\n              CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,\n              CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H,\n              CSR_MCOUNTINHIBIT,\n              CSR_MHPMEVENT3,\n              CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,\n              CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,\n              CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,\n              CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,\n              CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,\n              CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,\n              CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31 :\n                // Not illegal, but treat as status CSR to get accurate counts\n                csr_status_o = 1'b1;\n\n            // Hardware Performance Monitor (unprivileged read-only mirror CSRs)\n            CSR_CYCLE,\n              CSR_INSTRET,\n              CSR_HPMCOUNTER3,\n              CSR_HPMCOUNTER4,  CSR_HPMCOUNTER5,  CSR_HPMCOUNTER6,  CSR_HPMCOUNTER7,\n              CSR_HPMCOUNTER8,  CSR_HPMCOUNTER9,  CSR_HPMCOUNTER10, CSR_HPMCOUNTER11,\n              CSR_HPMCOUNTER12, CSR_HPMCOUNTER13, CSR_HPMCOUNTER14, CSR_HPMCOUNTER15,\n              CSR_HPMCOUNTER16, CSR_HPMCOUNTER17, CSR_HPMCOUNTER18, CSR_HPMCOUNTER19,\n              CSR_HPMCOUNTER20, CSR_HPMCOUNTER21, CSR_HPMCOUNTER22, CSR_HPMCOUNTER23,\n              CSR_HPMCOUNTER24, CSR_HPMCOUNTER25, CSR_HPMCOUNTER26, CSR_HPMCOUNTER27,\n              CSR_HPMCOUNTER28, CSR_HPMCOUNTER29, CSR_HPMCOUNTER30, CSR_HPMCOUNTER31,\n              CSR_CYCLEH,\n              CSR_INSTRETH,\n              CSR_HPMCOUNTER3H,\n              CSR_HPMCOUNTER4H,  CSR_HPMCOUNTER5H,  CSR_HPMCOUNTER6H,  CSR_HPMCOUNTER7H,\n              CSR_HPMCOUNTER8H,  CSR_HPMCOUNTER9H,  CSR_HPMCOUNTER10H, CSR_HPMCOUNTER11H,\n              CSR_HPMCOUNTER12H, CSR_HPMCOUNTER13H, CSR_HPMCOUNTER14H, CSR_HPMCOUNTER15H,\n              CSR_HPMCOUNTER16H, CSR_HPMCOUNTER17H, CSR_HPMCOUNTER18H, CSR_HPMCOUNTER19H,\n              CSR_HPMCOUNTER20H, CSR_HPMCOUNTER21H, CSR_HPMCOUNTER22H, CSR_HPMCOUNTER23H,\n              CSR_HPMCOUNTER24H, CSR_HPMCOUNTER25H, CSR_HPMCOUNTER26H, CSR_HPMCOUNTER27H,\n              CSR_HPMCOUNTER28H, CSR_HPMCOUNTER29H, CSR_HPMCOUNTER30H, CSR_HPMCOUNTER31H :\n                // Read-only and readable from user mode only if the bit of mcounteren is set\n                if ((csr_op != CSR_OP_READ) ||\n                    (PULP_SECURE && (current_priv_lvl_i != PRIV_LVL_M) && !mcounteren_i[instr_rdata_i[24:20]])) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            // This register only exists in user mode\n            CSR_MCOUNTEREN :\n                if (!PULP_SECURE) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            // Debug register access\n            CSR_DCSR,\n              CSR_DPC,\n              CSR_DSCRATCH0,\n              CSR_DSCRATCH1 :\n                if (!debug_mode_i) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            // Debug Trigger register access\n            CSR_TSELECT,\n              CSR_TDATA1,\n              CSR_TDATA2,\n              CSR_TDATA3,\n              CSR_TINFO,\n              CSR_MCONTEXT,\n              CSR_SCONTEXT :\n                if (DEBUG_TRIGGER_EN != 1)\n                  csr_illegal = 1'b1;\n\n            // Hardware Loop register\n            CSR_LPSTART0,\n              CSR_LPEND0,\n              CSR_LPCOUNT0,\n              CSR_LPSTART1,\n              CSR_LPEND1,\n              CSR_LPCOUNT1:\n                if (!COREV_PULP || csr_op != CSR_OP_READ) csr_illegal = 1'b1;\n\n            // UHARTID access\n            CSR_UHARTID :\n                if (!COREV_PULP || csr_op != CSR_OP_READ) csr_illegal = 1'b1;\n\n            // PRIVLV access\n            CSR_PRIVLV :\n                if (!COREV_PULP || csr_op != CSR_OP_READ) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            // ZFINX\n            CSR_ZFINX :\n                if (!COREV_PULP || (FPU && !ZFINX) || csr_op != CSR_OP_READ) begin\n                  csr_illegal = 1'b1;\n                end\n\n            // PMP register access\n            CSR_PMPCFG0,\n              CSR_PMPCFG1,\n              CSR_PMPCFG2,\n              CSR_PMPCFG3,\n              CSR_PMPADDR0,\n              CSR_PMPADDR1,\n              CSR_PMPADDR2,\n              CSR_PMPADDR3,\n              CSR_PMPADDR4,\n              CSR_PMPADDR5,\n              CSR_PMPADDR6,\n              CSR_PMPADDR7,\n              CSR_PMPADDR8,\n              CSR_PMPADDR9,\n              CSR_PMPADDR10,\n              CSR_PMPADDR11,\n              CSR_PMPADDR12,\n              CSR_PMPADDR13,\n              CSR_PMPADDR14,\n              CSR_PMPADDR15 :\n                if (!USE_PMP) csr_illegal = 1'b1;\n\n            // User register access\n            CSR_USTATUS,\n              CSR_UEPC,\n              CSR_UTVEC,\n              CSR_UCAUSE :\n                if (!PULP_SECURE) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            default : csr_illegal = 1'b1;\n\n          endcase // case (instr_rdata_i[31:20])\n\n          illegal_insn_o = csr_illegal;\n\n        end\n      end\n      default: illegal_insn_o = 1'b1;\n    endcase\n\n    // make sure invalid compressed instruction causes an exception\n    if (illegal_c_insn_i) begin\n      illegal_insn_o = 1'b1;\n    end\n\n  end\n\n  // deassert we signals (in case of stalls)\n  assign alu_en_o                    = (deassert_we_i) ? 1'b0          : alu_en;\n  assign mult_int_en_o               = (deassert_we_i) ? 1'b0          : mult_int_en;\n  assign mult_dot_en_o               = (deassert_we_i) ? 1'b0          : mult_dot_en;\n  assign apu_en_o                    = (deassert_we_i) ? 1'b0          : apu_en;\n  assign regfile_mem_we_o            = (deassert_we_i) ? 1'b0          : regfile_mem_we;\n  assign regfile_alu_we_o            = (deassert_we_i) ? 1'b0          : regfile_alu_we;\n  assign data_req_o                  = (deassert_we_i) ? 1'b0          : data_req;\n  assign hwlp_we_o                   = (deassert_we_i) ? 3'b0          : hwlp_we;\n  assign csr_op_o                    = (deassert_we_i) ? CSR_OP_READ   : csr_op;\n  assign ctrl_transfer_insn_in_id_o  = (deassert_we_i) ? BRANCH_NONE   : ctrl_transfer_insn;\n\n  assign ctrl_transfer_insn_in_dec_o  = ctrl_transfer_insn;\n  assign regfile_alu_we_dec_o         = regfile_alu_we;\n\nendmodule // cv32e40p_decoder\n","lang":"verilog"};
processSrcData(g_data);