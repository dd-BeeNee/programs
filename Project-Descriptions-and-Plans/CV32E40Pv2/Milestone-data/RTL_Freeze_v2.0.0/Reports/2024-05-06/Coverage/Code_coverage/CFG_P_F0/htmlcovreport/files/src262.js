var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/src/fpnew_classifier.sv","src":"// Copyright 2019 ETH Zurich and University of Bologna.\n//\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// SPDX-License-Identifier: SHL-0.51\n\n// Author: Stefan Mach <smach@iis.ee.ethz.ch>\n\nmodule fpnew_classifier #(\n  parameter fpnew_pkg::fp_format_e   FpFormat = fpnew_pkg::fp_format_e'(0),\n  parameter int unsigned             NumOperands = 1,\n  // Do not change\n  localparam int unsigned WIDTH = fpnew_pkg::fp_width(FpFormat)\n) (\n  input  logic                [NumOperands-1:0][WIDTH-1:0] operands_i,\n  input  logic                [NumOperands-1:0]            is_boxed_i,\n  output fpnew_pkg::fp_info_t [NumOperands-1:0]            info_o\n);\n\n  localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(FpFormat);\n  localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(FpFormat);\n\n  // Type definition\n  typedef struct packed {\n    logic                sign;\n    logic [EXP_BITS-1:0] exponent;\n    logic [MAN_BITS-1:0] mantissa;\n  } fp_t;\n\n  // Iterate through all operands\n  for (genvar op = 0; op < int'(NumOperands); op++) begin : gen_num_values\n\n    fp_t value;\n    logic is_boxed;\n    logic is_normal;\n    logic is_inf;\n    logic is_nan;\n    logic is_signalling;\n    logic is_quiet;\n    logic is_zero;\n    logic is_subnormal;\n\n    // ---------------\n    // Classify Input\n    // ---------------\n    always_comb begin : classify_input\n      value         = operands_i[op];\n      is_boxed      = is_boxed_i[op];\n      is_normal     = is_boxed && (value.exponent != '0) && (value.exponent != '1);\n      is_zero       = is_boxed && (value.exponent == '0) && (value.mantissa == '0);\n      is_subnormal  = is_boxed && (value.exponent == '0) && !is_zero;\n      is_inf        = is_boxed && ((value.exponent == '1) && (value.mantissa == '0));\n      is_nan        = !is_boxed || ((value.exponent == '1) && (value.mantissa != '0));\n      is_signalling = is_boxed && is_nan && (value.mantissa[MAN_BITS-1] == 1'b0);\n      is_quiet      = is_nan && !is_signalling;\n      // Assign output for current input\n      info_o[op].is_normal     = is_normal;\n      info_o[op].is_subnormal  = is_subnormal;\n      info_o[op].is_zero       = is_zero;\n      info_o[op].is_inf        = is_inf;\n      info_o[op].is_nan        = is_nan;\n      info_o[op].is_signalling = is_signalling;\n      info_o[op].is_quiet      = is_quiet;\n      info_o[op].is_boxed      = is_boxed;\n    end\n  end\nendmodule\n","lang":"verilog"};
processSrcData(g_data);