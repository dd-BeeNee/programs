var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_register_file_ff.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Francesco Conti - f.conti@unibo.it                         //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    RISC-V register file                                       //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Register file with 31x 32 bit wide registers. Register 0   //\n//                 is fixed to 0. This register file is based on flip-flops.  //\n//                 Also supports the fp-register file now if FPU=1            //\n//                 If ZFINX is 1, floating point operations take values       //\n//                 from the X register file                                   //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_register_file #(\n    parameter ADDR_WIDTH = 5,\n    parameter DATA_WIDTH = 32,\n    parameter FPU        = 0,\n    parameter ZFINX      = 0\n) (\n    // Clock and Reset\n    input logic clk,\n    input logic rst_n,\n\n    input logic scan_cg_en_i,\n\n    //Read port R1\n    input  logic [ADDR_WIDTH-1:0] raddr_a_i,\n    output logic [DATA_WIDTH-1:0] rdata_a_o,\n\n    //Read port R2\n    input  logic [ADDR_WIDTH-1:0] raddr_b_i,\n    output logic [DATA_WIDTH-1:0] rdata_b_o,\n\n    //Read port R3\n    input  logic [ADDR_WIDTH-1:0] raddr_c_i,\n    output logic [DATA_WIDTH-1:0] rdata_c_o,\n\n    // Write port W1\n    input logic [ADDR_WIDTH-1:0] waddr_a_i,\n    input logic [DATA_WIDTH-1:0] wdata_a_i,\n    input logic                  we_a_i,\n\n    // Write port W2\n    input logic [ADDR_WIDTH-1:0] waddr_b_i,\n    input logic [DATA_WIDTH-1:0] wdata_b_i,\n    input logic                  we_b_i\n);\n\n  // number of integer registers\n  localparam NUM_WORDS = 2 ** (ADDR_WIDTH - 1);\n  // number of floating point registers\n  localparam NUM_FP_WORDS = 2 ** (ADDR_WIDTH - 1);\n  localparam NUM_TOT_WORDS = FPU ? (ZFINX ? NUM_WORDS : NUM_WORDS + NUM_FP_WORDS) : NUM_WORDS;\n\n  // integer register file\n  logic [    NUM_WORDS-1:0][DATA_WIDTH-1:0] mem;\n\n  // fp register file\n  logic [ NUM_FP_WORDS-1:0][DATA_WIDTH-1:0] mem_fp;\n\n  // masked write addresses\n  logic [   ADDR_WIDTH-1:0]                 waddr_a;\n  logic [   ADDR_WIDTH-1:0]                 waddr_b;\n\n  // write enable signals for all registers\n  logic [NUM_TOT_WORDS-1:0]                 we_a_dec;\n  logic [NUM_TOT_WORDS-1:0]                 we_b_dec;\n\n\n  //-----------------------------------------------------------------------------\n  //-- READ : Read address decoder RAD\n  //-----------------------------------------------------------------------------\n  assign rdata_a_o = raddr_a_i[5] ? mem_fp[raddr_a_i[4:0]] : mem[raddr_a_i[4:0]];\n  assign rdata_b_o = raddr_b_i[5] ? mem_fp[raddr_b_i[4:0]] : mem[raddr_b_i[4:0]];\n  assign rdata_c_o = raddr_c_i[5] ? mem_fp[raddr_c_i[4:0]] : mem[raddr_c_i[4:0]];\n\n  //-----------------------------------------------------------------------------\n  //-- WRITE : Write Address Decoder (WAD), combinatorial process\n  //-----------------------------------------------------------------------------\n\n  // Mask top bit of write address to disable fp regfile\n  assign waddr_a   = waddr_a_i;\n  assign waddr_b   = waddr_b_i;\n\n  genvar gidx;\n  generate\n    for (gidx = 0; gidx < NUM_TOT_WORDS; gidx++) begin : gen_we_decoder\n      assign we_a_dec[gidx] = (waddr_a == gidx) ? we_a_i : 1'b0;\n      assign we_b_dec[gidx] = (waddr_b == gidx) ? we_b_i : 1'b0;\n    end\n  endgenerate\n\n  genvar i, l;\n  generate\n\n    //-----------------------------------------------------------------------------\n    //-- WRITE : Write operation\n    //-----------------------------------------------------------------------------\n    // R0 is nil\n    always_ff @(posedge clk or negedge rst_n) begin\n      if (~rst_n) begin\n        // R0 is nil\n        mem[0] <= 32'b0;\n      end else begin\n        // R0 is nil\n        mem[0] <= 32'b0;\n      end\n    end\n\n    // loop from 1 to NUM_WORDS-1 as R0 is nil\n    for (i = 1; i < NUM_WORDS; i++) begin : gen_rf\n\n      always_ff @(posedge clk, negedge rst_n) begin : register_write_behavioral\n        if (rst_n == 1'b0) begin\n          mem[i] <= 32'b0;\n        end else begin\n          if (we_b_dec[i] == 1'b1) mem[i] <= wdata_b_i;\n          else if (we_a_dec[i] == 1'b1) mem[i] <= wdata_a_i;\n        end\n      end\n\n    end\n\n    if (FPU == 1 && ZFINX == 0) begin : gen_mem_fp_write\n      // Floating point registers\n      for (l = 0; l < NUM_FP_WORDS; l++) begin\n        always_ff @(posedge clk, negedge rst_n) begin : fp_regs\n          if (rst_n == 1'b0) mem_fp[l] <= '0;\n          else if (we_b_dec[l+NUM_WORDS] == 1'b1) mem_fp[l] <= wdata_b_i;\n          else if (we_a_dec[l+NUM_WORDS] == 1'b1) mem_fp[l] <= wdata_a_i;\n        end\n      end\n    end else begin : gen_no_mem_fp_write\n      assign mem_fp = 'b0;\n    end\n\n  endgenerate\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);