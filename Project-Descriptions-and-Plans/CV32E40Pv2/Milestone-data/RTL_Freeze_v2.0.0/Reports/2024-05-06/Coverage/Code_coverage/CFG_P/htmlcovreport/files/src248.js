var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_hwloop_regs.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    hwloop regs                                                //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Hardware loop registers                                    //\n//                 a) store start/end address of N=4 hardware loops           //\n//                 b) store init value of counter for each hardware loop      //\n//                 c) decrement counter if hwloop taken                       //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_hwloop_regs #(\n    parameter N_REGS     = 2,\n    parameter N_REG_BITS = $clog2(N_REGS)\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // from ex stage\n    input logic [          31:0] hwlp_start_data_i,\n    input logic [          31:0] hwlp_end_data_i,\n    input logic [          31:0] hwlp_cnt_data_i,\n    input logic [           2:0] hwlp_we_i,\n    input logic [N_REG_BITS-1:0] hwlp_regid_i,  // selects the register set\n\n    // from controller\n    input logic valid_i,\n\n    // from hwloop controller\n    input logic [N_REGS-1:0] hwlp_dec_cnt_i,\n\n    // to hwloop controller\n    output logic [N_REGS-1:0][31:0] hwlp_start_addr_o,\n    output logic [N_REGS-1:0][31:0] hwlp_end_addr_o,\n    output logic [N_REGS-1:0][31:0] hwlp_counter_o\n);\n\n\n  logic [N_REGS-1:0][31:0] hwlp_start_q;\n  logic [N_REGS-1:0][31:0] hwlp_end_q;\n  logic [N_REGS-1:0][31:0] hwlp_counter_q, hwlp_counter_n;\n\n  int unsigned i;\n\n\n  assign hwlp_start_addr_o = hwlp_start_q;\n  assign hwlp_end_addr_o   = hwlp_end_q;\n  assign hwlp_counter_o    = hwlp_counter_q;\n\n\n  /////////////////////////////////////////////////////////////////////////////////\n  // HWLOOP start-address register                                               //\n  /////////////////////////////////////////////////////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin : HWLOOP_REGS_START\n    if (rst_n == 1'b0) begin\n      hwlp_start_q <= '{default: 32'b0};\n    end else if (hwlp_we_i[0] == 1'b1) begin\n      hwlp_start_q[hwlp_regid_i] <= {hwlp_start_data_i[31:2], 2'b0};\n    end\n  end\n\n\n  /////////////////////////////////////////////////////////////////////////////////\n  // HWLOOP end-address register                                                 //\n  /////////////////////////////////////////////////////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin : HWLOOP_REGS_END\n    if (rst_n == 1'b0) begin\n      hwlp_end_q <= '{default: 32'b0};\n    end else if (hwlp_we_i[1] == 1'b1) begin\n      hwlp_end_q[hwlp_regid_i] <= {hwlp_end_data_i[31:2], 2'b0};\n    end\n  end\n\n\n  /////////////////////////////////////////////////////////////////////////////////\n  // HWLOOP counter register with decrement logic                                //\n  /////////////////////////////////////////////////////////////////////////////////\n  genvar k;\n  for (k = 0; k < N_REGS; k++) begin\n    assign hwlp_counter_n[k] = hwlp_counter_q[k] - 1;\n  end\n\n  always_ff @(posedge clk, negedge rst_n) begin : HWLOOP_REGS_COUNTER\n    if (rst_n == 1'b0) begin\n      hwlp_counter_q <= '{default: 32'b0};\n    end else begin\n      for (i = 0; i < N_REGS; i++) begin\n        if ((hwlp_we_i[2] == 1'b1) && (i == hwlp_regid_i)) begin\n          hwlp_counter_q[i] <= hwlp_cnt_data_i;\n        end else begin\n          if (hwlp_dec_cnt_i[i] && valid_i) hwlp_counter_q[i] <= hwlp_counter_n[i];\n        end\n      end\n    end\n  end\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n`ifdef CV32E40P_ASSERT_ON\n  // do not decrement more than one counter at once\n  assert property (@(posedge clk) (valid_i) |-> ($countones(hwlp_dec_cnt_i) <= 1));\n`endif\nendmodule\n","lang":"verilog"};
processSrcData(g_data);