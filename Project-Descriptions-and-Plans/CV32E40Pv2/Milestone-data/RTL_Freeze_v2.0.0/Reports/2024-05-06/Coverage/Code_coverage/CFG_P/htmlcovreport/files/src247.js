var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_int_controller.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Additional contributions by:                                               //\n//                                                                            //\n// Design Name:    Interrupt Controller                                       //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Interrupt Controller of the pipelined processor            //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_int_controller\n  import cv32e40p_pkg::*;\n#(\n    parameter PULP_SECURE = 0\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // External interrupt lines\n    input logic [31:0] irq_i,  // Level-triggered interrupt inputs\n    input logic        irq_sec_i,  // Interrupt secure bit from EU\n\n    // To cv32e40p_controller\n    output logic       irq_req_ctrl_o,\n    output logic       irq_sec_ctrl_o,\n    output logic [4:0] irq_id_ctrl_o,\n    output logic       irq_wu_ctrl_o,\n\n    // To/from cv32e40p_cs_registers\n    input  logic     [31:0] mie_bypass_i,  // MIE CSR (bypass)\n    output logic     [31:0] mip_o,  // MIP CSR\n    input  logic            m_ie_i,  // Interrupt enable bit from CSR (M mode)\n    input  logic            u_ie_i,  // Interrupt enable bit from CSR (U mode)\n    input  PrivLvl_t        current_priv_lvl_i\n);\n\n  logic        global_irq_enable;\n  logic [31:0] irq_local_qual;\n  logic [31:0] irq_q;\n  logic        irq_sec_q;\n\n  // Register all interrupt inputs (on gated clock). The wake-up logic will\n  // observe irq_i as well, but in all other places irq_q will be used to \n  // avoid timing paths from irq_i to instr_*_o\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      irq_q     <= '0;\n      irq_sec_q <= 1'b0;\n    end else begin\n      irq_q     <= irq_i & IRQ_MASK;\n      irq_sec_q <= irq_sec_i;\n    end\n  end\n\n  // MIP CSR\n  assign mip_o = irq_q;\n\n  // Qualify registered IRQ with MIE CSR to compute locally enabled IRQs\n  assign irq_local_qual = irq_q & mie_bypass_i;\n\n  // Wake-up signal based on unregistered IRQ such that wake-up can be caused if no clock is present\n  assign irq_wu_ctrl_o = |(irq_i & mie_bypass_i);\n\n  // Global interrupt enable\n  generate\n    if (PULP_SECURE) begin : gen_pulp_secure\n      assign global_irq_enable = ((u_ie_i || irq_sec_i) && current_priv_lvl_i == PRIV_LVL_U) || (m_ie_i && current_priv_lvl_i == PRIV_LVL_M);\n    end else begin : gen_no_pulp_secure\n      assign global_irq_enable = m_ie_i;\n    end\n  endgenerate\n\n  // Request to take interrupt if there is a locally enabled interrupt while interrupts are also enabled globally\n  assign irq_req_ctrl_o = (|irq_local_qual) && global_irq_enable;\n\n  // Interrupt Encoder\n  //\n  // - sets correct id to request to ID\n  // - encodes priority order\n\n  always_comb begin\n    if (irq_local_qual[31]) irq_id_ctrl_o = 5'd31;  // Custom irq_i[31]\n    else if (irq_local_qual[30]) irq_id_ctrl_o = 5'd30;  // Custom irq_i[30]\n    else if (irq_local_qual[29]) irq_id_ctrl_o = 5'd29;  // Custom irq_i[29]\n    else if (irq_local_qual[28]) irq_id_ctrl_o = 5'd28;  // Custom irq_i[28]\n    else if (irq_local_qual[27]) irq_id_ctrl_o = 5'd27;  // Custom irq_i[27]\n    else if (irq_local_qual[26]) irq_id_ctrl_o = 5'd26;  // Custom irq_i[26]\n    else if (irq_local_qual[25]) irq_id_ctrl_o = 5'd25;  // Custom irq_i[25]\n    else if (irq_local_qual[24]) irq_id_ctrl_o = 5'd24;  // Custom irq_i[24]\n    else if (irq_local_qual[23]) irq_id_ctrl_o = 5'd23;  // Custom irq_i[23]\n    else if (irq_local_qual[22]) irq_id_ctrl_o = 5'd22;  // Custom irq_i[22]\n    else if (irq_local_qual[21]) irq_id_ctrl_o = 5'd21;  // Custom irq_i[21]\n    else if (irq_local_qual[20]) irq_id_ctrl_o = 5'd20;  // Custom irq_i[20]\n    else if (irq_local_qual[19]) irq_id_ctrl_o = 5'd19;  // Custom irq_i[19]\n    else if (irq_local_qual[18]) irq_id_ctrl_o = 5'd18;  // Custom irq_i[18]\n    else if (irq_local_qual[17]) irq_id_ctrl_o = 5'd17;  // Custom irq_i[17]\n    else if (irq_local_qual[16]) irq_id_ctrl_o = 5'd16;  // Custom irq_i[16]\n\n    else if (irq_local_qual[15])\n      irq_id_ctrl_o = 5'd15;  // Reserved  (default masked out with IRQ_MASK)\n    else if (irq_local_qual[14])\n      irq_id_ctrl_o = 5'd14;  // Reserved  (default masked out with IRQ_MASK)\n    else if (irq_local_qual[13])\n      irq_id_ctrl_o = 5'd13;  // Reserved  (default masked out with IRQ_MASK)\n    else if (irq_local_qual[12])\n      irq_id_ctrl_o = 5'd12;  // Reserved  (default masked out with IRQ_MASK)\n\n    else if (irq_local_qual[CSR_MEIX_BIT]) irq_id_ctrl_o = CSR_MEIX_BIT;  // MEI, irq_i[11]\n    else if (irq_local_qual[CSR_MSIX_BIT]) irq_id_ctrl_o = CSR_MSIX_BIT;  // MSI, irq_i[3]\n    else if (irq_local_qual[CSR_MTIX_BIT]) irq_id_ctrl_o = CSR_MTIX_BIT;  // MTI, irq_i[7]\n\n    else if (irq_local_qual[10])\n      irq_id_ctrl_o = 5'd10;                         // Reserved (for now assuming EI, SI, TI priority) (default masked out with IRQ_MASK)\n    else if (irq_local_qual[2])\n      irq_id_ctrl_o = 5'd2;                          // Reserved (for now assuming EI, SI, TI priority) (default masked out with IRQ_MASK)\n    else if (irq_local_qual[6])\n      irq_id_ctrl_o = 5'd6;                          // Reserved (for now assuming EI, SI, TI priority) (default masked out with IRQ_MASK)\n\n    else if (irq_local_qual[9])\n      irq_id_ctrl_o = 5'd9;  // Reserved: SEI (default masked out with IRQ_MASK)\n    else if (irq_local_qual[1])\n      irq_id_ctrl_o = 5'd1;  // Reserved: SSI (default masked out with IRQ_MASK)\n    else if (irq_local_qual[5])\n      irq_id_ctrl_o = 5'd5;  // Reserved: STI (default masked out with IRQ_MASK)\n\n    else if (irq_local_qual[8])\n      irq_id_ctrl_o = 5'd8;  // Reserved: UEI (default masked out with IRQ_MASK)\n    else if (irq_local_qual[0])\n      irq_id_ctrl_o = 5'd0;  // Reserved: USI (default masked out with IRQ_MASK)\n    else if (irq_local_qual[4])\n      irq_id_ctrl_o = 5'd4;  // Reserved: UTI (default masked out with IRQ_MASK)\n\n    else irq_id_ctrl_o = CSR_MTIX_BIT;  // Value not relevant\n  end\n\n  assign irq_sec_ctrl_o = irq_sec_q;\n\nendmodule  // cv32e40p_int_controller\n","lang":"verilog"};
processSrcData(g_data);