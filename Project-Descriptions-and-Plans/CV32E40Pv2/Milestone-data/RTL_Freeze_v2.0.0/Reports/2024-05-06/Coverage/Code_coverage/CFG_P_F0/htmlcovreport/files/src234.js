var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/../sva/cv32e40p_prefetch_controller_sva.sv","src":"// Copyright 2020 Silicon Labs, Inc.\n//   \n// This file, and derivatives thereof are licensed under the\n// Solderpad License, Version 2.0 (the \"License\").\n//\n// Use of this file means you agree to the terms and conditions\n// of the license and are in full compliance with the License.\n//\n// You may obtain a copy of the License at:\n//   \n//     https://solderpad.org/licenses/SHL-2.0/\n//   \n// Unless required by applicable law or agreed to in writing, software\n// and hardware implementations thereof distributed under the License \n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n// OF ANY KIND, EITHER EXPRESSED OR IMPLIED.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Design Name:    Prefetcher Controller SVA                                  //\n// Project Name:   CV32E40P                                                   //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    SV Properties, Assertions, etc, for the CV32E40P           //\n//                 Prefetch Controller.                                       //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_prefetch_controller_sva\n#(\n  parameter DEPTH = 4,\n  parameter COREV_PULP = 0,\n  parameter PULP_OBI = 0 ,\n  parameter FIFO_ADDR_DEPTH = (DEPTH > 1) ? $clog2(DEPTH) : 1\n)(\n  input  logic        clk,\n  input  logic        rst_n,\n\n  // Fetch stage interface\n  input  logic        req_i,                    // Fetch stage requests instructions\n  input  logic        branch_i,                 // Taken branch\n  input  logic [31:0] branch_addr_i,            // Taken branch address (only valid when branch_i = 1)\n  input  logic        busy_o,                   // Prefetcher busy\n\n  // HW loop signals\n  input  logic                     hwlp_jump_i,\n  input  logic [31:0]              hwlp_target_i,\n\n  // Transaction request interface\n  input  logic        trans_valid_o,            // Transaction request valid (to bus interface adapter)\n  input  logic        trans_ready_i,            // Transaction request ready (transaction gets accepted when trans_valid_o and trans_ready_i are both 1)\n  input  logic [31:0] trans_addr_o,             // Transaction address (only valid when trans_valid_o = 1). No stability requirements.\n\n  // Fetch interface is ready/valid\n  input  logic                     fetch_ready_i,\n  input  logic                     fetch_valid_o,\n\n  // Transaction response interface\n  input  logic        resp_valid_i,             // Note: Consumer is assumed to be 'ready' whenever resp_valid_i = 1\n\n  // FIFO interface\n  input  logic [FIFO_ADDR_DEPTH:0] fifo_cnt_i,               // Number of valid items/words in the prefetch FIFO\n  input  logic        fifo_empty_i,             // FIFO is empty\n\n  // internals used by these assertions\n  input  logic [FIFO_ADDR_DEPTH:0] cnt_q,\n  input  logic        count_up,\n  input  logic        count_down,\n  input  logic        hwlp_wait_resp_flush,\n  input  logic        hwlp_flush_after_resp,\n  input  logic [FIFO_ADDR_DEPTH:0] hwlp_flush_cnt_delayed_q,\n  input  logic        hwlp_flush_resp_delayed,\n  input  logic        hwlp_flush_resp\n);\n\n  import uvm_pkg::*; // needed for the UVM messaging service (`uvm_error(), etc.)\n\n  // Check that outstanding transaction count will not overflow DEPTH\n  property p_no_transaction_count_overflow_0;\n     @(posedge clk) disable iff (!rst_n) (1'b1) |-> (cnt_q <= DEPTH);\n  endproperty\n\n  a_no_transaction_count_overflow_0:\n    assert property(p_no_transaction_count_overflow_0)\n    else\n      `uvm_error(\"Prefetch Controller SVA\",\n                 $sformatf(\"Outstanding transaction count (%0d) greater than DEPTH (%0d)\",\n                           cnt_q, DEPTH))\n\n  property p_no_transaction_count_overflow_1;\n     @(posedge clk) disable iff (!rst_n) (cnt_q == DEPTH) |-> (!count_up || count_down);\n  endproperty\n\n  a_no_transaction_count_overflow_1:\n    assert property(p_no_transaction_count_overflow_1)\n    else\n      `uvm_error(\"Prefetch Controller SVA\",\n                 $sformatf(\"Overflow condition detected: cnt_q==%0d, DEPTH==%0d, count_up==%0d, count_down==%0d\",\n                           cnt_q, DEPTH, count_up, count_down))\n\n  generate\n  if (COREV_PULP) begin : gen_pulp_xpulp_assertions\n    // When HWLP_END-4 is in ID and we are hwlp branching,\n    // HWLP_END should at least have already been granted\n    // by the OBI interface\n    property p_hwlp_end_already_gnt_when_hwlp_branch;\n       @(posedge clk) disable iff (!rst_n) (hwlp_jump_i) |-> (cnt_q > 0 || !fifo_empty_i || resp_valid_i);\n    endproperty\n\n    a_hwlp_end_already_gnt_when_hwlp_branch: \n      assert property(p_hwlp_end_already_gnt_when_hwlp_branch)\n      else\n        `uvm_error(\"Prefetch Controller SVA\",\n                   $sformatf(\"Hardware Loop End should already be granted\"))\n\n  end else begin : gen_no_pulp_xpulp_assertions\n\n    property p_hwlp_not_used;\n       @(posedge clk) disable iff (!rst_n) (1'b1) |-> ((hwlp_jump_i == 1'b0) && (hwlp_target_i == 32'b0) && (hwlp_wait_resp_flush == 1'b0) &&\n                                  (hwlp_flush_after_resp == 1'b0) && (hwlp_flush_resp_delayed == 1'b0) && (hwlp_flush_cnt_delayed_q == 0) &&\n                                  (hwlp_flush_resp == 1'b0));\n    endproperty\n\n    a_hwlp_not_used:\n      assert property(p_hwlp_not_used)\n      else\n        `uvm_error(\"Prefetch Controller SVA\",\n                   $sformatf(\"Hardware Loop signals active while COREV_PULP = 0\"))\n\n  end\n  endgenerate\n\n\n // Check that a taken branch can only occur if fetching is requested\n  property p_branch_implies_req;\n     @(posedge clk) disable iff (!rst_n) (branch_i) |-> (req_i);\n  endproperty\n\n  a_branch_implies_req:\n    assert property(p_branch_implies_req)\n    else\n      `uvm_error(\"Prefetch Controller SVA\",\n                 $sformatf(\"Taken branch occurs while fetching is not requested\"))\n\n  // Check that after a taken branch the initial FIFO output is not accepted\n  property p_branch_invalidates_fifo;\n     @(posedge clk) disable iff (!rst_n) (branch_i) |-> (!(fetch_valid_o && fetch_ready_i));\n  endproperty\n\n  a_branch_invalidates_fifo:\n    assert property(p_branch_invalidates_fifo)\n    else\n      `uvm_error(\"Prefetch Controller SVA\",\n                 $sformatf(\"After taken branch the initial FIFO output is accepted\"))\n\n  // Check that hwlp_branch and branch_i cannot happen at the same moment\n  property p_jump_hwlp_branch_not_together;\n     @(posedge clk) disable iff (!rst_n) (branch_i || hwlp_jump_i) |-> (!hwlp_jump_i || !branch_i);\n  endproperty\n\n  a_jump_hwlp_branch_not_together:\n    assert property(p_jump_hwlp_branch_not_together)\n    else\n      `uvm_error(\"Prefetch Controller SVA\",\n                 $sformatf(\"hwlp_branch and branch_i happen at the same moment\"))\n\nendmodule: cv32e40p_prefetch_controller_sva\n","lang":"verilog"};
processSrcData(g_data);