var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_core.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Matthias Baer - baermatt@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Top level module                                           //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Top level module of the RISC-V core.                       //\n//                 added APU, FPU parameter to include the APU_dispatcher     //\n//                 and the FPU                                                //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_core\n  import cv32e40p_apu_core_pkg::*;\n#(\n    parameter COREV_PULP =  0,  // PULP ISA Extension (incl. custom CSRs and hardware loop, excl. cv.elw)\n    parameter COREV_CLUSTER = 0,  // PULP Cluster interface (incl. cv.elw)\n    parameter FPU = 0,  // Floating Point Unit (interfaced via APU interface)\n    parameter FPU_ADDMUL_LAT = 0,  // Floating-Point ADDition/MULtiplication lane pipeline registers number\n    parameter FPU_OTHERS_LAT = 0,  // Floating-Point COMParison/CONVersion lanes pipeline registers number\n    parameter ZFINX = 0,  // Float-in-General Purpose registers\n    parameter NUM_MHPMCOUNTERS = 1\n) (\n    // Clock and Reset\n    input logic clk_i,\n    input logic rst_ni,\n\n    input logic pulp_clock_en_i,  // PULP clock enable (only used if COREV_CLUSTER = 1)\n    input logic scan_cg_en_i,  // Enable all clock gates for testing\n\n    // Core ID, Cluster ID, debug mode halt address and boot address are considered more or less static\n    input logic [31:0] boot_addr_i,\n    input logic [31:0] mtvec_addr_i,\n    input logic [31:0] dm_halt_addr_i,\n    input logic [31:0] hart_id_i,\n    input logic [31:0] dm_exception_addr_i,\n\n    // Instruction memory interface\n    output logic        instr_req_o,\n    input  logic        instr_gnt_i,\n    input  logic        instr_rvalid_i,\n    output logic [31:0] instr_addr_o,\n    input  logic [31:0] instr_rdata_i,\n\n    // Data memory interface\n    output logic        data_req_o,\n    input  logic        data_gnt_i,\n    input  logic        data_rvalid_i,\n    output logic        data_we_o,\n    output logic [ 3:0] data_be_o,\n    output logic [31:0] data_addr_o,\n    output logic [31:0] data_wdata_o,\n    input  logic [31:0] data_rdata_i,\n\n    // CVFPU interface\n    output logic                              apu_busy_o,\n    // handshake signals\n    output logic                              apu_req_o,\n    input  logic                              apu_gnt_i,\n    // request channel\n    output logic [   APU_NARGS_CPU-1:0][31:0] apu_operands_o,\n    output logic [     APU_WOP_CPU-1:0]       apu_op_o,\n    output logic [APU_NDSFLAGS_CPU-1:0]       apu_flags_o,\n    // response channel\n    input  logic                              apu_rvalid_i,\n    input  logic [                31:0]       apu_result_i,\n    input  logic [APU_NUSFLAGS_CPU-1:0]       apu_flags_i,\n\n    // Interrupt inputs\n    input  logic [31:0] irq_i,  // CLINT interrupts + CLINT extension interrupts\n    output logic        irq_ack_o,\n    output logic [ 4:0] irq_id_o,\n\n    // Debug Interface\n    input  logic debug_req_i,\n    output logic debug_havereset_o,\n    output logic debug_running_o,\n    output logic debug_halted_o,\n\n    // CPU Control Signals\n    input  logic fetch_enable_i,\n    output logic core_sleep_o\n);\n\n  import cv32e40p_pkg::*;\n\n  // Unused parameters and signals (left in code for future design extensions)\n  localparam PULP_SECURE = 0;\n  localparam N_PMP_ENTRIES = 16;\n  localparam USE_PMP = 0;  // if PULP_SECURE is 1, you can still not use the PMP\n  localparam A_EXTENSION = 0;\n  localparam DEBUG_TRIGGER_EN = 1;\n\n  // PULP bus interface behavior\n  // If enabled will allow non-stable address phase signals during waited instructions requests and\n  // will re-introduce combinatorial paths from instr_rvalid_i to instr_req_o and from from data_rvalid_i\n  // to data_req_o\n  localparam PULP_OBI = 0;\n\n  // Unused signals related to above unused parameters\n  // Left in code (with their original _i, _o postfixes) for future design extensions;\n  // these used to be former inputs/outputs of RI5CY\n\n  logic [5:0] data_atop_o;  // atomic operation, only active if parameter `A_EXTENSION != 0`\n  logic       irq_sec_i;\n  logic       sec_lvl_o;\n\n  localparam N_HWLP = 2;\n  localparam APU = (FPU == 1) ? 1 : 0;\n\n  // IF/ID signals\n  logic        instr_valid_id;\n  logic [31:0] instr_rdata_id;  // Instruction sampled inside IF stage\n  logic        is_compressed_id;\n  logic        illegal_c_insn_id;\n  logic        is_fetch_failed_id;\n\n  logic        clear_instr_valid;\n  logic        pc_set;\n\n  logic [ 3:0] pc_mux_id;  // Mux selector for next PC\n  logic [ 2:0] exc_pc_mux_id;  // Mux selector for exception PC\n  logic [ 4:0] m_exc_vec_pc_mux_id;  // Mux selector for vectored IRQ PC\n  logic [ 4:0] u_exc_vec_pc_mux_id;  // Mux selector for vectored IRQ PC\n  logic [ 4:0] exc_cause;\n\n  logic [ 1:0] trap_addr_mux;\n\n  logic [31:0] pc_if;  // Program counter in IF stage\n  logic [31:0] pc_id;  // Program counter in ID stage\n\n  // ID performance counter signals\n  logic        is_decoding;\n\n  logic        useincr_addr_ex;  // Active when post increment\n  logic        data_misaligned;\n\n  logic        mult_multicycle;\n\n  // Jump and branch target and decision (EX->IF)\n  logic [31:0] jump_target_id, jump_target_ex;\n  logic               branch_in_ex;\n  logic               branch_decision;\n  logic        [ 1:0] ctrl_transfer_insn_in_dec;\n\n  logic               ctrl_busy;\n  logic               if_busy;\n  logic               lsu_busy;\n\n  logic        [31:0] pc_ex;  // PC of last executed branch or cv.elw\n\n  // ALU Control\n  logic               alu_en_ex;\n  alu_opcode_e        alu_operator_ex;\n  logic        [31:0] alu_operand_a_ex;\n  logic        [31:0] alu_operand_b_ex;\n  logic        [31:0] alu_operand_c_ex;\n  logic        [ 4:0] bmask_a_ex;\n  logic        [ 4:0] bmask_b_ex;\n  logic        [ 1:0] imm_vec_ext_ex;\n  logic        [ 1:0] alu_vec_mode_ex;\n  logic alu_is_clpx_ex, alu_is_subrot_ex;\n  logic        [                 1:0]       alu_clpx_shift_ex;\n\n  // Multiplier Control\n  mul_opcode_e                              mult_operator_ex;\n  logic        [                31:0]       mult_operand_a_ex;\n  logic        [                31:0]       mult_operand_b_ex;\n  logic        [                31:0]       mult_operand_c_ex;\n  logic                                     mult_en_ex;\n  logic                                     mult_sel_subword_ex;\n  logic        [                 1:0]       mult_signed_mode_ex;\n  logic        [                 4:0]       mult_imm_ex;\n  logic        [                31:0]       mult_dot_op_a_ex;\n  logic        [                31:0]       mult_dot_op_b_ex;\n  logic        [                31:0]       mult_dot_op_c_ex;\n  logic        [                 1:0]       mult_dot_signed_ex;\n  logic                                     mult_is_clpx_ex;\n  logic        [                 1:0]       mult_clpx_shift_ex;\n  logic                                     mult_clpx_img_ex;\n\n  // FPU\n  logic                                     fs_off;\n  logic        [            C_RM-1:0]       frm_csr;\n  logic        [         C_FFLAG-1:0]       fflags_csr;\n  logic                                     fflags_we;\n  logic                                     fregs_we;\n\n  // APU\n  logic                                     apu_en_ex;\n  logic        [APU_NDSFLAGS_CPU-1:0]       apu_flags_ex;\n  logic        [     APU_WOP_CPU-1:0]       apu_op_ex;\n  logic        [                 1:0]       apu_lat_ex;\n  logic        [   APU_NARGS_CPU-1:0][31:0] apu_operands_ex;\n  logic        [                 5:0]       apu_waddr_ex;\n\n  logic        [                 2:0][ 5:0] apu_read_regs;\n  logic        [                 2:0]       apu_read_regs_valid;\n  logic                                     apu_read_dep;\n  logic                                     apu_read_dep_for_jalr;\n  logic        [                 1:0][ 5:0] apu_write_regs;\n  logic        [                 1:0]       apu_write_regs_valid;\n  logic                                     apu_write_dep;\n\n  logic                                     perf_apu_type;\n  logic                                     perf_apu_cont;\n  logic                                     perf_apu_dep;\n  logic                                     perf_apu_wb;\n\n  // Register Write Control\n  logic        [                 5:0]       regfile_waddr_ex;\n  logic                                     regfile_we_ex;\n  logic        [                 5:0]       regfile_waddr_fw_wb_o;  // From WB to ID\n  logic                                     regfile_we_wb;\n  logic                                     regfile_we_wb_power;\n  logic        [                31:0]       regfile_wdata;\n\n  logic        [                 5:0]       regfile_alu_waddr_ex;\n  logic                                     regfile_alu_we_ex;\n\n  logic        [                 5:0]       regfile_alu_waddr_fw;\n  logic                                     regfile_alu_we_fw;\n  logic                                     regfile_alu_we_fw_power;\n  logic        [                31:0]       regfile_alu_wdata_fw;\n\n  // CSR control\n  logic                                     csr_access_ex;\n  csr_opcode_e                              csr_op_ex;\n  logic [23:0] mtvec, utvec;\n  logic        [ 1:0] mtvec_mode;\n  logic        [ 1:0] utvec_mode;\n\n  csr_opcode_e        csr_op;\n  csr_num_e           csr_addr;\n  csr_num_e           csr_addr_int;\n  logic        [31:0] csr_rdata;\n  logic        [31:0] csr_wdata;\n  PrivLvl_t           current_priv_lvl;\n\n  // Data Memory Control:  From ID stage (id-ex pipe) <--> load store unit\n  logic               data_we_ex;\n  logic        [ 5:0] data_atop_ex;\n  logic        [ 1:0] data_type_ex;\n  logic        [ 1:0] data_sign_ext_ex;\n  logic        [ 1:0] data_reg_offset_ex;\n  logic               data_req_ex;\n  logic               data_load_event_ex;\n  logic               data_misaligned_ex;\n\n  logic               p_elw_start;  // Start of cv.elw load (when data_req_o is sent)\n  logic               p_elw_finish;  // Finish of cv.elw load (when data_rvalid_i is received)\n\n  logic        [31:0] lsu_rdata;\n\n  // stall control\n  logic               halt_if;\n  logic               id_ready;\n  logic               ex_ready;\n\n  logic               id_valid;\n  logic               ex_valid;\n  logic               wb_valid;\n\n  logic               lsu_ready_ex;\n  logic               lsu_ready_wb;\n\n  logic               apu_ready_wb;\n\n  // Signals between instruction core interface and pipe (if and id stages)\n  logic               instr_req_int;  // Id stage asserts a req to instruction core interface\n\n  // Interrupts\n  logic m_irq_enable, u_irq_enable;\n  logic csr_irq_sec;\n  logic [31:0] mepc, uepc, depc;\n  logic [             31:0]       mie_bypass;\n  logic [             31:0]       mip;\n\n  logic                           csr_save_cause;\n  logic                           csr_save_if;\n  logic                           csr_save_id;\n  logic                           csr_save_ex;\n  logic [              5:0]       csr_cause;\n  logic                           csr_restore_mret_id;\n  logic                           csr_restore_uret_id;\n  logic                           csr_restore_dret_id;\n  logic                           csr_mtvec_init;\n\n  // HPM related control signals\n  logic [             31:0]       mcounteren;\n\n  // debug mode and dcsr configuration\n  logic                           debug_mode;\n  logic [              2:0]       debug_cause;\n  logic                           debug_csr_save;\n  logic                           debug_single_step;\n  logic                           debug_ebreakm;\n  logic                           debug_ebreaku;\n  logic                           trigger_match;\n  logic                           debug_p_elw_no_sleep;\n\n  // Hardware loop controller signals\n  logic [       N_HWLP-1:0][31:0] hwlp_start;\n  logic [       N_HWLP-1:0][31:0] hwlp_end;\n  logic [       N_HWLP-1:0][31:0] hwlp_cnt;\n\n  logic [             31:0]       hwlp_target;\n  logic                           hwlp_jump;\n\n  // Performance Counters\n  logic                           mhpmevent_minstret;\n  logic                           mhpmevent_load;\n  logic                           mhpmevent_store;\n  logic                           mhpmevent_jump;\n  logic                           mhpmevent_branch;\n  logic                           mhpmevent_branch_taken;\n  logic                           mhpmevent_compressed;\n  logic                           mhpmevent_jr_stall;\n  logic                           mhpmevent_imiss;\n  logic                           mhpmevent_ld_stall;\n  logic                           mhpmevent_pipe_stall;\n\n  logic                           perf_imiss;\n\n  // Wake signal\n  logic                           wake_from_sleep;\n\n  // PMP signals\n  logic [N_PMP_ENTRIES-1:0][31:0] pmp_addr;\n  logic [N_PMP_ENTRIES-1:0][ 7:0] pmp_cfg;\n\n  logic                           data_req_pmp;\n  logic [             31:0]       data_addr_pmp;\n  logic                           data_gnt_pmp;\n  logic                           data_err_pmp;\n  logic                           data_err_ack;\n  logic                           instr_req_pmp;\n  logic                           instr_gnt_pmp;\n  logic [             31:0]       instr_addr_pmp;\n  logic                           instr_err_pmp;\n\n  // Mux selector for vectored IRQ PC\n  assign m_exc_vec_pc_mux_id = (mtvec_mode == 2'b0) ? 5'h0 : exc_cause;\n  assign u_exc_vec_pc_mux_id = (utvec_mode == 2'b0) ? 5'h0 : exc_cause;\n\n  // PULP_SECURE == 0\n  assign irq_sec_i = 1'b0;\n\n  // APU master signals\n  assign apu_flags_o = apu_flags_ex;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  //   ____ _            _      __  __                                                   _    //\n  //  / ___| | ___   ___| | __ |  \\/  | __ _ _ __   __ _  __ _  ___ _ __ ___   ___ _ __ | |_  //\n  // | |   | |/ _ \\ / __| |/ / | |\\/| |/ _` | '_ \\ / _` |/ _` |/ _ \\ '_ ` _ \\ / _ \\ '_ \\| __| //\n  // | |___| | (_) | (__|   <  | |  | | (_| | | | | (_| | (_| |  __/ | | | | |  __/ | | | |_  //\n  //  \\____|_|\\___/ \\___|_|\\_\\ |_|  |_|\\__,_|_| |_|\\__,_|\\__, |\\___|_| |_| |_|\\___|_| |_|\\__| //\n  //                                                     |___/                                //\n  //////////////////////////////////////////////////////////////////////////////////////////////\n\n  logic clk;\n  logic fetch_enable;\n\n  cv32e40p_sleep_unit #(\n      .COREV_CLUSTER(COREV_CLUSTER)\n  ) sleep_unit_i (\n      // Clock, reset interface\n      .clk_ungated_i(clk_i),  // Ungated clock\n      .rst_n        (rst_ni),\n      .clk_gated_o  (clk),  // Gated clock\n      .scan_cg_en_i (scan_cg_en_i),\n\n      // Core sleep\n      .core_sleep_o(core_sleep_o),\n\n      // Fetch enable\n      .fetch_enable_i(fetch_enable_i),\n      .fetch_enable_o(fetch_enable),\n\n      // Core status\n      .if_busy_i  (if_busy),\n      .ctrl_busy_i(ctrl_busy),\n      .lsu_busy_i (lsu_busy),\n      .apu_busy_i (apu_busy_o),\n\n      // PULP cluster\n      .pulp_clock_en_i       (pulp_clock_en_i),\n      .p_elw_start_i         (p_elw_start),\n      .p_elw_finish_i        (p_elw_finish),\n      .debug_p_elw_no_sleep_i(debug_p_elw_no_sleep),\n\n      // WFI wake\n      .wake_from_sleep_i(wake_from_sleep)\n  );\n\n\n  //////////////////////////////////////////////////\n  //   ___ _____   ____ _____  _    ____ _____    //\n  //  |_ _|  ___| / ___|_   _|/ \\  / ___| ____|   //\n  //   | || |_    \\___ \\ | | / _ \\| |  _|  _|     //\n  //   | ||  _|    ___) || |/ ___ \\ |_| | |___    //\n  //  |___|_|     |____/ |_/_/   \\_\\____|_____|   //\n  //                                              //\n  //////////////////////////////////////////////////\n  cv32e40p_if_stage #(\n      .COREV_PULP (COREV_PULP),\n      .PULP_OBI   (PULP_OBI),\n      .PULP_SECURE(PULP_SECURE),\n      .FPU        (FPU),\n      .ZFINX      (ZFINX)\n  ) if_stage_i (\n      .clk  (clk),\n      .rst_n(rst_ni),\n\n      // boot address\n      .boot_addr_i        (boot_addr_i[31:0]),\n      .dm_exception_addr_i(dm_exception_addr_i[31:0]),\n\n      // debug mode halt address\n      .dm_halt_addr_i(dm_halt_addr_i[31:0]),\n\n      // trap vector location\n      .m_trap_base_addr_i(mtvec),\n      .u_trap_base_addr_i(utvec),\n      .trap_addr_mux_i   (trap_addr_mux),\n\n      // instruction request control\n      .req_i(instr_req_int),\n\n      // instruction cache interface\n      .instr_req_o    (instr_req_pmp),\n      .instr_addr_o   (instr_addr_pmp),\n      .instr_gnt_i    (instr_gnt_pmp),\n      .instr_rvalid_i (instr_rvalid_i),\n      .instr_rdata_i  (instr_rdata_i),\n      .instr_err_i    (1'b0),  // Bus error (not used yet)\n      .instr_err_pmp_i(instr_err_pmp),  // PMP error\n\n      // outputs to ID stage\n      .instr_valid_id_o (instr_valid_id),\n      .instr_rdata_id_o (instr_rdata_id),\n      .is_fetch_failed_o(is_fetch_failed_id),\n\n      // control signals\n      .clear_instr_valid_i(clear_instr_valid),\n      .pc_set_i           (pc_set),\n\n      .mepc_i(mepc),  // exception return address\n      .uepc_i(uepc),  // exception return address\n\n      .depc_i(depc),  // debug return address\n\n      .pc_mux_i    (pc_mux_id),  // sel for pc multiplexer\n      .exc_pc_mux_i(exc_pc_mux_id),\n\n\n      .pc_id_o(pc_id),\n      .pc_if_o(pc_if),\n\n      .is_compressed_id_o (is_compressed_id),\n      .illegal_c_insn_id_o(illegal_c_insn_id),\n\n      .m_exc_vec_pc_mux_i(m_exc_vec_pc_mux_id),\n      .u_exc_vec_pc_mux_i(u_exc_vec_pc_mux_id),\n\n      .csr_mtvec_init_o(csr_mtvec_init),\n\n      // from hwloop registers\n      .hwlp_jump_i  (hwlp_jump),\n      .hwlp_target_i(hwlp_target),\n\n\n      // Jump targets\n      .jump_target_id_i(jump_target_id),\n      .jump_target_ex_i(jump_target_ex),\n\n      // pipeline stalls\n      .halt_if_i (halt_if),\n      .id_ready_i(id_ready),\n\n      .if_busy_o   (if_busy),\n      .perf_imiss_o(perf_imiss)\n  );\n\n\n  /////////////////////////////////////////////////\n  //   ___ ____    ____ _____  _    ____ _____   //\n  //  |_ _|  _ \\  / ___|_   _|/ \\  / ___| ____|  //\n  //   | || | | | \\___ \\ | | / _ \\| |  _|  _|    //\n  //   | || |_| |  ___) || |/ ___ \\ |_| | |___   //\n  //  |___|____/  |____/ |_/_/   \\_\\____|_____|  //\n  //                                             //\n  /////////////////////////////////////////////////\n  cv32e40p_id_stage #(\n      .COREV_PULP      (COREV_PULP),\n      .COREV_CLUSTER   (COREV_CLUSTER),\n      .N_HWLP          (N_HWLP),\n      .PULP_SECURE     (PULP_SECURE),\n      .USE_PMP         (USE_PMP),\n      .A_EXTENSION     (A_EXTENSION),\n      .APU             (APU),\n      .FPU             (FPU),\n      .FPU_ADDMUL_LAT  (FPU_ADDMUL_LAT),\n      .FPU_OTHERS_LAT  (FPU_OTHERS_LAT),\n      .ZFINX           (ZFINX),\n      .APU_NARGS_CPU   (APU_NARGS_CPU),\n      .APU_WOP_CPU     (APU_WOP_CPU),\n      .APU_NDSFLAGS_CPU(APU_NDSFLAGS_CPU),\n      .APU_NUSFLAGS_CPU(APU_NUSFLAGS_CPU),\n      .DEBUG_TRIGGER_EN(DEBUG_TRIGGER_EN)\n  ) id_stage_i (\n      .clk          (clk),  // Gated clock\n      .clk_ungated_i(clk_i),  // Ungated clock\n      .rst_n        (rst_ni),\n\n      .scan_cg_en_i(scan_cg_en_i),\n\n      // Processor Enable\n      .fetch_enable_i               ( fetch_enable         ),     // Delayed version so that clock can remain gated until fetch enabled\n      .ctrl_busy_o(ctrl_busy),\n      .is_decoding_o(is_decoding),\n\n      // Interface to instruction memory\n      .instr_valid_i(instr_valid_id),\n      .instr_rdata_i(instr_rdata_id),\n      .instr_req_o  (instr_req_int),\n\n      // Jumps and branches\n      .branch_in_ex_o             (branch_in_ex),\n      .branch_decision_i          (branch_decision),\n      .jump_target_o              (jump_target_id),\n      .ctrl_transfer_insn_in_dec_o(ctrl_transfer_insn_in_dec),\n\n      // IF and ID control signals\n      .clear_instr_valid_o(clear_instr_valid),\n      .pc_set_o           (pc_set),\n      .pc_mux_o           (pc_mux_id),\n      .exc_pc_mux_o       (exc_pc_mux_id),\n      .exc_cause_o        (exc_cause),\n      .trap_addr_mux_o    (trap_addr_mux),\n\n      .is_fetch_failed_i(is_fetch_failed_id),\n\n      .pc_id_i(pc_id),\n\n      .is_compressed_i (is_compressed_id),\n      .illegal_c_insn_i(illegal_c_insn_id),\n\n      // Stalls\n      .halt_if_o(halt_if),\n\n      .id_ready_o(id_ready),\n      .ex_ready_i(ex_ready),\n      .wb_ready_i(lsu_ready_wb),\n\n      .id_valid_o(id_valid),\n      .ex_valid_i(ex_valid),\n\n      // From the Pipeline ID/EX\n      .pc_ex_o(pc_ex),\n\n      .alu_en_ex_o        (alu_en_ex),\n      .alu_operator_ex_o  (alu_operator_ex),\n      .alu_operand_a_ex_o (alu_operand_a_ex),\n      .alu_operand_b_ex_o (alu_operand_b_ex),\n      .alu_operand_c_ex_o (alu_operand_c_ex),\n      .bmask_a_ex_o       (bmask_a_ex),\n      .bmask_b_ex_o       (bmask_b_ex),\n      .imm_vec_ext_ex_o   (imm_vec_ext_ex),\n      .alu_vec_mode_ex_o  (alu_vec_mode_ex),\n      .alu_is_clpx_ex_o   (alu_is_clpx_ex),\n      .alu_is_subrot_ex_o (alu_is_subrot_ex),\n      .alu_clpx_shift_ex_o(alu_clpx_shift_ex),\n\n      .regfile_waddr_ex_o(regfile_waddr_ex),\n      .regfile_we_ex_o   (regfile_we_ex),\n\n      .regfile_alu_we_ex_o   (regfile_alu_we_ex),\n      .regfile_alu_waddr_ex_o(regfile_alu_waddr_ex),\n\n      // MUL\n      .mult_operator_ex_o   (mult_operator_ex),  // from ID to EX stage\n      .mult_en_ex_o         (mult_en_ex),  // from ID to EX stage\n      .mult_sel_subword_ex_o(mult_sel_subword_ex),  // from ID to EX stage\n      .mult_signed_mode_ex_o(mult_signed_mode_ex),  // from ID to EX stage\n      .mult_operand_a_ex_o  (mult_operand_a_ex),  // from ID to EX stage\n      .mult_operand_b_ex_o  (mult_operand_b_ex),  // from ID to EX stage\n      .mult_operand_c_ex_o  (mult_operand_c_ex),  // from ID to EX stage\n      .mult_imm_ex_o        (mult_imm_ex),  // from ID to EX stage\n\n      .mult_dot_op_a_ex_o  (mult_dot_op_a_ex),  // from ID to EX stage\n      .mult_dot_op_b_ex_o  (mult_dot_op_b_ex),  // from ID to EX stage\n      .mult_dot_op_c_ex_o  (mult_dot_op_c_ex),  // from ID to EX stage\n      .mult_dot_signed_ex_o(mult_dot_signed_ex),  // from ID to EX stage\n      .mult_is_clpx_ex_o   (mult_is_clpx_ex),  // from ID to EX stage\n      .mult_clpx_shift_ex_o(mult_clpx_shift_ex),  // from ID to EX stage\n      .mult_clpx_img_ex_o  (mult_clpx_img_ex),  // from ID to EX stage\n\n      // FPU\n      .fs_off_i(fs_off),\n      .frm_i   (frm_csr),\n\n      // APU\n      .apu_en_ex_o      (apu_en_ex),\n      .apu_op_ex_o      (apu_op_ex),\n      .apu_lat_ex_o     (apu_lat_ex),\n      .apu_operands_ex_o(apu_operands_ex),\n      .apu_flags_ex_o   (apu_flags_ex),\n      .apu_waddr_ex_o   (apu_waddr_ex),\n\n      .apu_read_regs_o        (apu_read_regs),\n      .apu_read_regs_valid_o  (apu_read_regs_valid),\n      .apu_read_dep_i         (apu_read_dep),\n      .apu_read_dep_for_jalr_i(apu_read_dep_for_jalr),\n      .apu_write_regs_o       (apu_write_regs),\n      .apu_write_regs_valid_o (apu_write_regs_valid),\n      .apu_write_dep_i        (apu_write_dep),\n      .apu_perf_dep_o         (perf_apu_dep),\n      .apu_busy_i             (apu_busy_o),\n\n      // CSR ID/EX\n      .csr_access_ex_o      (csr_access_ex),\n      .csr_op_ex_o          (csr_op_ex),\n      .current_priv_lvl_i   (current_priv_lvl),\n      .csr_irq_sec_o        (csr_irq_sec),\n      .csr_cause_o          (csr_cause),\n      .csr_save_if_o        (csr_save_if),  // control signal to save pc\n      .csr_save_id_o        (csr_save_id),  // control signal to save pc\n      .csr_save_ex_o        (csr_save_ex),  // control signal to save pc\n      .csr_restore_mret_id_o(csr_restore_mret_id),  // control signal to restore pc\n      .csr_restore_uret_id_o(csr_restore_uret_id),  // control signal to restore pc\n\n      .csr_restore_dret_id_o(csr_restore_dret_id),  // control signal to restore pc\n\n      .csr_save_cause_o(csr_save_cause),\n\n      // hardware loop signals to IF hwlp controller\n      .hwlp_start_o(hwlp_start),\n      .hwlp_end_o  (hwlp_end),\n      .hwlp_cnt_o  (hwlp_cnt),\n\n      .hwlp_jump_o  (hwlp_jump),\n      .hwlp_target_o(hwlp_target),\n\n      // LSU\n      .data_req_ex_o       (data_req_ex),  // to load store unit\n      .data_we_ex_o        (data_we_ex),  // to load store unit\n      .atop_ex_o           (data_atop_ex),\n      .data_type_ex_o      (data_type_ex),  // to load store unit\n      .data_sign_ext_ex_o  (data_sign_ext_ex),  // to load store unit\n      .data_reg_offset_ex_o(data_reg_offset_ex),  // to load store unit\n      .data_load_event_ex_o(data_load_event_ex),  // to load store unit\n\n      .data_misaligned_ex_o(data_misaligned_ex),  // to load store unit\n\n      .prepost_useincr_ex_o(useincr_addr_ex),\n      .data_misaligned_i   (data_misaligned),\n      .data_err_i          (data_err_pmp),\n      .data_err_ack_o      (data_err_ack),\n\n      // Interrupt Signals\n      .irq_i         (irq_i),\n      .irq_sec_i     ((PULP_SECURE) ? irq_sec_i : 1'b0),\n      .mie_bypass_i  (mie_bypass),\n      .mip_o         (mip),\n      .m_irq_enable_i(m_irq_enable),\n      .u_irq_enable_i(u_irq_enable),\n      .irq_ack_o     (irq_ack_o),\n      .irq_id_o      (irq_id_o),\n\n      // Debug Signal\n      .debug_mode_o          (debug_mode),\n      .debug_cause_o         (debug_cause),\n      .debug_csr_save_o      (debug_csr_save),\n      .debug_req_i           (debug_req_i),\n      .debug_havereset_o     (debug_havereset_o),\n      .debug_running_o       (debug_running_o),\n      .debug_halted_o        (debug_halted_o),\n      .debug_single_step_i   (debug_single_step),\n      .debug_ebreakm_i       (debug_ebreakm),\n      .debug_ebreaku_i       (debug_ebreaku),\n      .trigger_match_i       (trigger_match),\n      .debug_p_elw_no_sleep_o(debug_p_elw_no_sleep),\n\n      // Wakeup Signal\n      .wake_from_sleep_o(wake_from_sleep),\n\n      // Forward Signals\n      .regfile_waddr_wb_i   (regfile_waddr_fw_wb_o),  // Write address ex-wb pipeline\n      .regfile_we_wb_i      (regfile_we_wb),  // write enable for the register file\n      .regfile_we_wb_power_i(regfile_we_wb_power),\n      .regfile_wdata_wb_i   (regfile_wdata),  // write data to commit in the register file\n\n      .regfile_alu_waddr_fw_i   (regfile_alu_waddr_fw),\n      .regfile_alu_we_fw_i      (regfile_alu_we_fw),\n      .regfile_alu_we_fw_power_i(regfile_alu_we_fw_power),\n      .regfile_alu_wdata_fw_i   (regfile_alu_wdata_fw),\n\n      // from ALU\n      .mult_multicycle_i(mult_multicycle),\n\n      // Performance Counters\n      .mhpmevent_minstret_o    (mhpmevent_minstret),\n      .mhpmevent_load_o        (mhpmevent_load),\n      .mhpmevent_store_o       (mhpmevent_store),\n      .mhpmevent_jump_o        (mhpmevent_jump),\n      .mhpmevent_branch_o      (mhpmevent_branch),\n      .mhpmevent_branch_taken_o(mhpmevent_branch_taken),\n      .mhpmevent_compressed_o  (mhpmevent_compressed),\n      .mhpmevent_jr_stall_o    (mhpmevent_jr_stall),\n      .mhpmevent_imiss_o       (mhpmevent_imiss),\n      .mhpmevent_ld_stall_o    (mhpmevent_ld_stall),\n      .mhpmevent_pipe_stall_o  (mhpmevent_pipe_stall),\n\n      .perf_imiss_i(perf_imiss),\n      .mcounteren_i(mcounteren)\n  );\n\n\n  /////////////////////////////////////////////////////\n  //   _______  __  ____ _____  _    ____ _____      //\n  //  | ____\\ \\/ / / ___|_   _|/ \\  / ___| ____|     //\n  //  |  _|  \\  /  \\___ \\ | | / _ \\| |  _|  _|       //\n  //  | |___ /  \\   ___) || |/ ___ \\ |_| | |___      //\n  //  |_____/_/\\_\\ |____/ |_/_/   \\_\\____|_____|     //\n  //                                                 //\n  /////////////////////////////////////////////////////\n  cv32e40p_ex_stage #(\n      .COREV_PULP      (COREV_PULP),\n      .FPU             (FPU),\n      .APU_NARGS_CPU   (APU_NARGS_CPU),\n      .APU_WOP_CPU     (APU_WOP_CPU),\n      .APU_NDSFLAGS_CPU(APU_NDSFLAGS_CPU),\n      .APU_NUSFLAGS_CPU(APU_NUSFLAGS_CPU)\n  ) ex_stage_i (\n      // Global signals: Clock and active low asynchronous reset\n      .clk  (clk),\n      .rst_n(rst_ni),\n\n      // Alu signals from ID stage\n      .alu_en_i        (alu_en_ex),\n      .alu_operator_i  (alu_operator_ex),  // from ID/EX pipe registers\n      .alu_operand_a_i (alu_operand_a_ex),  // from ID/EX pipe registers\n      .alu_operand_b_i (alu_operand_b_ex),  // from ID/EX pipe registers\n      .alu_operand_c_i (alu_operand_c_ex),  // from ID/EX pipe registers\n      .bmask_a_i       (bmask_a_ex),  // from ID/EX pipe registers\n      .bmask_b_i       (bmask_b_ex),  // from ID/EX pipe registers\n      .imm_vec_ext_i   (imm_vec_ext_ex),  // from ID/EX pipe registers\n      .alu_vec_mode_i  (alu_vec_mode_ex),  // from ID/EX pipe registers\n      .alu_is_clpx_i   (alu_is_clpx_ex),  // from ID/EX pipe registers\n      .alu_is_subrot_i (alu_is_subrot_ex),  // from ID/Ex pipe registers\n      .alu_clpx_shift_i(alu_clpx_shift_ex),  // from ID/EX pipe registers\n\n      // Multipler\n      .mult_operator_i   (mult_operator_ex),  // from ID/EX pipe registers\n      .mult_operand_a_i  (mult_operand_a_ex),  // from ID/EX pipe registers\n      .mult_operand_b_i  (mult_operand_b_ex),  // from ID/EX pipe registers\n      .mult_operand_c_i  (mult_operand_c_ex),  // from ID/EX pipe registers\n      .mult_en_i         (mult_en_ex),  // from ID/EX pipe registers\n      .mult_sel_subword_i(mult_sel_subword_ex),  // from ID/EX pipe registers\n      .mult_signed_mode_i(mult_signed_mode_ex),  // from ID/EX pipe registers\n      .mult_imm_i        (mult_imm_ex),  // from ID/EX pipe registers\n      .mult_dot_op_a_i   (mult_dot_op_a_ex),  // from ID/EX pipe registers\n      .mult_dot_op_b_i   (mult_dot_op_b_ex),  // from ID/EX pipe registers\n      .mult_dot_op_c_i   (mult_dot_op_c_ex),  // from ID/EX pipe registers\n      .mult_dot_signed_i (mult_dot_signed_ex),  // from ID/EX pipe registers\n      .mult_is_clpx_i    (mult_is_clpx_ex),  // from ID/EX pipe registers\n      .mult_clpx_shift_i (mult_clpx_shift_ex),  // from ID/EX pipe registers\n      .mult_clpx_img_i   (mult_clpx_img_ex),  // from ID/EX pipe registers\n\n      .mult_multicycle_o(mult_multicycle),  // to ID/EX pipe registers\n\n      .data_req_i          (data_req_o),  // from ID/EX pipeline\n      .data_rvalid_i       (data_rvalid_i),  // from ID/EX pipeline\n      .data_misaligned_ex_i(data_misaligned_ex),  // from ID/EX pipeline\n      .data_misaligned_i   (data_misaligned),\n\n      .ctrl_transfer_insn_in_dec_i(ctrl_transfer_insn_in_dec),\n\n      // FPU\n      .fpu_fflags_we_o(fflags_we),\n      .fpu_fflags_o   (fflags_csr),\n\n      // APU\n      .apu_en_i      (apu_en_ex),\n      .apu_op_i      (apu_op_ex),\n      .apu_lat_i     (apu_lat_ex),\n      .apu_operands_i(apu_operands_ex),\n      .apu_waddr_i   (apu_waddr_ex),\n\n      .apu_read_regs_i        (apu_read_regs),\n      .apu_read_regs_valid_i  (apu_read_regs_valid),\n      .apu_read_dep_o         (apu_read_dep),\n      .apu_read_dep_for_jalr_o(apu_read_dep_for_jalr),\n      .apu_write_regs_i       (apu_write_regs),\n      .apu_write_regs_valid_i (apu_write_regs_valid),\n      .apu_write_dep_o        (apu_write_dep),\n\n      .apu_perf_type_o(perf_apu_type),\n      .apu_perf_cont_o(perf_apu_cont),\n      .apu_perf_wb_o  (perf_apu_wb),\n      .apu_ready_wb_o (apu_ready_wb),\n      .apu_busy_o     (apu_busy_o),\n\n      // CVFPU interface\n      // handshake signals\n      .apu_req_o     (apu_req_o),\n      .apu_gnt_i     (apu_gnt_i),\n      // request channel\n      .apu_operands_o(apu_operands_o),\n      .apu_op_o      (apu_op_o),\n      // response channel\n      .apu_rvalid_i  (apu_rvalid_i),\n      .apu_result_i  (apu_result_i),\n      .apu_flags_i   (apu_flags_i),\n\n      .lsu_en_i   (data_req_ex),\n      .lsu_rdata_i(lsu_rdata),\n\n      // interface with CSRs\n      .csr_access_i(csr_access_ex),\n      .csr_rdata_i (csr_rdata),\n\n      // From ID Stage: Regfile control signals\n      .branch_in_ex_i     (branch_in_ex),\n      .regfile_alu_waddr_i(regfile_alu_waddr_ex),\n      .regfile_alu_we_i   (regfile_alu_we_ex),\n\n      .regfile_waddr_i(regfile_waddr_ex),\n      .regfile_we_i   (regfile_we_ex),\n\n      // Output of ex stage pipeline\n      .regfile_waddr_wb_o   (regfile_waddr_fw_wb_o),\n      .regfile_we_wb_o      (regfile_we_wb),\n      .regfile_we_wb_power_o(regfile_we_wb_power),\n      .regfile_wdata_wb_o   (regfile_wdata),\n\n      // To IF: Jump and branch target and decision\n      .jump_target_o    (jump_target_ex),\n      .branch_decision_o(branch_decision),\n\n      // To ID stage: Forwarding signals\n      .regfile_alu_waddr_fw_o   (regfile_alu_waddr_fw),\n      .regfile_alu_we_fw_o      (regfile_alu_we_fw),\n      .regfile_alu_we_fw_power_o(regfile_alu_we_fw_power),\n      .regfile_alu_wdata_fw_o   (regfile_alu_wdata_fw),\n\n      // stall control\n      .is_decoding_i (is_decoding),\n      .lsu_ready_ex_i(lsu_ready_ex),\n      .lsu_err_i     (data_err_pmp),\n\n      .ex_ready_o(ex_ready),\n      .ex_valid_o(ex_valid),\n      .wb_ready_i(lsu_ready_wb)\n  );\n\n\n  ////////////////////////////////////////////////////////////////////////////////////////\n  //    _     ___    _    ____    ____ _____ ___  ____  _____   _   _ _   _ ___ _____   //\n  //   | |   / _ \\  / \\  |  _ \\  / ___|_   _/ _ \\|  _ \\| ____| | | | | \\ | |_ _|_   _|  //\n  //   | |  | | | |/ _ \\ | | | | \\___ \\ | || | | | |_) |  _|   | | | |  \\| || |  | |    //\n  //   | |__| |_| / ___ \\| |_| |  ___) || || |_| |  _ <| |___  | |_| | |\\  || |  | |    //\n  //   |_____\\___/_/   \\_\\____/  |____/ |_| \\___/|_| \\_\\_____|  \\___/|_| \\_|___| |_|    //\n  //                                                                                    //\n  ////////////////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_load_store_unit #(\n      .PULP_OBI(PULP_OBI)\n  ) load_store_unit_i (\n      .clk  (clk),\n      .rst_n(rst_ni),\n\n      //output to data memory\n      .data_req_o    (data_req_pmp),\n      .data_gnt_i    (data_gnt_pmp),\n      .data_rvalid_i (data_rvalid_i),\n      .data_err_i    (1'b0),  // Bus error (not used yet)\n      .data_err_pmp_i(data_err_pmp),  // PMP error\n\n      .data_addr_o (data_addr_pmp),\n      .data_we_o   (data_we_o),\n      .data_atop_o (data_atop_o),\n      .data_be_o   (data_be_o),\n      .data_wdata_o(data_wdata_o),\n      .data_rdata_i(data_rdata_i),\n\n      // signal from ex stage\n      .data_we_ex_i        (data_we_ex),\n      .data_atop_ex_i      (data_atop_ex),\n      .data_type_ex_i      (data_type_ex),\n      .data_wdata_ex_i     (alu_operand_c_ex),\n      .data_reg_offset_ex_i(data_reg_offset_ex),\n      .data_load_event_ex_i(data_load_event_ex),\n      .data_sign_ext_ex_i  (data_sign_ext_ex),  // sign extension\n\n      .data_rdata_ex_o  (lsu_rdata),\n      .data_req_ex_i    (data_req_ex),\n      .operand_a_ex_i   (alu_operand_a_ex),\n      .operand_b_ex_i   (alu_operand_b_ex),\n      .addr_useincr_ex_i(useincr_addr_ex),\n\n      .data_misaligned_ex_i(data_misaligned_ex),  // from ID/EX pipeline\n      .data_misaligned_o   (data_misaligned),\n\n      .p_elw_start_o (p_elw_start),\n      .p_elw_finish_o(p_elw_finish),\n\n      // control signals\n      .lsu_ready_ex_o(lsu_ready_ex),\n      .lsu_ready_wb_o(lsu_ready_wb),\n\n      .busy_o(lsu_busy)\n  );\n\n  // Tracer signal\n  assign wb_valid = lsu_ready_wb;\n\n\n  //////////////////////////////////////\n  //        ____ ____  ____           //\n  //       / ___/ ___||  _ \\ ___      //\n  //      | |   \\___ \\| |_) / __|     //\n  //      | |___ ___) |  _ <\\__ \\     //\n  //       \\____|____/|_| \\_\\___/     //\n  //                                  //\n  //   Control and Status Registers   //\n  //////////////////////////////////////\n\n  cv32e40p_cs_registers #(\n      .N_HWLP          (N_HWLP),\n      .A_EXTENSION     (A_EXTENSION),\n      .FPU             (FPU),\n      .ZFINX           (ZFINX),\n      .APU             (APU),\n      .PULP_SECURE     (PULP_SECURE),\n      .USE_PMP         (USE_PMP),\n      .N_PMP_ENTRIES   (N_PMP_ENTRIES),\n      .NUM_MHPMCOUNTERS(NUM_MHPMCOUNTERS),\n      .COREV_PULP      (COREV_PULP),\n      .COREV_CLUSTER   (COREV_CLUSTER),\n      .DEBUG_TRIGGER_EN(DEBUG_TRIGGER_EN)\n  ) cs_registers_i (\n      .clk  (clk),\n      .rst_n(rst_ni),\n\n      // Hart ID from outside\n      .hart_id_i       (hart_id_i),\n      .mtvec_o         (mtvec),\n      .utvec_o         (utvec),\n      .mtvec_mode_o    (mtvec_mode),\n      .utvec_mode_o    (utvec_mode),\n      // mtvec address\n      .mtvec_addr_i    (mtvec_addr_i[31:0]),\n      .csr_mtvec_init_i(csr_mtvec_init),\n      // Interface to CSRs (SRAM like)\n      .csr_addr_i      (csr_addr),\n      .csr_wdata_i     (csr_wdata),\n      .csr_op_i        (csr_op),\n      .csr_rdata_o     (csr_rdata),\n\n      .fs_off_o   (fs_off),\n      .frm_o      (frm_csr),\n      .fflags_i   (fflags_csr),\n      .fflags_we_i(fflags_we),\n      .fregs_we_i (fregs_we),\n\n      // Interrupt related control signals\n      .mie_bypass_o  (mie_bypass),\n      .mip_i         (mip),\n      .m_irq_enable_o(m_irq_enable),\n      .u_irq_enable_o(u_irq_enable),\n      .csr_irq_sec_i (csr_irq_sec),\n      .sec_lvl_o     (sec_lvl_o),\n      .mepc_o        (mepc),\n      .uepc_o        (uepc),\n\n      // HPM related control signals\n      .mcounteren_o(mcounteren),\n\n      // debug\n      .debug_mode_i       (debug_mode),\n      .debug_cause_i      (debug_cause),\n      .debug_csr_save_i   (debug_csr_save),\n      .depc_o             (depc),\n      .debug_single_step_o(debug_single_step),\n      .debug_ebreakm_o    (debug_ebreakm),\n      .debug_ebreaku_o    (debug_ebreaku),\n      .trigger_match_o    (trigger_match),\n\n      .priv_lvl_o(current_priv_lvl),\n\n      .pmp_addr_o(pmp_addr),\n      .pmp_cfg_o (pmp_cfg),\n\n      .pc_if_i(pc_if),\n      .pc_id_i(pc_id),\n      .pc_ex_i(pc_ex),\n\n      .csr_save_if_i     (csr_save_if),\n      .csr_save_id_i     (csr_save_id),\n      .csr_save_ex_i     (csr_save_ex),\n      .csr_restore_mret_i(csr_restore_mret_id),\n      .csr_restore_uret_i(csr_restore_uret_id),\n\n      .csr_restore_dret_i(csr_restore_dret_id),\n\n      .csr_cause_i     (csr_cause),\n      .csr_save_cause_i(csr_save_cause),\n\n      // from hwloop registers\n      .hwlp_start_i(hwlp_start),\n      .hwlp_end_i  (hwlp_end),\n      .hwlp_cnt_i  (hwlp_cnt),\n\n      // performance counter related signals\n      .mhpmevent_minstret_i    (mhpmevent_minstret),\n      .mhpmevent_load_i        (mhpmevent_load),\n      .mhpmevent_store_i       (mhpmevent_store),\n      .mhpmevent_jump_i        (mhpmevent_jump),\n      .mhpmevent_branch_i      (mhpmevent_branch),\n      .mhpmevent_branch_taken_i(mhpmevent_branch_taken),\n      .mhpmevent_compressed_i  (mhpmevent_compressed),\n      .mhpmevent_jr_stall_i    (mhpmevent_jr_stall),\n      .mhpmevent_imiss_i       (mhpmevent_imiss),\n      .mhpmevent_ld_stall_i    (mhpmevent_ld_stall),\n      .mhpmevent_pipe_stall_i  (mhpmevent_pipe_stall),\n      .apu_typeconflict_i      (perf_apu_type),\n      .apu_contention_i        (perf_apu_cont),\n      .apu_dep_i               (perf_apu_dep),\n      .apu_wb_i                (perf_apu_wb)\n  );\n\n  //  CSR access\n  assign csr_addr = csr_addr_int;\n  assign csr_wdata = alu_operand_a_ex;\n  assign csr_op = csr_op_ex;\n\n  assign csr_addr_int = csr_num_e'(csr_access_ex ? alu_operand_b_ex[11:0] : '0);\n\n  //  Floating-Point registers write\n  assign fregs_we     = (FPU == 1 & ZFINX == 0) ? ((regfile_alu_we_fw && regfile_alu_waddr_fw[5]) ||\n                                                   (regfile_we_wb     && regfile_waddr_fw_wb_o[5]))\n                                                : 1'b0;\n\n  ///////////////////////////\n  //   ____  __  __ ____   //\n  //  |  _ \\|  \\/  |  _ \\  //\n  //  | |_) | |\\/| | |_) | //\n  //  |  __/| |  | |  __/  //\n  //  |_|   |_|  |_|_|     //\n  //                       //\n  ///////////////////////////\n\n  generate\n    if (PULP_SECURE && USE_PMP) begin : gen_pmp\n      cv32e40p_pmp #(\n          .N_PMP_ENTRIES(N_PMP_ENTRIES)\n      ) pmp_unit_i (\n          .clk  (clk),\n          .rst_n(rst_ni),\n\n          .pmp_privil_mode_i(current_priv_lvl),\n\n          .pmp_addr_i(pmp_addr),\n          .pmp_cfg_i (pmp_cfg),\n\n\n          .data_req_i (data_req_pmp),\n          .data_addr_i(data_addr_pmp),\n          .data_we_i  (data_we_o),\n          .data_gnt_o (data_gnt_pmp),\n\n          .data_req_o    (data_req_o),\n          .data_gnt_i    (data_gnt_i),\n          .data_addr_o   (data_addr_o),\n          .data_err_o    (data_err_pmp),\n          .data_err_ack_i(data_err_ack),\n\n          .instr_req_i (instr_req_pmp),\n          .instr_addr_i(instr_addr_pmp),\n          .instr_gnt_o (instr_gnt_pmp),\n\n          .instr_req_o (instr_req_o),\n          .instr_gnt_i (instr_gnt_i),\n          .instr_addr_o(instr_addr_o),\n          .instr_err_o (instr_err_pmp)\n      );\n    end else begin : gen_no_pmp\n      assign instr_req_o   = instr_req_pmp;\n      assign instr_addr_o  = instr_addr_pmp;\n      assign instr_gnt_pmp = instr_gnt_i;\n      assign instr_err_pmp = 1'b0;\n\n      assign data_req_o    = data_req_pmp;\n      assign data_addr_o   = data_addr_pmp;\n      assign data_gnt_pmp  = data_gnt_i;\n      assign data_err_pmp  = 1'b0;\n    end\n  endgenerate\n\n`ifdef CV32E40P_ASSERT_ON\n\n  //----------------------------------------------------------------------------\n  // Assumptions\n  //----------------------------------------------------------------------------\n\n  generate\n    if (COREV_CLUSTER) begin : gen_pulp_cluster_assumptions\n\n      // Assumptions/requirements on the environment when pulp_clock_en_i = 0\n      property p_env_req_0;\n        @(posedge clk_i) disable iff (!rst_ni) (pulp_clock_en_i == 1'b0) |-> (irq_i == 'b0) && (debug_req_i == 1'b0) &&\n                                                                            (instr_rvalid_i == 1'b0) && (instr_gnt_i == 1'b0) &&\n                                                                            (data_rvalid_i == 1'b0) && (data_gnt_i == 1'b0);\n      endproperty\n\n      a_env_req_0 :\n      assume property (p_env_req_0);\n\n      // Assumptions/requirements on the environment when core_sleep_o = 0\n      property p_env_req_1;\n        @(posedge clk_i) disable iff (!rst_ni) (core_sleep_o == 1'b0) |-> (pulp_clock_en_i == 1'b1);\n      endproperty\n\n      a_env_req_1 :\n      assume property (p_env_req_1);\n\n    end\n  endgenerate\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n  generate\n    if (!COREV_CLUSTER) begin : gen_no_pulp_cluster_assertions\n      // Check that a taken IRQ is actually enabled (e.g. that we do not react to an IRQ that was just disabled in MIE)\n      property p_irq_enabled_0;\n        @(posedge clk) disable iff (!rst_ni) (pc_set && (pc_mux_id == PC_EXCEPTION) && (exc_pc_mux_id == EXC_PC_IRQ)) |->\n         (cs_registers_i.mie_n[exc_cause] && cs_registers_i.mstatus_q.mie);\n      endproperty\n\n      a_irq_enabled_0 :\n      assert property (p_irq_enabled_0);\n\n      // Check that a taken IRQ was for an enabled cause and that mstatus.mie gets disabled\n      property p_irq_enabled_1;\n        @(posedge clk) disable iff (!rst_ni) (pc_set && (pc_mux_id == PC_EXCEPTION) && (exc_pc_mux_id == EXC_PC_IRQ)) |=>\n         (cs_registers_i.mcause_q[5] && cs_registers_i.mie_q[cs_registers_i.mcause_q[4:0]] && !cs_registers_i.mstatus_q.mie);\n      endproperty\n\n      a_irq_enabled_1 :\n      assert property (p_irq_enabled_1);\n    end\n  endgenerate\n\n  generate\n    if (!COREV_PULP) begin : gen_no_pulp_xpulp_assertions\n\n      // Illegal, ECALL, EBRK checks excluded for PULP due to other definition for for Hardware Loop\n\n      // First illegal instruction decoded\n      logic        first_illegal_found;\n      logic        first_ecall_found;\n      logic        first_ebrk_found;\n      logic [31:0] expected_illegal_mepc;\n      logic [31:0] expected_ecall_mepc;\n      logic [31:0] expected_ebrk_mepc;\n\n      always_ff @(posedge clk, negedge rst_ni) begin\n        if (rst_ni == 1'b0) begin\n          first_illegal_found   <= 1'b0;\n          first_ecall_found     <= 1'b0;\n          first_ebrk_found      <= 1'b0;\n          expected_illegal_mepc <= 32'b0;\n          expected_ecall_mepc   <= 32'b0;\n          expected_ebrk_mepc    <= 32'b0;\n        end else begin\n          if (!first_illegal_found && is_decoding && id_valid && id_stage_i.illegal_insn_dec && !id_stage_i.controller_i.debug_mode_n) begin\n            first_illegal_found   <= 1'b1;\n            expected_illegal_mepc <= pc_id;\n          end\n          if (!first_ecall_found && is_decoding && id_valid && id_stage_i.ecall_insn_dec && !id_stage_i.controller_i.debug_mode_n) begin\n            first_ecall_found   <= 1'b1;\n            expected_ecall_mepc <= pc_id;\n          end\n          if (!first_ebrk_found && is_decoding && id_valid && id_stage_i.ebrk_insn_dec && (id_stage_i.controller_i.ctrl_fsm_ns != DBG_FLUSH)) begin\n            first_ebrk_found   <= 1'b1;\n            expected_ebrk_mepc <= pc_id;\n          end\n        end\n      end\n\n      // First mepc write for illegal instruction exception\n      logic        first_cause_illegal_found;\n      logic        first_cause_ecall_found;\n      logic        first_cause_ebrk_found;\n      logic [31:0] actual_illegal_mepc;\n      logic [31:0] actual_ecall_mepc;\n      logic [31:0] actual_ebrk_mepc;\n\n      always_ff @(posedge clk, negedge rst_ni) begin\n        if (rst_ni == 1'b0) begin\n          first_cause_illegal_found <= 1'b0;\n          first_cause_ecall_found   <= 1'b0;\n          first_cause_ebrk_found    <= 1'b0;\n          actual_illegal_mepc       <= 32'b0;\n          actual_ecall_mepc         <= 32'b0;\n          actual_ebrk_mepc          <= 32'b0;\n        end else begin\n          if (!first_cause_illegal_found && (cs_registers_i.csr_cause_i == {\n                1'b0, EXC_CAUSE_ILLEGAL_INSN\n              }) && csr_save_cause) begin\n            first_cause_illegal_found <= 1'b1;\n            actual_illegal_mepc       <= cs_registers_i.mepc_n;\n          end\n          if (!first_cause_ecall_found && (cs_registers_i.csr_cause_i == {\n                1'b0, EXC_CAUSE_ECALL_MMODE\n              }) && csr_save_cause) begin\n            first_cause_ecall_found <= 1'b1;\n            actual_ecall_mepc       <= cs_registers_i.mepc_n;\n          end\n          if (!first_cause_ebrk_found && (cs_registers_i.csr_cause_i == {\n                1'b0, EXC_CAUSE_BREAKPOINT\n              }) && csr_save_cause) begin\n            first_cause_ebrk_found <= 1'b1;\n            actual_ebrk_mepc       <= cs_registers_i.mepc_n;\n          end\n        end\n      end\n\n      // Check that mepc is updated with PC of illegal instruction\n      property p_illegal_mepc;\n        @(posedge clk) disable iff (!rst_ni) (first_illegal_found && first_cause_illegal_found) |=> (expected_illegal_mepc == actual_illegal_mepc);\n      endproperty\n\n      a_illegal_mepc :\n      assert property (p_illegal_mepc);\n\n      // Check that mepc is updated with PC of the ECALL instruction\n      property p_ecall_mepc;\n        @(posedge clk) disable iff (!rst_ni) (first_ecall_found && first_cause_ecall_found) |=> (expected_ecall_mepc == actual_ecall_mepc);\n      endproperty\n\n      a_ecall_mepc :\n      assert property (p_ecall_mepc);\n\n      // Check that mepc is updated with PC of EBRK instruction\n      property p_ebrk_mepc;\n        @(posedge clk) disable iff (!rst_ni) (first_ebrk_found && first_cause_ebrk_found) |=> (expected_ebrk_mepc == actual_ebrk_mepc);\n      endproperty\n\n      a_ebrk_mepc :\n      assert property (p_ebrk_mepc);\n\n    end\n  endgenerate\n\n  // Single Step only decodes one instruction in non debug mode and next instruction decode is in debug mode\n  logic inst_taken;\n  assign inst_taken = id_valid && is_decoding;\n\n  a_single_step :\n  assert property\n  (\n    @(posedge clk) disable iff (!rst_ni)\n    (inst_taken && debug_single_step && ~debug_mode)\n    ##1 inst_taken [->1]\n    |-> (debug_mode && debug_single_step));\n\n`endif\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);