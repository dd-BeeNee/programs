var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/tb/uvmt/uvmt_cv32e40p_dut_wrap.sv","src":"//\n// Copyright 2020 OpenHW Group\n// Copyright 2020 Datum Technology Corporation\n// Copyright 2020 Silicon Labs, Inc.\n// \n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n//     https://solderpad.org/licenses/\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n///////////////////////////////////////////////////////////////////////////////\n//\n// Modified version of the wrapper for a RI5CY testbench, containing RI5CY,\n// plus Memory and stdout virtual peripherals.\n// Contributor: Robert Balas <balasr@student.ethz.ch>\n// Copyright 2018 Robert Balas <balasr@student.ethz.ch>\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n\n\n`ifndef __UVMT_CV32E40P_DUT_WRAP_SV__\n`define __UVMT_CV32E40P_DUT_WRAP_SV__\n\n\n/**\n * Module wrapper for CV32E40P RTL DUT.\n */\nmodule uvmt_cv32e40p_dut_wrap \n  #(\n                            // CV32E40P parameters.  See User Manual.\n                            parameter COREV_PULP          =  0,\n                                      COREV_CLUSTER       =  0,\n                                      FPU                 =  0,\n                                      FPU_ADDMUL_LAT      =  0,\n                                      FPU_OTHERS_LAT      =  0,\n                                      ZFINX               =  0,\n                                      NUM_MHPMCOUNTERS    =  1,\n                            // Remaining parameters are used by TB components only\n                                      INSTR_ADDR_WIDTH    =  32,\n                                      INSTR_RDATA_WIDTH   =  32,\n                                      RAM_ADDR_WIDTH      =  22\n   )\n  (\n    uvma_clknrst_if              clknrst_if,\n    uvma_interrupt_if            interrupt_if,    // Interrupts sourced by both UVM Agent and Virtual Peripherals\n    //uvma_interrupt_if            agt_interrupt_if,    // Interrupts sourced by UVM Agent\n    //uvma_interrupt_if            vp_interrupt_if,     // Interrupts sourced by Virtual Peripherals\n    uvme_cv32e40p_core_cntrl_if  core_cntrl_if,\n    uvmt_cv32e40p_core_status_if core_status_if,\n    uvma_obi_memory_if           obi_memory_instr_if, // Instruction fetch bus\n    uvma_obi_memory_if           obi_memory_data_if   // Load/Store bus\n  );\n\n    import uvm_pkg::*; // needed for the UVM messaging service (`uvm_info(), etc.)\n\n    // signals connecting core to memory\n    logic                         instr_req;\n    logic                         instr_gnt;\n    logic                         instr_rvalid;\n    logic [INSTR_ADDR_WIDTH-1 :0] instr_addr;\n    logic [INSTR_RDATA_WIDTH-1:0] instr_rdata;\n\n    logic                         data_req;\n    logic                         data_gnt;\n    logic                         data_rvalid;\n    logic [31:0]                  data_addr;\n    logic                         data_we;\n    logic [3:0]                   data_be;\n    logic [31:0]                  data_rdata;\n    logic [31:0]                  data_wdata;\n\n    logic [31:0]                  irq_vp;\n    logic [31:0]                  irq_agt;\n    logic [31:0]                  irq;\n    logic                         irq_ack;\n    logic [ 4:0]                  irq_id;\n\n    logic                         debug_req_vp;\n    logic                         debug_req_uvma;\n    logic                         debug_req;\n    logic                         debug_havereset;\n    logic                         debug_running;\n    logic                         debug_halted;\n\n    assign debug_if.clk      = clknrst_if.clk;\n    assign debug_if.reset_n  = clknrst_if.reset_n;\n    assign debug_req_uvma    = debug_if.debug_req;\n\n    assign debug_req = debug_req_vp | debug_req_uvma;\n\n        \n\n    // --------------------------------------------\n    // Instruction bus is read-only, OBI v1.0\n    assign obi_memory_instr_if.we        = 'b0;\n    assign obi_memory_instr_if.be        = '1;\n    // Data bus is read/write, OBI v1.0\n\n    // --------------------------------------------\n    // Connect to interrupt interfaces\n    assign interrupt_if.clk     = clknrst_if.clk;\n    assign interrupt_if.reset_n = clknrst_if.reset_n;\n    assign interrupt_if.irq_id  = irq_id;\n    assign interrupt_if.irq_ack = irq_ack;\n    //assign agt_interrupt_if.clk     = clknrst_if.clk;\n    //assign agt_interrupt_if.reset_n = clknrst_if.reset_n;\n    //assign agt_interrupt_if.irq_id  = irq_id;\n    //assign agt_interrupt_if.irq_ack = irq_ack;\n    //assign vp_interrupt_if.clk      = clknrst_if.clk;\n    //assign vp_interrupt_if.reset_n  = clknrst_if.reset_n;\n    //assign vp_interrupt_if.irq_id   = irq_id;\n    //assign vp_interrupt_if.irq_ack  = irq_ack;\n\n    //assign irq_vp  = vp_interrupt_if.irq;\n    //assign irq_agt = agt_interrupt_if.irq;\n    //always @(irq_vp)  $display(\"%m: @%0t; irq_vp  = %8x\", $time, irq_vp);\n    //always @(irq_agt) $display(\"%m: @%0t; irq_agt = %8x\", $time, irq_agt);\n\n    assign irq = interrupt_if.irq_drv;\n    always @(irq) begin\n      `uvm_info(\"uvmt_cv32e40p_dut_wrap\", $sformatf(\"irq = %8x\", irq), UVM_HIGH);\n    end\n\n    // -------------------------------------------------------------\n    // Instantiate the Core and optional FPU plus logger and tracers\n    cv32e40p_tb_wrapper #(\n                 .COREV_PULP       (COREV_PULP),\n                 .COREV_CLUSTER    (COREV_CLUSTER),\n                 .FPU              (FPU),\n                 .FPU_ADDMUL_LAT   (FPU_ADDMUL_LAT),\n                 .FPU_OTHERS_LAT   (FPU_OTHERS_LAT),\n                 .ZFINX            (ZFINX),\n                 .NUM_MHPMCOUNTERS (NUM_MHPMCOUNTERS)\n                )\n    cv32e40p_tb_wrapper_i\n        (\n         .clk_i                  ( clknrst_if.clk                 ),\n         .rst_ni                 ( clknrst_if.reset_n             ),\n\n         .pulp_clock_en_i        ( '0),//core_cntrl_if.pulp_clock_en    ),\n         .scan_cg_en_i           ( core_cntrl_if.scan_cg_en       ),\n\n         .boot_addr_i            ( core_cntrl_if.boot_addr        ),\n         .mtvec_addr_i           ( core_cntrl_if.mtvec_addr       ),\n         .dm_halt_addr_i         ( core_cntrl_if.dm_halt_addr     ),\n         .hart_id_i              ( core_cntrl_if.mhartid          ),\n         .dm_exception_addr_i    ( core_cntrl_if.dm_exception_addr),\n\n         .instr_req_o            ( obi_memory_instr_if.req        ), // core to agent\n         .instr_gnt_i            ( obi_memory_instr_if.gnt        ), // agent to core\n         .instr_rvalid_i         ( obi_memory_instr_if.rvalid     ),\n         .instr_addr_o           ( obi_memory_instr_if.addr       ),\n         .instr_rdata_i          ( obi_memory_instr_if.rdata      ),\n\n         .data_req_o             ( obi_memory_data_if.req         ),\n         .data_gnt_i             ( obi_memory_data_if.gnt         ),\n         .data_rvalid_i          ( obi_memory_data_if.rvalid      ),\n         .data_we_o              ( obi_memory_data_if.we          ),\n         .data_be_o              ( obi_memory_data_if.be          ),\n         .data_addr_o            ( obi_memory_data_if.addr        ),\n         .data_wdata_o           ( obi_memory_data_if.wdata       ),\n         .data_rdata_i           ( obi_memory_data_if.rdata       ),\n\n         .irq_i                  ( irq                            ),\n         .irq_ack_o              ( irq_ack                        ),\n         .irq_id_o               ( irq_id                         ),\n\n         .debug_req_i            ( debug_req_uvma                 ),\n         .debug_havereset_o      ( debug_havereset                ),\n         .debug_running_o        ( debug_running                  ),\n         .debug_halted_o         ( debug_halted                   ),\n\n         .fetch_enable_i         ( core_cntrl_if.fetch_en         ),\n         .core_sleep_o           ( core_status_if.core_busy       )\n        ); // cv32e40p_tb_wrapper_i\n\n\nendmodule : uvmt_cv32e40p_dut_wrap\n\n`endif // __UVMT_CV32E40P_DUT_WRAP_SV__\n\n\n","lang":"verilog"};
processSrcData(g_data);