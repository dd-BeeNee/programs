var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/tb/uvmt/uvmt_cv32e40p_interrupt_assert.sv","src":"//\n// Copyright 2020 OpenHW Group\n// Copyright 2020 Datum Technology Corporation\n// \n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n//     https://solderpad.org/licenses/\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n\nmodule uvmt_cv32e40p_interrupt_assert  \n  import uvm_pkg::*;\n  import cv32e40p_pkg::*;\n  (\n    \n    input clk,   // Gated clock\n    input clk_i, // Free-running core clock\n    input rst_ni,\n\n    // Core inputs\n    input        fetch_enable_i, // external core fetch enable\n\n    // External interrupt interface\n    input [31:0] irq_i,\n    input        irq_ack_o,\n    input [4:0]  irq_id_o,\n\n    // External debug req (for WFI modeling)\n    input        debug_req_i,\n    input        debug_mode_q,\n\n    // CSR Interface\n    input [5:0]  mcause_n, // mcause_n[5]: interrupt, mcause_n[4]: vector\n    input [31:0] mip,     // machine interrupt pending\n    input [31:0] mie_q,   // machine interrupt enable\n    input [31:0] mie_n,   // machine interrupt enable\n    input        mstatus_mie, // machine mode interrupt enable\n    input [1:0]  mtvec_mode_q, // machine mode interrupt vector mode\n\n    // Instruction fetch stage\n    input        if_stage_instr_rvalid_i, // Instruction word is valid\n    input [31:0] if_stage_instr_rdata_i, // Instruction word data\n\n    // Instruction ID stage (determines executed instructions)  \n    input        id_stage_instr_valid_i, // instruction word is valid\n    input [31:0] id_stage_instr_rdata_i, // Instruction word data\n    input [4:0]  ctrl_fsm_cs,            // Controller FSM to get hint for interrupt taken\n\n    // Determine whether to cancel instruction if branch taken\n    input branch_taken_ex,\n\n    // WFI Interface\n    input core_sleep_o\n  );\n\n  // ---------------------------------------------------------------------------\n  // Local parameters\n  // ---------------------------------------------------------------------------  \n  localparam NUM_IRQ        = 32;  \n  localparam VALID_IRQ_MASK = 32'hffff_0888; // Valid external interrupt signals\n\n  localparam WFI_INSTR_MASK = 32'hffffffff;\n  localparam WFI_INSTR_DATA = 32'h10500073;\n\n  localparam WFI_WAKEUP_LATENCY = 40;\n\n  // ---------------------------------------------------------------------------\n  // Local variables\n  // ---------------------------------------------------------------------------\n  string info_tag = \"CV32E40P_IRQ_ASSERT\";\n\n  wire [31:0] pending_enabled_irq;\n  wire [31:0] pending_enabled_irq_q;\n\n  wire id_instr_is_wfi; // ID instruction is a WFI\n  reg  in_wfi; // Local model of WFI state of core\n\n  reg[31:0] irq_q;\n\n  reg[31:0] next_irq;\n  reg       next_irq_valid;\n\n  reg[31:0] next_irq_q;    \n  reg       next_irq_valid_q;\n  reg[31:0] saved_mie_q;\n\n  reg[31:0] expected_irq;\n  logic     expected_irq_ack;\n\n  reg[31:0] last_instr_rdata;\n\n  // ---------------------------------------------------------------------------\n  // Clocking blocks\n  // ---------------------------------------------------------------------------\n\n  // Single clock, single reset design, use default clocking\n  default clocking @(posedge clk_i); endclocking\n  default disable iff !(rst_ni);\n\n  // ---------------------------------------------------------------------------\n  // Begin module code\n  // ---------------------------------------------------------------------------\n  assign pending_enabled_irq   = irq_i & mie_n;\n  assign pending_enabled_irq_q = irq_q & mie_n;\n\n  // ---------------------------------------------------------------------------\n  // Interrupt interface checks\n  // ---------------------------------------------------------------------------\n\n  // irq_ack_o is always a pulse\n  property p_irq_ack_o_pulse;\n    irq_ack_o |=> !irq_ack_o;\n  endproperty\n  a_irq_ack_o_pulse: assert property(p_irq_ack_o_pulse)\n    else\n      `uvm_error(info_tag,\n                 \"Interrupt ack was asserted for more than one cycle\");\n\n  // irq_id_o is never a reserved irq\n  property p_irq_id_o_not_reserved;\n    irq_ack_o |-> VALID_IRQ_MASK[irq_id_o];\n  endproperty    \n  a_irq_id_o_not_reserved: assert property(p_irq_id_o_not_reserved)\n    else\n      `uvm_error(info_tag,\n                 $sformatf(\"int_id_o output is 0x%0x which is reserved\", irq_id_o));\n\n  // irq_id_o is never a disabled irq\n  property p_irq_id_o_mie_enabled;\n    irq_ack_o |-> mie_n[irq_id_o];\n  endproperty    \n  a_irq_id_o_mie_enabled: assert property(p_irq_id_o_mie_enabled)\n    else\n      `uvm_error(info_tag,\n                 $sformatf(\"irq_id_o output is 0x%0x which is disabled in MIE: 0x%08x\", irq_id_o, mie_n));\n\n  // irq_ack_o cannot be asserted if mstatus_mie is deasserted\n  property p_irq_id_o_mstatus_mie_enabled;\n    irq_ack_o |-> mstatus_mie;\n  endproperty\n  a_irq_id_o_mstatus_mie_enabled: assert property(p_irq_id_o_mstatus_mie_enabled)\n    else\n      `uvm_error(info_tag,\n                 $sformatf(\"int_id_o output is 0x%0x but MSTATUS.MIE is disabled\", irq_id_o));\n  \n  // ---------------------------------------------------------------------------\n  // Interrupt CSR checks\n  // ---------------------------------------------------------------------------\n\n  // Coverage for individual interupt assertions\n  sequence s_irq_taken(irq);\n    irq_i[irq] ##0 mie_q[irq] ##0 mstatus_mie ##0 irq_ack_o ##0 irq_id_o == irq;\n  endsequence : s_irq_taken\n\n  // Interrupt fired, global interrupts enabled, but not taken due to global MSTATUS.MIE setting\n  property p_irq_masked(irq);\n    irq_i[irq] ##0 !mie_q[irq] ##0 mstatus_mie;    \n  endproperty : p_irq_masked\n\n  // Interrupt fired and locally enabled in MIE, but masked due to MSTATUS_MIE\n  property p_irq_masked_mstatus(irq);\n    irq_i[irq] ##0 mie_q[irq] ##0 !mstatus_mie;\n  endproperty : p_irq_masked_mstatus\n\n  // Interrupt taken\n  property p_irq_taken(irq);\n    s_irq_taken(irq);\n  endproperty : p_irq_taken\n\n  // Interrupt enabled via MIE locally masked\n  property p_irq_masked_then_enabled(irq);\n    irq_i[irq] ##0 !mie_q[irq] ##0 mstatus_mie ##1 irq_i[irq] ##0 mie_q[irq] ##0 mstatus_mie;\n  endproperty : p_irq_masked_then_enabled\n\n  // Interrupt enabled via MSTATUS_MIE locally masked\n  property p_irq_masked_mstatus_then_enabled(irq);\n    irq_i[irq] ##0 mie_q[irq] ##0 !mstatus_mie ##1 irq_i[irq] ##0 mie_q[irq] ##0 mstatus_mie;\n  endproperty : p_irq_masked_mstatus_then_enabled\n\n  // Interrupt request deasserted when enabled but not acked\n  property p_irq_deasserted_while_enabled_not_acked(irq);\n    irq_i[irq] ##0 mie_q[irq] ##0 mstatus_mie ##0 !irq_ack_o ##1 \n    !irq_i[irq] ##0 !irq_ack_o;\n  endproperty : p_irq_deasserted_while_enabled_not_acked  \n\n  // Interrupt taken in each supported mtvec mode\n  property p_irq_in_mtvec(irq, mtvec);\n    s_irq_taken(irq) ##0 mtvec_mode_q == mtvec;\n  endproperty\n\n  generate for(genvar gv_i = 0; gv_i < NUM_IRQ; gv_i++) begin : gen_irq_cov\n    if (VALID_IRQ_MASK[gv_i]) begin : gen_valid\n      c_irq_masked: cover property(p_irq_masked(gv_i));\n      c_irq_masked_mstatus: cover property(p_irq_masked_mstatus(gv_i));\n      c_irq_taken: cover property(p_irq_taken(gv_i));\n      c_irq_masked_then_enabled: cover property(p_irq_masked_then_enabled(gv_i));\n      c_irq_masked_mstatus_then_enabled: cover property(p_irq_masked_mstatus_then_enabled(gv_i));\n      c_irq_deasserted_while_enabled_not_acked: cover property(p_irq_deasserted_while_enabled_not_acked(gv_i));\n      c_irq_in_mtvec_fixed: cover property(p_irq_in_mtvec(gv_i, 0));\n      c_irq_in_mtvec_vector: cover property(p_irq_in_mtvec(gv_i, 1));\n    end\n  end\n  endgenerate\n\n  // Detect arbitration of interrupt assertion\n  always @* begin\n    next_irq_valid = 1'b0;\n    next_irq = '0;\n    casex ({pending_enabled_irq_q[31:16], pending_enabled_irq_q[11], pending_enabled_irq_q[3], pending_enabled_irq_q[7]})\n      19'b1???_????_????_????_???: begin next_irq = 'd31; next_irq_valid = '1; end\n      19'b01??_????_????_????_???: begin next_irq = 'd30; next_irq_valid = '1; end\n      19'b001?_????_????_????_???: begin next_irq = 'd29; next_irq_valid = '1; end\n      19'b0001_????_????_????_???: begin next_irq = 'd28; next_irq_valid = '1; end\n      19'b0000_1???_????_????_???: begin next_irq = 'd27; next_irq_valid = '1; end\n      19'b0000_01??_????_????_???: begin next_irq = 'd26; next_irq_valid = '1; end\n      19'b0000_001?_????_????_???: begin next_irq = 'd25; next_irq_valid = '1; end\n      19'b0000_0001_????_????_???: begin next_irq = 'd24; next_irq_valid = '1; end\n      19'b0000_0000_1???_????_???: begin next_irq = 'd23; next_irq_valid = '1; end\n      19'b0000_0000_01??_????_???: begin next_irq = 'd22; next_irq_valid = '1; end\n      19'b0000_0000_001?_????_???: begin next_irq = 'd21; next_irq_valid = '1; end\n      19'b0000_0000_0001_????_???: begin next_irq = 'd20; next_irq_valid = '1; end\n      19'b0000_0000_0000_1???_???: begin next_irq = 'd19; next_irq_valid = '1; end\n      19'b0000_0000_0000_01??_???: begin next_irq = 'd18; next_irq_valid = '1; end\n      19'b0000_0000_0000_001?_???: begin next_irq = 'd17; next_irq_valid = '1; end\n      19'b0000_0000_0000_0001_???: begin next_irq = 'd16; next_irq_valid = '1; end\n      19'b0000_0000_0000_0000_1??: begin next_irq = 'd11; next_irq_valid = '1; end\n      19'b0000_0000_0000_0000_01?: begin next_irq = 'd3; next_irq_valid = '1; end\n      19'b0000_0000_0000_0000_001: begin next_irq = 'd7; next_irq_valid = '1; end\n    endcase\n  end\n\n  always @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      irq_q <= 0;\n      next_irq_q <= 0;\n      next_irq_valid_q <= 0;\n      saved_mie_q <= 0;\n    end    \n    else begin\n      irq_q <= irq_i;\n      next_irq_q <= next_irq;\n      next_irq_valid_q <= next_irq_valid;\n      saved_mie_q <= mie_q;\n    end\n  end\n\n  always @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni)\n      expected_irq <= 0;\n    else\n      expected_irq <= next_irq_q;\n  end\n\n  assign expected_irq_ack = next_irq_valid & mstatus_mie;\n\n  // Check expected interrupt wins\n  property p_irq_arb;\n    irq_ack_o |-> irq_id_o == next_irq;\n  endproperty\n  a_irq_arb: assert property(p_irq_arb)\n    else\n      `uvm_error(info_tag,\n                 $sformatf(\"Expected winning interrupt: %0d, actual interrupt: %0d\", next_irq, irq_id_o))  \n\n  // Check that an interrupt is expected\n  property p_irq_expected;\n    irq_ack_o |-> expected_irq_ack;\n  endproperty\n  a_irq_expected: assert property(p_irq_expected)\n    else\n      `uvm_error(info_tag,\n                 $sformatf(\"Did not expect interrupt ack: %0d\", irq_id_o))\n\n  // ---------------------------------------------------------------------------\n  // The infamous \"first\" flag (kludge for $past() handling of t=0 values)\n  // Would like to use a leading ##1 in the property instead but this currently\n  // does not work with dsim\n  // ---------------------------------------------------------------------------\n  reg first;\n  always @(posedge clk or negedge rst_ni)\n    if (!rst_ni)\n      first <= 1'b1;\n    else\n      first <= 1'b0;\n\n  // mip reflects flopped interrupt inputs (irq_i) regardless of other configuration\n  // Note that this runs on the gated clock\n  property p_mip_irq_i;\n    @(posedge clk)\n      !first |-> mip == ($past(irq_i) & VALID_IRQ_MASK);\n  endproperty\n  a_mip_irq_i: assert property(p_mip_irq_i)\n    else \n      `uvm_error(info_tag,\n                 $sformatf(\"MIP of 0x%08x does not follow flopped irq_i input: 0x%08x\", mip, $past(irq_i)));\n\n  // mip should not be reserved\n  property p_mip_not_reserved;\n    (mip & ~VALID_IRQ_MASK) == 0;\n  endproperty\n  a_mip_not_reserved: assert property(p_mip_not_reserved)\n    else\n      `uvm_error(info_tag,\n                 $sformatf(\"MIP of reserved interrupt is asserted: mip = 0x%08x\", mip));\n\n  // ---------------------------------------------------------------------------\n  // Instruction coverage when taking an interrupt\n  // ---------------------------------------------------------------------------\n  always @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      last_instr_rdata <= '0;\n    end\n    else if (id_stage_instr_valid_i) begin\n      last_instr_rdata <= id_stage_instr_rdata_i;\n    end\n  end\n\n  // ---------------------------------------------------------------------------\n  // WFI Checks\n  // ---------------------------------------------------------------------------\n  assign is_wfi = id_stage_instr_valid_i && \n                  ((id_stage_instr_rdata_i & WFI_INSTR_MASK) == WFI_INSTR_DATA) &&\n                  !branch_taken_ex;\n  always @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      in_wfi <= 1'b0;\n    end\n    else begin\n      if (is_wfi) \n        in_wfi <= 1'b1;\n      else if (|pending_enabled_irq || debug_req_i)\n        in_wfi <= 1'b0;\n    end\n  end\n\n  // WFI assertion will assert core_sleep_o in 6 clocks\n  property p_wfi_assert_core_sleep_o;\n    !pending_enabled_irq_q ##0 !in_wfi ##1 !pending_enabled_irq_q ##0\n      ((!pending_enabled_irq && !debug_mode_q && !debug_req_i) throughout in_wfi[*40]) \n             |-> core_sleep_o;\n  endproperty\n  a_wfi_assert_core_sleep_o: assert property(p_wfi_assert_core_sleep_o)\n    else\n      `uvm_error(info_tag,\n                 \"Assertion of core_sleep_o did not occur within 6 clocks\")\n\n  // core_sleep_o deassertion in wfi should be followed by WFI deassertion\n  property p_core_sleep_deassert;\n    $fell(core_sleep_o) ##0 in_wfi |-> ##1 !in_wfi;\n  endproperty\n  a_core_sleep_deassert: assert property(p_core_sleep_deassert)\n    else\n      `uvm_error(info_tag,\n                 \"Deassertion of core_sleep_o in WFI not followed by WFI wakeup\");\n  \n  // When WFI deasserts the core should be awake\n  property p_wfi_deassert_core_sleep_o;\n    core_sleep_o ##1 pending_enabled_irq |-> !core_sleep_o;\n  endproperty\n  a_wfi_deassert_core_sleep_o: assert property(p_wfi_deassert_core_sleep_o) \n    else\n      `uvm_error(info_tag,\n                 \"Deassertion of WFI occurred and core is still asleep\");\n\n  // WFI wakeup to next instruction fetch\n  property p_wfi_wake_to_instr_fetch;\n    disable iff (!rst_ni || !fetch_enable_i || debug_mode_q)\n      core_sleep_o ##0 in_wfi ##1 !in_wfi[->1] |-> ##[1:WFI_WAKEUP_LATENCY] if_stage_instr_rvalid_i;\n  endproperty\n  a_wfi_wake_to_instr_fetch: assert property(p_wfi_wake_to_instr_fetch)\n    else\n      `uvm_error(info_tag,\n                 $sformatf(\"Core did not start fetching %0d cycles after WFI completed\", WFI_WAKEUP_LATENCY));\n\n  // Cover property, detect sleep deassertion due to asserted and non-asserted interrupts\n  property p_wfi_wake_mstatus_mie(irq, mie);\n    $fell(in_wfi) ##0 irq_i[irq] ##0 mie_q[irq] ##0 mstatus_mie == mie;\n  endproperty \n  generate for(genvar gv_i = 0; gv_i < 32; gv_i++) begin : gen_wfi_cov\n    if (VALID_IRQ_MASK[gv_i]) begin\n      c_wfi_wake_mstatus_mie_0: cover property(p_wfi_wake_mstatus_mie(gv_i, 0));\n      c_wfi_wake_mstatus_mie_1: cover property(p_wfi_wake_mstatus_mie(gv_i, 1));\n    end\n  end\n  endgenerate\n\nendmodule : uvmt_cv32e40p_interrupt_assert\n","lang":"verilog"};
processSrcData(g_data);