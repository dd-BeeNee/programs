var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/vendor/opene906/E906_RTL_FACTORY/gen_rtl/fdsu/rtl/pa_fdsu_prepare.v","src":"/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// &ModuleBeg; @23\nmodule pa_fdsu_prepare(\n  dp_xx_ex1_rm,\n  ex1_div,\n  ex1_divisor,\n  ex1_expnt_adder_op0,\n  ex1_expnt_adder_op1,\n  ex1_of_result_lfn,\n  ex1_op0_id,\n  ex1_op0_sign,\n  ex1_op1_id,\n  ex1_op1_id_vld,\n  ex1_op1_sel,\n  ex1_oper_id_expnt,\n  ex1_oper_id_expnt_f,\n  ex1_oper_id_frac,\n  ex1_oper_id_frac_f,\n  ex1_remainder,\n  ex1_result_sign,\n  ex1_rm,\n  ex1_sqrt,\n  fdsu_ex1_sel,\n  idu_fpu_ex1_func,\n  idu_fpu_ex1_srcf0,\n  idu_fpu_ex1_srcf1\n);\n\n// &Ports; @24\ninput   [2 :0]  dp_xx_ex1_rm;            \ninput           ex1_op0_id;              \ninput           ex1_op1_id;              \ninput           ex1_op1_sel;             \ninput   [12:0]  ex1_oper_id_expnt_f;     \ninput   [51:0]  ex1_oper_id_frac_f;      \ninput           fdsu_ex1_sel;            \ninput   [9 :0]  idu_fpu_ex1_func;        \ninput   [31:0]  idu_fpu_ex1_srcf0;       \ninput   [31:0]  idu_fpu_ex1_srcf1;       \noutput          ex1_div;                 \noutput  [23:0]  ex1_divisor;             \noutput  [12:0]  ex1_expnt_adder_op0;     \noutput  [12:0]  ex1_expnt_adder_op1;     \noutput          ex1_of_result_lfn;       \noutput          ex1_op0_sign;            \noutput          ex1_op1_id_vld;          \noutput  [12:0]  ex1_oper_id_expnt;       \noutput  [51:0]  ex1_oper_id_frac;        \noutput  [31:0]  ex1_remainder;           \noutput          ex1_result_sign;         \noutput  [2 :0]  ex1_rm;                  \noutput          ex1_sqrt;                \n\n// &Regs; @25\nreg     [12:0]  ex1_expnt_adder_op1;     \nreg             ex1_of_result_lfn;       \n\n// &Wires; @26\nwire            div_sign;                \nwire    [2 :0]  dp_xx_ex1_rm;            \nwire            ex1_div;                 \nwire    [52:0]  ex1_div_noid_nor_srt_op0; \nwire    [52:0]  ex1_div_noid_nor_srt_op1; \nwire    [52:0]  ex1_div_nor_srt_op0;     \nwire    [52:0]  ex1_div_nor_srt_op1;     \nwire    [12:0]  ex1_div_op0_expnt;       \nwire    [12:0]  ex1_div_op1_expnt;       \nwire    [52:0]  ex1_div_srt_op0;         \nwire    [52:0]  ex1_div_srt_op1;         \nwire    [23:0]  ex1_divisor;             \nwire            ex1_double;              \nwire    [12:0]  ex1_expnt_adder_op0;     \nwire            ex1_op0_id;              \nwire            ex1_op0_id_nor;          \nwire            ex1_op0_sign;            \nwire            ex1_op1_id;              \nwire            ex1_op1_id_nor;          \nwire            ex1_op1_id_vld;          \nwire            ex1_op1_sel;             \nwire            ex1_op1_sign;            \nwire    [63:0]  ex1_oper0;               \nwire    [51:0]  ex1_oper0_frac;          \nwire    [12:0]  ex1_oper0_id_expnt;      \nwire    [51:0]  ex1_oper0_id_frac;       \nwire    [63:0]  ex1_oper1;               \nwire    [51:0]  ex1_oper1_frac;          \nwire    [12:0]  ex1_oper1_id_expnt;      \nwire    [51:0]  ex1_oper1_id_frac;       \nwire    [51:0]  ex1_oper_frac;           \nwire    [12:0]  ex1_oper_id_expnt;       \nwire    [12:0]  ex1_oper_id_expnt_f;     \nwire    [51:0]  ex1_oper_id_frac;        \nwire    [51:0]  ex1_oper_id_frac_f;      \nwire    [31:0]  ex1_remainder;           \nwire            ex1_result_sign;         \nwire    [2 :0]  ex1_rm;                  \nwire            ex1_single;              \nwire            ex1_sqrt;                \nwire            ex1_sqrt_expnt_odd;      \nwire            ex1_sqrt_op0_expnt_0;    \nwire    [12:0]  ex1_sqrt_op1_expnt;      \nwire    [52:0]  ex1_sqrt_srt_op0;        \nwire            fdsu_ex1_sel;            \nwire    [9 :0]  idu_fpu_ex1_func;        \nwire    [31:0]  idu_fpu_ex1_srcf0;       \nwire    [31:0]  idu_fpu_ex1_srcf1;       \nwire    [59:0]  sqrt_remainder;          \nwire            sqrt_sign;               \n\n\nassign ex1_sqrt                    = idu_fpu_ex1_func[0];\nassign ex1_div                     = idu_fpu_ex1_func[1];\nassign ex1_oper0[63:0]             = {32'b0, idu_fpu_ex1_srcf0[31:0] & {32{fdsu_ex1_sel}}};\nassign ex1_oper1[63:0]             = {32'b0, idu_fpu_ex1_srcf1[31:0] & {32{fdsu_ex1_sel}}};\nassign ex1_double                  = 1'b0;\nassign ex1_single                  = 1'b1;\n// &Force(\"bus\", \"idu_fpu_ex1_func\", 9, 0); @43\nassign ex1_op0_id_nor              = ex1_op0_id;\nassign ex1_op1_id_nor              = ex1_op1_id;\n\n//Sign bit prepare\nassign ex1_op0_sign                = ex1_double && ex1_oper0[63]\n                                  || ex1_single && ex1_oper0[31];\nassign ex1_op1_sign                = ex1_double && ex1_oper1[63]\n                                  || ex1_single && ex1_oper1[31];\nassign div_sign                    = ex1_op0_sign ^ ex1_op1_sign;\nassign sqrt_sign                   = ex1_op0_sign;\nassign ex1_result_sign             = (ex1_div)\n                                   ? div_sign\n                                   : sqrt_sign;\n\n//=====================find first one=======================\n// this is for the denormal number\nassign ex1_oper_frac[51:0] = ex1_op1_sel ? ex1_oper1_frac[51:0]\n                                         : ex1_oper0_frac[51:0];\n\n// &Instance(\"pa_fdsu_ff1\", \"x_frac_expnt\"); @63\npa_fdsu_ff1  x_frac_expnt (\n  .fanc_shift_num          (ex1_oper_id_frac[51:0] ),\n  .frac_bin_val            (ex1_oper_id_expnt[12:0]),\n  .frac_num                (ex1_oper_frac[51:0]    )\n);\n\n// &Connect(.frac_num(ex1_oper_frac[51:0])); @64\n// &Connect(.frac_bin_val(ex1_oper_id_expnt[12:0])); @65\n// &Connect(.fanc_shift_num(ex1_oper_id_frac[51:0])); @66\n// &Force(\"output\", \"ex1_oper_id_expnt\"); &Force(\"bus\", \"ex1_oper_id_expnt\", 12, 0); @67\n// &Force(\"output\", \"ex1_oper_id_frac\"); &Force(\"bus\", \"ex1_oper_id_frac\", 51, 0); @68\n\nassign ex1_oper0_id_expnt[12:0] = ex1_op1_sel ? ex1_oper_id_expnt_f[12:0]\n                                              : ex1_oper_id_expnt[12:0];\nassign ex1_oper0_id_frac[51:0]  = ex1_op1_sel ? ex1_oper_id_frac_f[51:0]\n                                              : ex1_oper_id_frac[51:0];\nassign ex1_oper1_id_expnt[12:0] = ex1_oper_id_expnt[12:0];\nassign ex1_oper1_id_frac[51:0]  = ex1_oper_id_frac[51:0];\n\nassign ex1_oper0_frac[51:0] = {52{ex1_double}} & ex1_oper0[51:0]\n                            | {52{ex1_single}} & {ex1_oper0[22:0],29'b0};\nassign ex1_oper1_frac[51:0] = {52{ex1_double}} & ex1_oper1[51:0]\n                            | {52{ex1_single}} & {ex1_oper1[22:0],29'b0};\n\n//=====================exponent add=========================\n//exponent number 0\nassign ex1_div_op0_expnt[12:0]     = {13{ex1_double}} & {2'b0,ex1_oper0[62:52]}\n                                   | {13{ex1_single}} & {5'b0,ex1_oper0[30:23]};\nassign ex1_expnt_adder_op0[12:0]   = ex1_op0_id_nor ? ex1_oper0_id_expnt[12:0]\n                                                : ex1_div_op0_expnt[12:0];\n//exponent number 1\nassign ex1_div_op1_expnt[12:0]  = {13{ex1_double}} & {2'b0,ex1_oper1[62:52]}\n                                | {13{ex1_single}} & {5'b0,ex1_oper1[30:23]};\nassign ex1_sqrt_op1_expnt[12:0] = {13{ex1_double}} & {3'b0,{10{1'b1}}} //'d1023\n                                | {13{ex1_single}} & {6'b0,{7{1'b1}}}; //'d127\n// &CombBeg; @93\nalways @( ex1_oper1_id_expnt[12:0]\n       or ex1_div\n       or ex1_op1_id_nor\n       or ex1_sqrt_op1_expnt[12:0]\n       or ex1_sqrt\n       or ex1_div_op1_expnt[12:0])\nbegin\ncase({ex1_div,ex1_sqrt})\n  2'b10:   ex1_expnt_adder_op1[12:0] = ex1_op1_id_nor ? ex1_oper1_id_expnt[12:0]\n                                                  : ex1_div_op1_expnt[12:0];\n  2'b01:   ex1_expnt_adder_op1[12:0] = ex1_sqrt_op1_expnt[12:0];\n  default: ex1_expnt_adder_op1[12:0] = 13'b0;\nendcase\n// &CombEnd; @100\nend\n\n//ex1_sqrt_expnt_odd\n//fraction will shift left by 1\n// adder_op0/1 timing is bad.\n// assign ex1_sqrt_expnt_odd          = ex1_expnt_adder_op0[0] ^ ex1_expnt_adder_op1[0];\n\n// sqrt_odd is only used when is sqrt.\nassign ex1_sqrt_op0_expnt_0        = ex1_op0_id_nor ? ex1_oper_id_expnt[0]\n                                                    : ex1_div_op0_expnt[0];\n// ex1_expnt_adder_op1 is always 1'b1, so adder_op0[0] should be 0.\nassign ex1_sqrt_expnt_odd          = !ex1_sqrt_op0_expnt_0;\n\nassign ex1_rm[2:0]       = dp_xx_ex1_rm[2:0];\n//RNE : Always inc 1 because round to nearest of 1.111...11\n//RTZ : Always not inc 1\n//RUP : Always not inc 1 when posetive\n//RDN : Always not inc 1 when negative\n//RMM : Always inc 1 because round to max magnitude\n// &CombBeg; @119\nalways @( ex1_rm[2:0]\n       or ex1_result_sign)\nbegin\ncase(ex1_rm[2:0])\n  3'b000  : ex1_of_result_lfn = 1'b0;\n  3'b001  : ex1_of_result_lfn = 1'b1;\n  3'b010  : ex1_of_result_lfn = !ex1_result_sign;\n  3'b011  : ex1_of_result_lfn = ex1_result_sign;\n  3'b100  : ex1_of_result_lfn = 1'b0;\n  default: ex1_of_result_lfn = 1'b0;\nendcase\n// &CombEnd; @128\nend\n\n//EX1 Remainder\n//div  : 1/8  <= x < 1/4\n//sqrt : 1/16 <= x < 1/4\nassign ex1_remainder[31:0] = {32{ex1_div }} & {5'b0,ex1_div_srt_op0[52:28],2'b0} |\n                             {32{ex1_sqrt}} & sqrt_remainder[59:28];\n\n//EX1 Divisor\n//1/2 <= y < 1\nassign ex1_divisor[23:0]   = ex1_div_srt_op1[52:29];\n\n//ex1_div_srt_op0\nassign ex1_div_srt_op0[52:0]     = ex1_div_nor_srt_op0[52:0];\n//ex1_div_srt_op1\nassign ex1_div_srt_op1[52:0]     =  ex1_div_nor_srt_op1[52:0];\n//ex1_div_nor_srt_op0\nassign ex1_div_noid_nor_srt_op0[52:0] = {53{ex1_double}} & {1'b1,ex1_oper0[51:0]}\n                                      | {53{ex1_single}} & {1'b1,ex1_oper0[22:0],29'b0};\nassign ex1_div_nor_srt_op0[52:0] = ex1_op0_id_nor ? {ex1_oper0_id_frac[51:0],1'b0}\n                                                  : ex1_div_noid_nor_srt_op0[52:0];\n//ex1_div_nor_srt_op1\nassign ex1_div_noid_nor_srt_op1[52:0] = {53{ex1_double}} & {1'b1,ex1_oper1[51:0]}\n                                      | {53{ex1_single}} & {1'b1,ex1_oper1[22:0],29'b0};\nassign ex1_div_nor_srt_op1[52:0] = ex1_op1_id_nor ? {ex1_oper1_id_frac[51:0],1'b0}\n                                                  : ex1_div_noid_nor_srt_op1[52:0];\n//sqrt_remainder\nassign sqrt_remainder[59:0]      = (ex1_sqrt_expnt_odd)\n                                 ? {5'b0,ex1_sqrt_srt_op0[52:0],2'b0}\n                                 : {6'b0,ex1_sqrt_srt_op0[52:0],1'b0};\n//ex1_sqrt_srt_op0\nassign ex1_sqrt_srt_op0[52:0]    = ex1_div_srt_op0[52:0];\n\n//========================Pipe to EX2=======================\n//exponent register cal result\n// &Force(\"output\", \"ex1_expnt_adder_op0\"); &Force(\"bus\", \"ex1_expnt_adder_op0\", 12, 0); @173\n// &Force(\"output\", \"ex1_expnt_adder_op1\"); &Force(\"bus\", \"ex1_expnt_adder_op1\", 12, 0); @174\n// &Force(\"output\", \"ex1_double\"); @175\n// &Force(\"output\", \"ex1_expnt_adder_op0\"); &Force(\"bus\", \"ex1_expnt_adder_op0\", 12, 0); @177\n// &Force(\"output\", \"ex1_expnt_adder_op1\"); &Force(\"bus\", \"ex1_expnt_adder_op1\", 12, 0); @178\n// &Force(\"output\", \"ex1_result_sign\"); @180\n// &Force(\"output\", \"ex1_div\"); @181\n// &Force(\"output\", \"ex1_sqrt\"); @182\n// &Force(\"output\", \"ex1_rm\"); &Force(\"bus\", \"ex1_rm\", 2, 0); @183\n// &Force(\"output\", \"ex1_op0_sign\"); @184\n\nassign ex1_op1_id_vld = ex1_op1_id_nor && ex1_div;\n\n// &ModuleEnd; @188\nendmodule\n\n\n\n","lang":"verilog"};
processSrcData(g_data);