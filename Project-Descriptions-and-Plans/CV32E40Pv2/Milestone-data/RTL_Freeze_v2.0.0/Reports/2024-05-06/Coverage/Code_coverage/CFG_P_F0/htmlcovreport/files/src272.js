var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/vendor/opene906/E906_RTL_FACTORY/gen_rtl/fdsu/rtl/pa_fdsu_srt_single.v","src":"/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// &ModuleBeg; @23\nmodule pa_fdsu_srt_single(\n  cp0_fpu_icg_en,\n  cp0_yy_clk_en,\n  ex1_divisor,\n  ex1_expnt_adder_op1,\n  ex1_oper_id_frac,\n  ex1_oper_id_frac_f,\n  ex1_pipedown,\n  ex1_pipedown_gate,\n  ex1_remainder,\n  ex1_save_op0,\n  ex1_save_op0_gate,\n  ex2_expnt_adder_op0,\n  ex2_of,\n  ex2_pipe_clk,\n  ex2_pipedown,\n  ex2_potnt_of,\n  ex2_potnt_uf,\n  ex2_result_inf,\n  ex2_result_lfn,\n  ex2_rslt_denorm,\n  ex2_srt_expnt_rst,\n  ex2_srt_first_round,\n  ex2_uf,\n  ex2_uf_srt_skip,\n  ex3_frac_final_rst,\n  ex3_pipedown,\n  fdsu_ex3_id_srt_skip,\n  fdsu_ex3_rem_sign,\n  fdsu_ex3_rem_zero,\n  fdsu_ex3_result_denorm_round_add_num,\n  fdsu_ex4_frac,\n  fdsu_yy_div,\n  fdsu_yy_of_rm_lfn,\n  fdsu_yy_op0_norm,\n  fdsu_yy_op1_norm,\n  fdsu_yy_sqrt,\n  forever_cpuclk,\n  pad_yy_icg_scan_en,\n  srt_remainder_zero,\n  srt_sm_on,\n  total_qt_rt_30\n);\n\n// &Ports; @24\ninput           cp0_fpu_icg_en;                      \ninput           cp0_yy_clk_en;                       \ninput   [23:0]  ex1_divisor;                         \ninput   [12:0]  ex1_expnt_adder_op1;                 \ninput   [51:0]  ex1_oper_id_frac;                    \ninput           ex1_pipedown;                        \ninput           ex1_pipedown_gate;                   \ninput   [31:0]  ex1_remainder;                       \ninput           ex1_save_op0;                        \ninput           ex1_save_op0_gate;                   \ninput   [9 :0]  ex2_expnt_adder_op0;                 \ninput           ex2_pipe_clk;                        \ninput           ex2_pipedown;                        \ninput           ex2_srt_first_round;                 \ninput   [25:0]  ex3_frac_final_rst;                  \ninput           ex3_pipedown;                        \ninput           fdsu_yy_div;                         \ninput           fdsu_yy_of_rm_lfn;                   \ninput           fdsu_yy_op0_norm;                    \ninput           fdsu_yy_op1_norm;                    \ninput           fdsu_yy_sqrt;                        \ninput           forever_cpuclk;                      \ninput           pad_yy_icg_scan_en;                  \ninput           srt_sm_on;                           \noutput  [51:0]  ex1_oper_id_frac_f;                  \noutput          ex2_of;                              \noutput          ex2_potnt_of;                        \noutput          ex2_potnt_uf;                        \noutput          ex2_result_inf;                      \noutput          ex2_result_lfn;                      \noutput          ex2_rslt_denorm;                     \noutput  [9 :0]  ex2_srt_expnt_rst;                   \noutput          ex2_uf;                              \noutput          ex2_uf_srt_skip;                     \noutput          fdsu_ex3_id_srt_skip;                \noutput          fdsu_ex3_rem_sign;                   \noutput          fdsu_ex3_rem_zero;                   \noutput  [23:0]  fdsu_ex3_result_denorm_round_add_num; \noutput  [25:0]  fdsu_ex4_frac;                       \noutput          srt_remainder_zero;                  \noutput  [29:0]  total_qt_rt_30;                      \n\n// &Regs; @25\nreg     [31:0]  cur_rem;                             \nreg     [7 :0]  digit_bound_1;                       \nreg     [7 :0]  digit_bound_2;                       \nreg     [23:0]  ex2_result_denorm_round_add_num;     \nreg             fdsu_ex3_id_srt_skip;                \nreg             fdsu_ex3_rem_sign;                   \nreg             fdsu_ex3_rem_zero;                   \nreg     [23:0]  fdsu_ex3_result_denorm_round_add_num; \nreg     [29:0]  qt_rt_const_shift_std;               \nreg     [7 :0]  qtrt_sel_rem;                        \nreg     [31:0]  rem_add1_op1;                        \nreg     [31:0]  rem_add2_op1;                        \nreg     [25:0]  srt_divisor;                         \nreg     [31:0]  srt_remainder;                       \nreg     [29:0]  total_qt_rt_30;                      \nreg     [29:0]  total_qt_rt_30_next;                 \nreg     [29:0]  total_qt_rt_minus_30;                \nreg     [29:0]  total_qt_rt_minus_30_next;           \n\n// &Wires; @26\nwire    [7 :0]  bound1_cmp_result;                   \nwire            bound1_cmp_sign;                     \nwire    [7 :0]  bound2_cmp_result;                   \nwire            bound2_cmp_sign;                     \nwire    [3 :0]  bound_sel;                           \nwire            cp0_fpu_icg_en;                      \nwire            cp0_yy_clk_en;                       \nwire    [31:0]  cur_doub_rem_1;                      \nwire    [31:0]  cur_doub_rem_2;                      \nwire    [31:0]  cur_rem_1;                           \nwire    [31:0]  cur_rem_2;                           \nwire    [31:0]  div_qt_1_rem_add_op1;                \nwire    [31:0]  div_qt_2_rem_add_op1;                \nwire    [31:0]  div_qt_r1_rem_add_op1;               \nwire    [31:0]  div_qt_r2_rem_add_op1;               \nwire    [23:0]  ex1_divisor;                         \nwire            ex1_ex2_pipe_clk;                    \nwire            ex1_ex2_pipe_clk_en;                 \nwire    [12:0]  ex1_expnt_adder_op1;                 \nwire    [51:0]  ex1_oper_id_frac;                    \nwire    [51:0]  ex1_oper_id_frac_f;                  \nwire            ex1_pipedown;                        \nwire            ex1_pipedown_gate;                   \nwire    [31:0]  ex1_remainder;                       \nwire            ex1_save_op0;                        \nwire            ex1_save_op0_gate;                   \nwire            ex2_div_of;                          \nwire            ex2_div_uf;                          \nwire    [9 :0]  ex2_expnt_adder_op0;                 \nwire    [9 :0]  ex2_expnt_adder_op1;                 \nwire            ex2_expnt_of;                        \nwire    [9 :0]  ex2_expnt_result;                    \nwire            ex2_expnt_uf;                        \nwire            ex2_id_nor_srt_skip;                 \nwire            ex2_of;                              \nwire            ex2_of_plus;                         \nwire            ex2_pipe_clk;                        \nwire            ex2_pipedown;                        \nwire            ex2_potnt_of;                        \nwire            ex2_potnt_of_pre;                    \nwire            ex2_potnt_uf;                        \nwire            ex2_potnt_uf_pre;                    \nwire            ex2_result_inf;                      \nwire            ex2_result_lfn;                      \nwire            ex2_rslt_denorm;                     \nwire    [9 :0]  ex2_sqrt_expnt_result;               \nwire    [9 :0]  ex2_srt_expnt_rst;                   \nwire            ex2_srt_first_round;                 \nwire            ex2_uf;                              \nwire            ex2_uf_plus;                         \nwire            ex2_uf_srt_skip;                     \nwire    [25:0]  ex3_frac_final_rst;                  \nwire            ex3_pipedown;                        \nwire            fdsu_ex2_div;                        \nwire    [9 :0]  fdsu_ex2_expnt_rst;                  \nwire            fdsu_ex2_of_rm_lfn;                  \nwire            fdsu_ex2_op0_norm;                   \nwire            fdsu_ex2_op1_norm;                   \nwire            fdsu_ex2_result_lfn;                 \nwire            fdsu_ex2_sqrt;                       \nwire    [25:0]  fdsu_ex4_frac;                       \nwire            fdsu_yy_div;                         \nwire            fdsu_yy_of_rm_lfn;                   \nwire            fdsu_yy_op0_norm;                    \nwire            fdsu_yy_op1_norm;                    \nwire            fdsu_yy_sqrt;                        \nwire            forever_cpuclk;                      \nwire            pad_yy_icg_scan_en;                  \nwire            qt_clk;                              \nwire            qt_clk_en;                           \nwire    [29:0]  qt_rt_const_pre_sel_q1;              \nwire    [29:0]  qt_rt_const_pre_sel_q2;              \nwire    [29:0]  qt_rt_const_q1;                      \nwire    [29:0]  qt_rt_const_q2;                      \nwire    [29:0]  qt_rt_const_q3;                      \nwire    [29:0]  qt_rt_const_shift_std_next;          \nwire    [29:0]  qt_rt_mins_const_pre_sel_q1;         \nwire    [29:0]  qt_rt_mins_const_pre_sel_q2;         \nwire            rem_sign;                            \nwire    [31:0]  sqrt_qt_1_rem_add_op1;               \nwire    [31:0]  sqrt_qt_2_rem_add_op1;               \nwire    [31:0]  sqrt_qt_r1_rem_add_op1;              \nwire    [31:0]  sqrt_qt_r2_rem_add_op1;              \nwire            srt_div_clk;                         \nwire            srt_div_clk_en;                      \nwire    [31:0]  srt_remainder_nxt;                   \nwire    [31:0]  srt_remainder_shift;                 \nwire            srt_remainder_sign;                  \nwire            srt_remainder_zero;                  \nwire            srt_sm_on;                           \nwire    [29:0]  total_qt_rt_pre_sel;                 \n\n\nassign fdsu_ex2_div             = fdsu_yy_div;\nassign fdsu_ex2_sqrt            = fdsu_yy_sqrt;\nassign fdsu_ex2_op0_norm        = fdsu_yy_op0_norm;\nassign fdsu_ex2_op1_norm        = fdsu_yy_op1_norm;\nassign fdsu_ex2_of_rm_lfn       = fdsu_yy_of_rm_lfn;\nassign fdsu_ex2_result_lfn      = 1'b0;\n\n//==========================================================\n//                    EX2 Expnt Generate\n//==========================================================\n//expnt0 sub expnt1\nassign ex2_expnt_result[9:0] =  ex2_expnt_adder_op0[9:0] -\n                                 ex2_expnt_adder_op1[9:0];\n\n//===================sqrt exponent prepare==================\n//sqrt exponent prepare\n//afert E sub, div E by 2\nassign ex2_sqrt_expnt_result[9:0] = {ex2_expnt_result[9],\n                                      ex2_expnt_result[9:1]};\n\nassign ex2_srt_expnt_rst[9:0] = (fdsu_ex2_sqrt)\n                               ? ex2_sqrt_expnt_result[9:0]\n                               : ex2_expnt_result[9:0];\n// &Force(\"output\", \"ex2_srt_expnt_rst\"); &Force(\"bus\", \"ex2_srt_expnt_rst\", 9, 0); @51\nassign fdsu_ex2_expnt_rst[9:0] = ex2_srt_expnt_rst[9:0];\n\n\n//====================EX2 Expt info=========================\n//EX1 only detect of/uf under id condition\n//EX2 will deal with other condition\n\n//When input is normal, overflow when E1-E2 > 128/1024\nassign ex2_expnt_of = ~fdsu_ex2_expnt_rst[9] && (fdsu_ex2_expnt_rst[8]\n                                                      || (fdsu_ex2_expnt_rst[7]  &&\n                                                          |fdsu_ex2_expnt_rst[6:0]));\n//potential overflow when E1-E2 = 128/1024\nassign ex2_potnt_of_pre = ~fdsu_ex2_expnt_rst[9]  &&\n                           ~fdsu_ex2_expnt_rst[8]  &&\n                            fdsu_ex2_expnt_rst[7]  &&\n                          ~|fdsu_ex2_expnt_rst[6:0];\nassign ex2_potnt_of      = ex2_potnt_of_pre &&\n                           fdsu_ex2_op0_norm &&\n                           fdsu_ex2_op1_norm &&\n                           fdsu_ex2_div;\n\n//When input is normal, underflow when E1-E2 <= -127/-1023\nassign ex2_expnt_uf = fdsu_ex2_expnt_rst[9] &&(fdsu_ex2_expnt_rst[8:0] <= 9'h181);\n//potential underflow when E1-E2 = -126/-1022\nassign ex2_potnt_uf_pre = &fdsu_ex2_expnt_rst[9:7]   &&\n                          ~|fdsu_ex2_expnt_rst[6:2]   &&\n                            fdsu_ex2_expnt_rst[1]     &&\n                           !fdsu_ex2_expnt_rst[0];\nassign ex2_potnt_uf      = (ex2_potnt_uf_pre &&\n                            fdsu_ex2_op0_norm &&\n                            fdsu_ex2_op1_norm &&\n                            fdsu_ex2_div)     ||\n                           (ex2_potnt_uf_pre   &&\n                            fdsu_ex2_op0_norm);\n\n//========================EX2 Overflow======================\n//ex2 overflow when\n//  1.op0 & op1 both norm && expnt overflow\n//  2.ex1_id_of\n// &Force(\"output\",\"ex2_of\"); @91\nassign ex2_of      = ex2_of_plus;\nassign ex2_of_plus = ex2_div_of  && fdsu_ex2_div;\nassign ex2_div_of  = fdsu_ex2_op0_norm &&\n                     fdsu_ex2_op1_norm &&\n                     ex2_expnt_of;\n\n//=======================EX2 Underflow======================\n//ex2 underflow when\n//  1.op0 & op1 both norm && expnt underflow\n//  2.ex1_id_uf\n//  and detect when to skip the srt, here, we have further optmization\nassign ex2_uf      = ex2_uf_plus;\nassign ex2_uf_plus = ex2_div_uf  && fdsu_ex2_div;\nassign ex2_div_uf  = fdsu_ex2_op0_norm &&\n                     fdsu_ex2_op1_norm &&\n                     ex2_expnt_uf;\nassign ex2_id_nor_srt_skip =  fdsu_ex2_expnt_rst[9]\n                                     && (fdsu_ex2_expnt_rst[8:0]<9'h16a);\nassign ex2_uf_srt_skip            = ex2_id_nor_srt_skip;\nassign ex2_rslt_denorm            = ex2_uf;\n//===============ex2 round prepare for denormal round======\n// &CombBeg; @113\nalways @( fdsu_ex2_expnt_rst[9:0])\nbegin\ncase(fdsu_ex2_expnt_rst[9:0])\n  10'h382:ex2_result_denorm_round_add_num[23:0] = 24'h1; //-126 1\n  10'h381:ex2_result_denorm_round_add_num[23:0] = 24'h2; //-127 0\n  10'h380:ex2_result_denorm_round_add_num[23:0] = 24'h4; //-128 -1\n  10'h37f:ex2_result_denorm_round_add_num[23:0] = 24'h8; //-129 -2\n  10'h37e:ex2_result_denorm_round_add_num[23:0] = 24'h10; //-130 -3\n  10'h37d:ex2_result_denorm_round_add_num[23:0] = 24'h20; //-131 -4\n  10'h37c:ex2_result_denorm_round_add_num[23:0] = 24'h40; //-132 -5\n  10'h37b:ex2_result_denorm_round_add_num[23:0] = 24'h80; //-133 -6\n  10'h37a:ex2_result_denorm_round_add_num[23:0] = 24'h100; //-134 -7\n  10'h379:ex2_result_denorm_round_add_num[23:0] = 24'h200; //-135 -8\n  10'h378:ex2_result_denorm_round_add_num[23:0] = 24'h400; //-136 -9\n  10'h377:ex2_result_denorm_round_add_num[23:0] = 24'h800; //-137 -10\n  10'h376:ex2_result_denorm_round_add_num[23:0] = 24'h1000; //-138 -11\n  10'h375:ex2_result_denorm_round_add_num[23:0] = 24'h2000; //-139 -12\n  10'h374:ex2_result_denorm_round_add_num[23:0] = 24'h4000; //-140 -13\n  10'h373:ex2_result_denorm_round_add_num[23:0] = 24'h8000; // -141 -14\n  10'h372:ex2_result_denorm_round_add_num[23:0] = 24'h10000;//-142  -15\n  10'h371:ex2_result_denorm_round_add_num[23:0] = 24'h20000;//-143 -16\n  10'h370:ex2_result_denorm_round_add_num[23:0] = 24'h40000; //-144 -17\n  10'h36f:ex2_result_denorm_round_add_num[23:0] = 24'h80000; //-145 -18\n  10'h36e:ex2_result_denorm_round_add_num[23:0] = 24'h100000; //-146 -19\n  10'h36d:ex2_result_denorm_round_add_num[23:0] = 24'h200000; //-147 -20\n  10'h36c:ex2_result_denorm_round_add_num[23:0] = 24'h400000; //-148 -21\n  10'h36b:ex2_result_denorm_round_add_num[23:0] = 24'h800000; //-148 -22\n  default: ex2_result_denorm_round_add_num[23:0] = 24'h0;  // -23\nendcase\n// &CombEnd; @141\nend\n\n//===================special result========================\nassign ex2_result_inf  = ex2_of_plus && !fdsu_ex2_of_rm_lfn;\nassign ex2_result_lfn  = fdsu_ex2_result_lfn ||\n                         ex2_of_plus &&  fdsu_ex2_of_rm_lfn;\n\n\n\n//====================Pipe to EX3===========================\nalways @(posedge ex1_ex2_pipe_clk)\nbegin\n  if(ex1_pipedown)\n  begin\n    fdsu_ex3_result_denorm_round_add_num[23:0]\n                              <= {14'b0, ex1_expnt_adder_op1[9:0]};\n  end\n  else if(ex2_pipedown)\n  begin\n    fdsu_ex3_result_denorm_round_add_num[23:0]\n                              <= ex2_result_denorm_round_add_num[23:0];\n  end\n  else\n  begin\n    fdsu_ex3_result_denorm_round_add_num[23:0]\n                              <= fdsu_ex3_result_denorm_round_add_num[23:0];\n  end\nend\nassign ex2_expnt_adder_op1 = fdsu_ex3_result_denorm_round_add_num[9:0];\n// &Force(\"bus\", \"ex1_expnt_adder_op1\", 12, 0); @193\n\nassign ex1_ex2_pipe_clk_en = ex1_pipedown_gate || ex2_pipedown;\n// &Instance(\"gated_clk_cell\", \"x_ex1_ex2_pipe_clk\"); @196\ngated_clk_cell  x_ex1_ex2_pipe_clk (\n  .clk_in              (forever_cpuclk     ),\n  .clk_out             (ex1_ex2_pipe_clk   ),\n  .external_en         (1'b0               ),\n  .global_en           (cp0_yy_clk_en      ),\n  .local_en            (ex1_ex2_pipe_clk_en),\n  .module_en           (cp0_fpu_icg_en     ),\n  .pad_yy_icg_scan_en  (pad_yy_icg_scan_en )\n);\n\n// &Connect(.clk_in      (forever_cpuclk), @197\n//          .external_en (1'b0), @198\n//          .global_en   (cp0_yy_clk_en), @199\n//          .module_en   (cp0_fpu_icg_en), @200\n//          .local_en    (ex1_ex2_pipe_clk_en), @201\n//          .clk_out     (ex1_ex2_pipe_clk)); @202\n\nalways @(posedge ex2_pipe_clk)\nbegin\n  if(ex2_pipedown)\n  begin\n    fdsu_ex3_rem_sign        <= srt_remainder_sign;\n    fdsu_ex3_rem_zero        <= srt_remainder_zero;\n    fdsu_ex3_id_srt_skip     <= ex2_id_nor_srt_skip;\n  end\n  else\n  begin\n    fdsu_ex3_rem_sign        <= fdsu_ex3_rem_sign;\n    fdsu_ex3_rem_zero        <= fdsu_ex3_rem_zero;\n    fdsu_ex3_id_srt_skip    <=  fdsu_ex3_id_srt_skip;\n  end\nend\n\n// &Force(\"output\",\"fdsu_ex3_rem_sign\"); @243\n// &Force(\"output\",\"fdsu_ex3_rem_zero\"); @244\n// &Force(\"output\",\"fdsu_ex3_result_denorm_round_add_num\"); @245\n// &Force(\"output\",\"fdsu_ex3_id_srt_skip\"); @246\n\n//==========================================================\n//    SRT Remainder & Divisor for Quotient/Root Generate\n//==========================================================\n\n//===================Remainder Generate=====================\n//gate clk\n// &Instance(\"gated_clk_cell\",\"x_srt_rem_clk\");\n// // &Connect( .clk_in         (forever_cpuclk), @255\n// //           .clk_out        (srt_rem_clk),//Out Clock @256\n// //           .external_en    (1'b0), @257\n// //           .global_en      (cp0_yy_clk_en), @258\n// //           .local_en       (srt_rem_clk_en),//Local Condition @259\n// //           .module_en      (cp0_fpu_icg_en) @260\n// //         ); @261\n// assign srt_rem_clk_en = ex1_pipedown ||\n//                         srt_sm_on;\n\nalways @(posedge qt_clk)\nbegin\n  if (ex1_pipedown)\n    srt_remainder[31:0] <= ex1_remainder[31:0];\n  else if (srt_sm_on)\n    srt_remainder[31:0] <= srt_remainder_nxt[31:0];\n  else\n    srt_remainder[31:0] <= srt_remainder[31:0];\nend\n\n//=====================Divisor Generate=====================\n//gate clk\n// &Instance(\"gated_clk_cell\",\"x_srt_div_clk\"); @291\ngated_clk_cell  x_srt_div_clk (\n  .clk_in             (forever_cpuclk    ),\n  .clk_out            (srt_div_clk       ),\n  .external_en        (1'b0              ),\n  .global_en          (cp0_yy_clk_en     ),\n  .local_en           (srt_div_clk_en    ),\n  .module_en          (cp0_fpu_icg_en    ),\n  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)\n);\n\n// &Connect( .clk_in         (forever_cpuclk), @292\n//           .clk_out        (srt_div_clk),//Out Clock @293\n//           .external_en    (1'b0), @294\n//           .global_en      (cp0_yy_clk_en), @295\n//           .local_en       (srt_div_clk_en),//Local Condition @296\n//           .module_en      (cp0_fpu_icg_en) @297\n//         ); @298\nassign srt_div_clk_en = ex1_pipedown_gate\n                     || ex1_save_op0_gate\n                     || ex3_pipedown;\n// final_rst saved in srt_divisor.\n// srt_divisor is 26 bits, final_rst is 24 bits.\nalways @(posedge srt_div_clk)\nbegin\n  if (ex1_save_op0)\n    srt_divisor[25:0] <= {3'b0, {ex1_oper_id_frac[51:29]}};\n  else if (ex1_pipedown)\n    srt_divisor[25:0] <= {2'b0, ex1_divisor[23:0]};\n  else if (ex3_pipedown)\n    srt_divisor[25:0] <= ex3_frac_final_rst[25:0];\n  else\n    srt_divisor[25:0] <= srt_divisor[25:0];\nend\nassign ex1_oper_id_frac_f[51:0] = {srt_divisor[22:0], 29'b0};\n// &Force(\"bus\", \"ex1_oper_id_frac\", 51, 0); @332\nassign fdsu_ex4_frac[25:0] = srt_divisor[25:0];\n\n//=======================Bound Select=======================\n//---------------------------------------+\n// K   | 8 | 9 | 10| 11| 12| 13| 14|15,16|\n//---------------------------------------+\n//32S1 | 7 | 7 | 8 | 9 | 9 | 10| 11|  12 |\n//---------------------------------------+\n//32S2 | 25| 28| 31| 33| 36| 39| 41|  47 |\n//---------------------------------------+\n\n//bound_sel[3:0]\n//For div,  use divisor high four bit as K\n//For sqrt, use 2qi high four bit as K next round and\n//          use 1010 as K first round\nassign bound_sel[3:0] = (fdsu_ex2_div)\n                      ? srt_divisor[23:20]\n                      : (ex2_srt_first_round)\n                        ? 4'b1010\n                        : total_qt_rt_30[28:25];\n//Select bound as look up table\n//   K = bound_sel[3:0]\n//32S1 = digit_bound_1[7:0]\n//32s2 = digit_bound_2[7:0]\n// &CombBeg; @357\nalways @( bound_sel[3:0])\nbegin\ncase(bound_sel[3:0])\n4'b0000:       //when first interation get \"10\", choose k=16\n   begin\n     digit_bound_1[7:0] = 8'b11110100;//-12\n     digit_bound_2[7:0] = 8'b11010001;//-47\n   end\n4'b1000:\n   begin\n     digit_bound_1[7:0] = 8'b11111001;//-7\n     digit_bound_2[7:0] = 8'b11100111;//-25\n   end\n4'b1001:\n   begin\n     digit_bound_1[7:0] = 8'b11111001;//-7\n     digit_bound_2[7:0] = 8'b11100100;//-28\n   end\n4'b1010:\n   begin\n     digit_bound_1[7:0] = 8'b11111000;//-8\n     digit_bound_2[7:0] = 8'b11100001;//-31\n   end\n4'b1011:\n   begin\n     digit_bound_1[7:0] = 8'b11110111;//-9\n     digit_bound_2[7:0] = 8'b11011111;//-33\n   end\n4'b1100:\n   begin\n     digit_bound_1[7:0] = 8'b11110111;//-9\n     digit_bound_2[7:0] = 8'b11011100;//-36\n   end\n4'b1101:\n   begin\n     digit_bound_1[7:0] = 8'b11110110;//-10\n     digit_bound_2[7:0] = 8'b11011001;//-39\n   end\n4'b1110:\n   begin\n     digit_bound_1[7:0] = 8'b11110101;//-11\n     digit_bound_2[7:0] = 8'b11010111;//-41\n   end\n4'b1111:\n   begin\n     digit_bound_1[7:0] = 8'b11110100;//-12\n     digit_bound_2[7:0] = 8'b11010001;//-47\n   end\ndefault:\n   begin\n     digit_bound_1[7:0] = 8'b11111001;//-7\n     digit_bound_2[7:0] = 8'b11100111;//-25\n   end\nendcase\n// &CombEnd; @410\nend\n\n//==============Prepare for quotient generate===============\nassign bound1_cmp_result[7:0] = qtrt_sel_rem[7:0] + digit_bound_1[7:0];\nassign bound2_cmp_result[7:0] = qtrt_sel_rem[7:0] + digit_bound_2[7:0];\nassign bound1_cmp_sign        = bound1_cmp_result[7];\nassign bound2_cmp_sign        = bound2_cmp_result[7];\nassign rem_sign               = srt_remainder[29];\n\n//qtrt_sel_rem is use to select quotient\n//Only when sqrt first round use 8R0 select quotient(special rule)\n//4R0 is used to select quotient on other condition\n//For negative remaider, we use ~rem not (~rem + 1)\n//Because  bound1 <=  rem   <   bound2, when positive rem\n//        -bound2 <=  rem   <  -bound1, when negative rem\n//Thus     bound1 <  -rem   <=  bound2, when negative rem\n//Thus     bound1 <= -rem-1 <   bound2, when negative rem\n//Thus     bound1 <= ~rem   <   bound2, when negative rem\n//srt_remainder[29] used as sign bit\n// &CombBeg; @429\nalways @( ex2_srt_first_round\n       or fdsu_ex2_sqrt\n       or srt_remainder[29:21])\nbegin\nif(ex2_srt_first_round && fdsu_ex2_sqrt)\n  qtrt_sel_rem[7:0] = {srt_remainder[29],   srt_remainder[27:21]};\nelse\n  qtrt_sel_rem[7:0] =  srt_remainder[29] ? ~srt_remainder[29:22]\n                                         :  srt_remainder[29:22];\n// &CombEnd; @435\nend\n\n//==========================================================\n//     on fly round method to generate total quotient\n//==========================================================\n//gate clk\n// &Instance(\"gated_clk_cell\",\"x_qt_clk\"); @441\ngated_clk_cell  x_qt_clk (\n  .clk_in             (forever_cpuclk    ),\n  .clk_out            (qt_clk            ),\n  .external_en        (1'b0              ),\n  .global_en          (cp0_yy_clk_en     ),\n  .local_en           (qt_clk_en         ),\n  .module_en          (cp0_fpu_icg_en    ),\n  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)\n);\n\n// &Connect( .clk_in         (forever_cpuclk), @442\n//           .clk_out        (qt_clk),//Out Clock @443\n//           .external_en    (1'b0), @444\n//           .global_en      (cp0_yy_clk_en), @445\n//           .local_en       (qt_clk_en),//Local Condition @446\n//           .module_en      (cp0_fpu_icg_en) @447\n//         ); @448\nassign qt_clk_en = srt_sm_on ||\n                   ex1_pipedown_gate;\n\n//qt_rt_const_shift_std[29:0] is const data for on fly round\n//                which is used to record the times of round\n//\n//total_qt_rt[29:0]       is total quotient\n//total_qt_rt_minus[29:0] is total quotient minus\n//                which is used to generate quotient rapidly\nalways @(posedge qt_clk)\nbegin\n  if(ex1_pipedown)\n  begin\n    qt_rt_const_shift_std[29:0] <= {1'b0,1'b1,28'b0};\n    total_qt_rt_30[29:0]        <= 30'b0;\n    total_qt_rt_minus_30[29:0]  <= 30'b0;\n  end\n  else if(srt_sm_on)\n  begin\n    qt_rt_const_shift_std[29:0] <= qt_rt_const_shift_std_next[29:0];\n    total_qt_rt_30[29:0]        <= total_qt_rt_30_next[29:0];\n    total_qt_rt_minus_30[29:0]  <= total_qt_rt_minus_30_next[29:0];\n  end\n  else\n  begin\n    qt_rt_const_shift_std[29:0] <= qt_rt_const_shift_std[29:0];\n    total_qt_rt_30[29:0]        <= total_qt_rt_30[29:0];\n    total_qt_rt_minus_30[29:0]  <= total_qt_rt_minus_30[29:0];\n  end\nend\n// &Force(\"output\",\"total_qt_rt_30\"); @508\n\n//qt_rt_const_q1/q2/q3 for shift 1/2/3 in\nassign qt_rt_const_q1[29:0] =  qt_rt_const_shift_std[29:0];\nassign qt_rt_const_q2[29:0] = {qt_rt_const_shift_std[28:0],1'b0};\nassign qt_rt_const_q3[29:0] =  qt_rt_const_q1[29:0] |\n                               qt_rt_const_q2[29:0];\n//qt_rt_const update value\nassign qt_rt_const_shift_std_next[29:0] = {2'b0, qt_rt_const_shift_std[29:2]};\n\n//========total_qt_rt & total_qt_rt_minus update value======\n//q(i+1) is the total quotient/root after the (i+1) digit\n//is calculated\n//                 q(i+1)             qm(i+1)\n//d(i+1)=-2     qm(i)+2*shift      qm(i)+1*shift\n//d(i+1)=-1     qm(i)+3*shift      qm(i)+2*shift\n//d(i+1)=0      q(i)               qm(i)+3*shift\n//d(i+1)=1      q(i)+1*shift       q(i)\n//d(i+1)=2      q(i)+2*shift       q(i)+1*shift\n//Note:\n//shift = 4^(-i-1), qm(i+1)=q(i+1)-shift\n\n//pre select for quotient\nassign total_qt_rt_pre_sel[29:0]         = (rem_sign) ?\n                                           total_qt_rt_minus_30[29:0] :\n                                           total_qt_rt_30[29:0];\n//when the quotient is 2 or -2\nassign qt_rt_const_pre_sel_q2[29:0]      = qt_rt_const_q2[29:0];\nassign qt_rt_mins_const_pre_sel_q2[29:0] = qt_rt_const_q1[29:0];\n//when the quotient is 1 or -1\nassign qt_rt_const_pre_sel_q1[29:0]      = (rem_sign) ?\n                                           qt_rt_const_q3[29:0] ://-1\n                                           qt_rt_const_q1[29:0]; //1\nassign qt_rt_mins_const_pre_sel_q1[29:0] = (rem_sign) ?\n                                           qt_rt_const_q2[29:0] : //-1\n                                           30'b0;\n\n//After bound compare, the final selection\n// &CombBeg; @546\nalways @( qt_rt_const_q3[29:0]\n       or qt_rt_mins_const_pre_sel_q1[29:0]\n       or bound1_cmp_sign\n       or total_qt_rt_30[29:0]\n       or qt_rt_mins_const_pre_sel_q2[29:0]\n       or total_qt_rt_minus_30[29:0]\n       or bound2_cmp_sign\n       or qt_rt_const_pre_sel_q2[29:0]\n       or qt_rt_const_pre_sel_q1[29:0]\n       or total_qt_rt_pre_sel[29:0])\nbegin\ncasez({bound1_cmp_sign,bound2_cmp_sign})\n  2'b00:// the quotient is -2 or 2\n  begin\n    total_qt_rt_30_next[29:0]       = total_qt_rt_pre_sel[29:0] |\n                                      qt_rt_const_pre_sel_q2[29:0];\n    total_qt_rt_minus_30_next[29:0] = total_qt_rt_pre_sel[29:0] |\n                                      qt_rt_mins_const_pre_sel_q2[29:0];\n  end\n  2'b01:// quotient is -1 or 1\n  begin\n    total_qt_rt_30_next[29:0]       = total_qt_rt_pre_sel[29:0] |\n                                      qt_rt_const_pre_sel_q1[29:0];\n    total_qt_rt_minus_30_next[29:0] = total_qt_rt_pre_sel[29:0] |\n                                      qt_rt_mins_const_pre_sel_q1[29:0];\n  end\n  2'b1?: // quotient is 0\n  begin\n    total_qt_rt_30_next[29:0]       = total_qt_rt_30[29:0];\n    total_qt_rt_minus_30_next[29:0] = total_qt_rt_minus_30[29:0] |\n                                      qt_rt_const_q3[29:0];\n  end\n  default:\n  begin\n    total_qt_rt_30_next[29:0]       = 30'b0;\n    total_qt_rt_minus_30_next[29:0] = 30'b0;\n  end\nendcase\n// &CombEnd; @574\nend\n\n//==========================================================\n//      on fly round method to generate cur remainder\n//==========================================================\n//Division emainder add value\n//Quoit 1\nassign div_qt_1_rem_add_op1[31:0]   = ~{3'b0,srt_divisor[23:0],5'b0};\n//Quoit 2\nassign div_qt_2_rem_add_op1[31:0]   = ~{2'b0,srt_divisor[23:0],6'b0};\n//Quoit -1\nassign div_qt_r1_rem_add_op1[31:0]  =  {3'b0,srt_divisor[23:0],5'b0};\n//Quoit -2\nassign div_qt_r2_rem_add_op1[31:0]  =  {2'b0,srt_divisor[23:0],6'b0};\n\n//Sqrt remainder add value op1\n//Quoit 1\nassign sqrt_qt_1_rem_add_op1[31:0]  = ~({2'b0,total_qt_rt_30[29:0]} |\n                                        {3'b0,qt_rt_const_q1[29:1]});\n//Quoit 2\nassign sqrt_qt_2_rem_add_op1[31:0]  = ~({1'b0,total_qt_rt_30[29:0],1'b0} |\n                                        {1'b0,qt_rt_const_q1[29:0],1'b0});\n//Quoit -1\nassign sqrt_qt_r1_rem_add_op1[31:0] =   {2'b0,total_qt_rt_minus_30[29:0]} |\n                                        {1'b0,qt_rt_const_q1[29:0],1'b0}  |\n                                        {2'b0,qt_rt_const_q1[29:0]}       |\n                                        {3'b0,qt_rt_const_q1[29:1]};\n//Quoit -2\nassign sqrt_qt_r2_rem_add_op1[31:0] =   {1'b0,\n                                         total_qt_rt_minus_30[29:0],1'b0} |\n                                        {qt_rt_const_q1[29:0],2'b0}       |\n                                        {1'b0,qt_rt_const_q1[29:0],1'b0};\n//Remainder Adder select logic\n// &CombBeg; @607\nalways @( div_qt_2_rem_add_op1[31:0]\n       or sqrt_qt_r2_rem_add_op1[31:0]\n       or sqrt_qt_r1_rem_add_op1[31:0]\n       or rem_sign\n       or div_qt_r2_rem_add_op1[31:0]\n       or div_qt_1_rem_add_op1[31:0]\n       or sqrt_qt_2_rem_add_op1[31:0]\n       or fdsu_ex2_sqrt\n       or div_qt_r1_rem_add_op1[31:0]\n       or sqrt_qt_1_rem_add_op1[31:0])\nbegin\ncase({rem_sign,fdsu_ex2_sqrt})\n  2'b01:\n  begin\n        rem_add1_op1[31:0] = sqrt_qt_1_rem_add_op1[31:0];\n        rem_add2_op1[31:0] = sqrt_qt_2_rem_add_op1[31:0];\n  end\n  2'b00:\n  begin\n        rem_add1_op1[31:0] = div_qt_1_rem_add_op1[31:0];\n        rem_add2_op1[31:0] = div_qt_2_rem_add_op1[31:0];\n  end\n  2'b11:\n  begin\n        rem_add1_op1[31:0] = sqrt_qt_r1_rem_add_op1[31:0];\n        rem_add2_op1[31:0] = sqrt_qt_r2_rem_add_op1[31:0];\n  end\n  2'b10:\n  begin\n        rem_add1_op1[31:0] = div_qt_r1_rem_add_op1[31:0];\n        rem_add2_op1[31:0] = div_qt_r2_rem_add_op1[31:0];\n  end\n  default :\n  begin\n        rem_add1_op1[31:0] = 32'b0;\n        rem_add2_op1[31:0] = 32'b0;\n  end\n  endcase\n// &CombEnd; @635\nend\nassign srt_remainder_shift[31:0] = {srt_remainder[31],\n                                    srt_remainder[28:0],2'b0};\n//Remainder add\nassign cur_doub_rem_1[31:0]      = srt_remainder_shift[31:0] +\n                                   rem_add1_op1[31:0]    +\n                                   {31'b0, ~rem_sign};\nassign cur_doub_rem_2[31:0]      = srt_remainder_shift[31:0] +\n                                   rem_add2_op1[31:0]    +\n                                   {31'b0, ~rem_sign};\nassign cur_rem_1[31:0]           = cur_doub_rem_1[31:0];\nassign cur_rem_2[31:0]           = cur_doub_rem_2[31:0];\n//Generate srt remainder update value\n// &CombBeg; @648\nalways @( cur_rem_2[31:0]\n       or bound1_cmp_sign\n       or srt_remainder_shift[31:0]\n       or bound2_cmp_sign\n       or cur_rem_1[31:0])\nbegin\ncase({bound1_cmp_sign,bound2_cmp_sign})\n  2'b00:   cur_rem[31:0]         = cur_rem_2[31:0];  //+-2\n  2'b01:   cur_rem[31:0]         = cur_rem_1[31:0];  //+-1\n  default: cur_rem[31:0]         = srt_remainder_shift[31:0]; //0\nendcase\n// &CombEnd; @654\nend\nassign srt_remainder_nxt[31:0]   = cur_rem[31:0];\n\n//Remainder is zero signal in EX3\nassign srt_remainder_zero        = ~|srt_remainder[31:0];\n// &Force(\"output\",\"srt_remainder_zero\"); @659\nassign srt_remainder_sign        =   srt_remainder[31];\n\n// &Force(\"output\", \"ex2_uf\"); @662\n// &ModuleEnd; @663\nendmodule\n\n\n\n","lang":"verilog"};
processSrcData(g_data);