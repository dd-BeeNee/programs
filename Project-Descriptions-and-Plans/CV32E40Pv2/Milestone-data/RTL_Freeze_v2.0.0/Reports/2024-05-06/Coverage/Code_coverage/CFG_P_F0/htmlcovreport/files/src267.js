var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/src/fpnew_divsqrt_th_32.sv","src":"// Copyright 2019-2022 ETH Zurich and University of Bologna.\n//\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// SPDX-License-Identifier: SHL-0.51\n\n// Authors: Stefan Mach <smach@iis.ee.ethz.ch>\n//          Luca Bertaccini <lbertaccini@iis.ee.ethz.ch>\n//          Jiang Lannan <jiangl@ethz.ch>\n//          Kexin Li <likexi@ethz.ch>\n\n`include \"common_cells/registers.svh\"\n\nmodule fpnew_divsqrt_th_32 #(\n  // FP32-only DivSqrt\n  // FPU configuration\n  parameter int unsigned             NumPipeRegs = 0,\n  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,\n  parameter type                     TagType     = logic,\n  parameter type                     AuxType     = logic,\n  // Do not change\n  localparam int unsigned WIDTH       = 32,\n  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,\n  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs\n) (\n  input  logic                        clk_i,\n  input  logic                        rst_ni,\n  // Input signals\n  input  logic [1:0][WIDTH-1:0]       operands_i, // 2 operands\n  input  logic [NUM_FORMATS-1:0][1:0] is_boxed_i, // 2 operands\n  input  fpnew_pkg::roundmode_e       rnd_mode_i,\n  input  fpnew_pkg::operation_e       op_i,\n  input  TagType                      tag_i,\n  input  logic                        mask_i,\n  input  AuxType                      aux_i,\n  // Input Handshake\n  input  logic                        in_valid_i,\n  output logic                        in_ready_o,\n  input  logic                        flush_i,\n  // Output signals\n  output logic [WIDTH-1:0]            result_o,\n  output fpnew_pkg::status_t          status_o,\n  output logic                        extension_bit_o,\n  output TagType                      tag_o,\n  output logic                        mask_o,\n  output AuxType                      aux_o,\n  // Output handshake\n  output logic                        out_valid_o,\n  input  logic                        out_ready_i,\n  // Indication of valid data in flight\n  output logic                        busy_o,\n  // External register enable override\n  input  logic [ExtRegEnaWidth-1:0]   reg_ena_i\n);\n\n  // ----------\n  // Constants\n  // ----------\n  // Pipelines\n  localparam NUM_INP_REGS = (PipeConfig == fpnew_pkg::BEFORE)\n                            ? NumPipeRegs\n                            : (PipeConfig == fpnew_pkg::DISTRIBUTED\n                               ? (NumPipeRegs / 2) // Last to get distributed regs\n                               : 0); // no regs here otherwise\n  localparam NUM_OUT_REGS = (PipeConfig == fpnew_pkg::AFTER || PipeConfig == fpnew_pkg::INSIDE)\n                            ? NumPipeRegs\n                            : (PipeConfig == fpnew_pkg::DISTRIBUTED\n                               ? ((NumPipeRegs + 1) / 2) // First to get distributed regs\n                               : 0); // no regs here otherwise\n\n  // ---------------\n  // Input pipeline\n  // ---------------\n  // Selected pipeline output signals as non-arrays\n  logic [1:0][WIDTH-1:0] operands_q;\n  fpnew_pkg::roundmode_e rnd_mode_q;\n  fpnew_pkg::operation_e op_q;\n  logic                  in_valid_q;\n\n  // Input pipeline signals, index i holds signal after i register stages\n  logic                  [0:NUM_INP_REGS][1:0][WIDTH-1:0]       inp_pipe_operands_q;\n  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;\n  fpnew_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;\n  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;\n  logic                  [0:NUM_INP_REGS]                       inp_pipe_mask_q;\n  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;\n  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;\n  // Ready signal is combinatorial for all stages\n  logic [0:NUM_INP_REGS] inp_pipe_ready;\n\n  // Input stage: First element of pipeline is taken from inputs\n  assign inp_pipe_operands_q[0] = operands_i;\n  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;\n  assign inp_pipe_op_q[0]       = op_i;\n  assign inp_pipe_tag_q[0]      = tag_i;\n  assign inp_pipe_mask_q[0]     = mask_i;\n  assign inp_pipe_aux_q[0]      = aux_i;\n  assign inp_pipe_valid_q[0]    = in_valid_i;\n  // Input stage: Propagate pipeline ready signal to updtream circuitry\n  assign in_ready_o = inp_pipe_ready[0];\n  // Generate the register stages\n  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline\n    // Internal register enable for this stage\n    logic reg_ena;\n    // Determine the ready signal of the current stage - advance the pipeline:\n    // 1. if the next stage is ready for our data\n    // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];\n    // Valid: enabled by ready signal, synchronous clear with the flush signal\n    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n    // Enable register if pipleine ready and a valid data item is present\n    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];\n    // Generate the pipeline registers within the stages, use enable-registers\n    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)\n    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)\n    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)\n    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))\n    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)\n    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))\n  end\n  // Output stage: assign selected pipe outputs to signals for later use\n  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];\n  assign rnd_mode_q = inp_pipe_rnd_mode_q[NUM_INP_REGS];\n  assign op_q       = inp_pipe_op_q[NUM_INP_REGS];\n  assign in_valid_q = inp_pipe_valid_q[NUM_INP_REGS];\n\n  // ------------\n  // Control FSM\n  // ------------\n  logic in_ready;               // input handshake with upstream\n  logic div_op, sqrt_op;        // input signalling with unit\n  logic unit_ready_q, unit_done;  // status signals from unit instance\n  logic op_starting;            // high in the cycle a new operation starts\n  logic out_valid, out_ready;   // output handshake with downstream\n  logic hold_result;            // whether to put result into hold register\n  logic data_is_held;           // data in hold register is valid\n  logic unit_busy;              // valid data in flight\n  // FSM states\n  typedef enum logic [1:0] {IDLE, BUSY, HOLD} fsm_state_e;\n  fsm_state_e state_q, state_d;\n\n  // Operations are gated by the FSM ready. Invalid input ops run a sqrt to not lose illegal instr.\n  assign div_op   = in_valid_q & (op_q == fpnew_pkg::DIV) & in_ready & ~flush_i;  //in_ready delete, valid independent of ready\n  assign sqrt_op  = in_valid_q & (op_q == fpnew_pkg::SQRT) & in_ready & ~flush_i;\n  assign op_starting = div_op | sqrt_op;  //start computing or handshake, modify tb handshake right\n\n  logic fdsu_fpu_ex1_stall, fdsu_fpu_ex1_stall_q;\n  logic div_op_d, div_op_q;\n  logic sqrt_op_d, sqrt_op_q;\n\n  assign div_op_d  = (fdsu_fpu_ex1_stall) ? div_op  : 1'b0;\n  assign sqrt_op_d = (fdsu_fpu_ex1_stall) ? sqrt_op : 1'b0;\n\n  `FFL(fdsu_fpu_ex1_stall_q, fdsu_fpu_ex1_stall, 1'b1, '0)\n  `FFL(div_op_q, div_op_d, 1'b1, '0)\n  `FFL(sqrt_op_q, sqrt_op_d, 1'b1, '0)\n\n  // FSM to safely apply and receive data from DIVSQRT unit\n  always_comb begin : flag_fsm\n    // Default assignments\n    in_ready     = 1'b0;\n    out_valid    = 1'b0;\n    hold_result  = 1'b0;\n    data_is_held = 1'b0;\n    unit_busy    = 1'b0;\n    state_d      = state_q;\n    inp_pipe_ready[NUM_INP_REGS] = unit_ready_q;\n\n    unique case (state_q)\n      // Waiting for work\n      IDLE: begin\n        // in_ready = 1'b1; // we're ready\n        in_ready = unit_ready_q;  //***\n        if (in_valid_q && unit_ready_q) begin // New work arrives\n          inp_pipe_ready[NUM_INP_REGS] = unit_ready_q && !fdsu_fpu_ex1_stall;\n          state_d = BUSY; // go into processing state\n        end\n      end\n      // Operation in progress\n      BUSY: begin\n        inp_pipe_ready[NUM_INP_REGS] = fdsu_fpu_ex1_stall_q;\n        unit_busy = 1'b1; // data in flight\n        // If the unit is done with processing\n        if (unit_done) begin\n          out_valid = 1'b1; // try to commit result downstream\n          // If downstream accepts our result\n          if (out_ready) begin\n            state_d = IDLE; // we anticipate going back to idling..\n            if (in_valid_q && unit_ready_q) begin // ..unless new work comes in\n              in_ready = 1'b1; // we acknowledge the instruction\n              state_d  = BUSY; // and stay busy with it\n            end\n          // Otherwise if downstream is not ready for the result\n          end else begin\n            hold_result = 1'b1; // activate the hold register\n            state_d     = HOLD; // wait for the pipeline to take the data\n          end\n        end\n      end\n      // Waiting with valid result for downstream\n      HOLD: begin\n        unit_busy    = 1'b1; // data in flight\n        data_is_held = 1'b1; // data in hold register is valid\n        out_valid    = 1'b1; // try to commit result downstream\n        // If the result is accepted by downstream\n        if (out_ready) begin\n          state_d = IDLE; // go back to idle..\n          if (in_valid_q && unit_ready_q) begin // ..unless new work comes in\n            in_ready = 1'b1; // acknowledge the new transaction\n            state_d  = BUSY; // will be busy with the next instruction\n          end\n        end\n      end\n      // fall into idle state otherwise\n      default: state_d = IDLE;\n    endcase\n\n    // Flushing overrides the other actions\n    if (flush_i) begin\n      unit_busy = 1'b0; // data is invalidated\n      out_valid = 1'b0; // cancel any valid data\n      state_d   = IDLE; // go to default state\n    end\n  end\n\n  // FSM status register (asynch active low reset)\n  `FF(state_q, state_d, IDLE)\n\n  // Hold additional information while the operation is in progress\n  TagType result_tag_q;\n  AuxType result_aux_q;\n  logic   result_mask_q;\n\n  // Fill the registers everytime a valid operation arrives (load FF, active low asynch rst)\n  `FFL(result_tag_q,  inp_pipe_tag_q[NUM_INP_REGS],  op_starting, '0)\n  `FFL(result_mask_q, inp_pipe_mask_q[NUM_INP_REGS], op_starting, '0)\n  `FFL(result_aux_q,  inp_pipe_aux_q[NUM_INP_REGS],  op_starting, '0)\n\n  // -----------------\n  // DIVSQRT instance\n  // -----------------\n  logic [WIDTH-1:0]   unit_result, held_result_q;\n  fpnew_pkg::status_t unit_status, held_status_q;\n\n  // thead define fdsu module's input and output\n  logic        ctrl_fdsu_ex1_sel;\n  logic        fdsu_fpu_ex1_cmplt;\n  logic  [4:0] fdsu_fpu_ex1_fflags;\n  logic  [7:0] fdsu_fpu_ex1_special_sel;\n  logic  [3:0] fdsu_fpu_ex1_special_sign;\n  logic        fdsu_fpu_no_op;\n  logic  [2:0] idu_fpu_ex1_eu_sel;\n  logic [31:0] fdsu_frbus_data;\n  logic  [4:0] fdsu_frbus_fflags;\n  logic        fdsu_frbus_wb_vld;\n\n  // dp\n  logic [31:0] dp_frbus_ex2_data;\n  logic  [4:0] dp_frbus_ex2_fflags;\n  logic  [2:0] dp_xx_ex1_cnan;\n  logic  [2:0] dp_xx_ex1_id;\n  logic  [2:0] dp_xx_ex1_inf;\n  logic  [2:0] dp_xx_ex1_norm;\n  logic  [2:0] dp_xx_ex1_qnan;\n  logic  [2:0] dp_xx_ex1_snan;\n  logic  [2:0] dp_xx_ex1_zero;\n  logic        ex2_inst_wb;\n  logic        ex2_inst_wb_vld_d, ex2_inst_wb_vld_q;\n\n  // frbus\n  logic [31:0] fpu_idu_fwd_data;\n  logic  [4:0] fpu_idu_fwd_fflags;\n  logic        fpu_idu_fwd_vld;\n\n  logic unit_ready_d;\n\n  // unit_ready_q related to state machine, different under special and normal cases.\n  always_comb begin\n    if(op_starting && unit_ready_q) begin\n      if(ex2_inst_wb && ex2_inst_wb_vld_q) begin\n        unit_ready_d = 1'b1;\n      end else begin\n        unit_ready_d = 1'b0;\n      end\n    end else if(fpu_idu_fwd_vld | flush_i) begin\n      unit_ready_d = 1'b1;\n    end else begin\n      unit_ready_d = unit_ready_q;\n    end\n  end\n\n  `FFL(unit_ready_q, unit_ready_d, 1'b1, 1'b1)\n\n  // determine input of time to select operands\n  always_comb begin\n    ctrl_fdsu_ex1_sel = 1'b0;\n    idu_fpu_ex1_eu_sel = 3'h0;\n    if (op_starting) begin  // time to start calculation\n      ctrl_fdsu_ex1_sel = 1'b1;  // time to select operands\n      idu_fpu_ex1_eu_sel = 3'h4; // time to select operands, only idu_fpu_ex1_eu_sel_i[2] works in fdsu module\n    end else if (fdsu_fpu_ex1_stall_q) begin\n      ctrl_fdsu_ex1_sel = 1'b1;  // time to select operands\n      idu_fpu_ex1_eu_sel = 3'h4; // time to select operands, only idu_fpu_ex1_eu_sel_i[2] works in fdsu module\n    end else begin\n      ctrl_fdsu_ex1_sel = 1'b0;\n      idu_fpu_ex1_eu_sel = 3'h0;\n    end\n  end\n\n  pa_fdsu_top i_divsqrt_thead (\n   .cp0_fpu_icg_en                ( 1'b0               ),  // input clock gate enable in gated_clk_cell, active 0.\n   .cp0_fpu_xx_dqnan              ( 1'b0               ),  // When dqnan = 0, QNAN (0x7fc00000).\n   .cp0_yy_clk_en                 ( 1'b1               ),  // clock enable in gated_clk_cell, active 1.\n   .cpurst_b                      ( rst_ni             ),  // If negedge cpu reset, all state machines reset to IDLE.\n   .ctrl_fdsu_ex1_sel             ( ctrl_fdsu_ex1_sel  ),  // select operands\n   .ctrl_xx_ex1_cmplt_dp          ( ctrl_fdsu_ex1_sel  ),  // complete datapath\n   .ctrl_xx_ex1_inst_vld          ( ctrl_fdsu_ex1_sel  ),  // instance valid\n   .ctrl_xx_ex1_stall             ( fdsu_fpu_ex1_stall ),\n   .ctrl_xx_ex1_warm_up           ( 1'b0               ),\n   .ctrl_xx_ex2_warm_up           ( 1'b0               ),\n   .ctrl_xx_ex3_warm_up           ( 1'b0               ),\n   .dp_xx_ex1_cnan                ( dp_xx_ex1_cnan     ),  // Special input type determination\n   .dp_xx_ex1_id                  ( dp_xx_ex1_id       ),\n   .dp_xx_ex1_inf                 ( dp_xx_ex1_inf      ),\n   .dp_xx_ex1_qnan                ( dp_xx_ex1_qnan     ),\n   .dp_xx_ex1_rm                  ( rnd_mode_q         ),  // rounding mode\n   .dp_xx_ex1_snan                ( dp_xx_ex1_snan     ),\n   .dp_xx_ex1_zero                ( dp_xx_ex1_zero     ),\n   .fdsu_fpu_debug_info           (                    ),  // output, not used\n   .fdsu_fpu_ex1_cmplt            ( fdsu_fpu_ex1_cmplt ),  // output, ctrl_xx_ex1_cmplt_dp && idu_fpu_ex1_eu_sel_i[2]\n   .fdsu_fpu_ex1_cmplt_dp         (                    ),  // output, not used\n   .fdsu_fpu_ex1_fflags           ( fdsu_fpu_ex1_fflags       ),  // output, special case fflags\n   .fdsu_fpu_ex1_special_sel      ( fdsu_fpu_ex1_special_sel  ),  // output, special case type selection\n   .fdsu_fpu_ex1_special_sign     ( fdsu_fpu_ex1_special_sign ),  // output, special case sign determination\n   .fdsu_fpu_ex1_stall            ( fdsu_fpu_ex1_stall        ),  // output, determine whether stall in ex1\n   .fdsu_fpu_no_op                ( fdsu_fpu_no_op            ),  // output, if Write Back SM and fdsu SM no operation, fdsu_fpu_no_op = 1; Otherwise if busy, fdsu_fpu_no_op = 0. (not used)\n   .fdsu_frbus_data               ( fdsu_frbus_data           ),  // output, normal case result\n   .fdsu_frbus_fflags             ( fdsu_frbus_fflags         ),  // output, normal case fflags\n   .fdsu_frbus_freg               (                           ),  // output, determined by input idu_fpu_ex1_dst_freg\n   .fdsu_frbus_wb_vld             ( fdsu_frbus_wb_vld         ),  // output, determine whether write back valid\n   .forever_cpuclk                ( clk_i                     ),\n   .frbus_fdsu_wb_grant           ( fdsu_frbus_wb_vld         ),  // input is fdsu_frbus_wb_vld\n   .idu_fpu_ex1_dst_freg          ( 5'h0f                     ),  // register index to write back (not used)\n   .idu_fpu_ex1_eu_sel            ( idu_fpu_ex1_eu_sel        ),  // time to select operands\n   .idu_fpu_ex1_func              ( {8'b0, div_op | div_op_q, sqrt_op | sqrt_op_q} ),\n   .idu_fpu_ex1_srcf0             ( operands_q[0][31:0]       ),  // the first operand\n   .idu_fpu_ex1_srcf1             ( operands_q[1][31:0]       ),  // the second operand\n   .pad_yy_icg_scan_en            ( 1'b0                      ),  // input of core_top, set to 1'b0 from the beginning to end\n   .rtu_xx_ex1_cancel             ( 1'b0                      ),\n   .rtu_xx_ex2_cancel             ( 1'b0                      ),\n   .rtu_yy_xx_async_flush         ( flush_i                   ),\n   .rtu_yy_xx_flush               ( 1'b0                      )\n  );\n\n  pa_fpu_dp  x_pa_fpu_dp (\n    .cp0_fpu_icg_en              ( 1'b0                       ),\n    .cp0_fpu_xx_rm               ( rnd_mode_q                 ),\n    .cp0_yy_clk_en               ( 1'b1                       ),\n    .ctrl_xx_ex1_inst_vld        ( ctrl_fdsu_ex1_sel          ),\n    .ctrl_xx_ex1_stall           ( 1'b0                       ),\n    .ctrl_xx_ex1_warm_up         ( 1'b0                       ),\n    .dp_frbus_ex2_data           ( dp_frbus_ex2_data          ),  // output\n    .dp_frbus_ex2_fflags         ( dp_frbus_ex2_fflags        ),  // output\n    .dp_xx_ex1_cnan              ( dp_xx_ex1_cnan             ),  // output\n    .dp_xx_ex1_id                ( dp_xx_ex1_id               ),  // output\n    .dp_xx_ex1_inf               ( dp_xx_ex1_inf              ),  // output\n    .dp_xx_ex1_norm              ( dp_xx_ex1_norm             ),  // output\n    .dp_xx_ex1_qnan              ( dp_xx_ex1_qnan             ),  // output\n    .dp_xx_ex1_snan              ( dp_xx_ex1_snan             ),  // output\n    .dp_xx_ex1_zero              ( dp_xx_ex1_zero             ),  // output\n    .ex2_inst_wb                 ( ex2_inst_wb                ),  // output\n    .fdsu_fpu_ex1_fflags         ( fdsu_fpu_ex1_fflags        ),\n    .fdsu_fpu_ex1_special_sel    ( fdsu_fpu_ex1_special_sel   ),\n    .fdsu_fpu_ex1_special_sign   ( fdsu_fpu_ex1_special_sign  ),\n    .forever_cpuclk              ( clk_i                      ),\n    .idu_fpu_ex1_eu_sel          ( idu_fpu_ex1_eu_sel         ),\n    .idu_fpu_ex1_func            ( {8'b0, div_op, sqrt_op}    ),\n    .idu_fpu_ex1_gateclk_vld     ( fdsu_fpu_ex1_cmplt         ),\n    .idu_fpu_ex1_rm              ( rnd_mode_q                 ),\n    .idu_fpu_ex1_srcf0           ( operands_q[0][31:0]        ),\n    .idu_fpu_ex1_srcf1           ( operands_q[1][31:0]        ),\n    .idu_fpu_ex1_srcf2           ( '0                         ),\n    .pad_yy_icg_scan_en          ( 1'b0                       )\n  );\n\n  assign ex2_inst_wb_vld_d = ctrl_fdsu_ex1_sel;\n  `FF(ex2_inst_wb_vld_q, ex2_inst_wb_vld_d, '0)\n\n  pa_fpu_frbus x_pa_fpu_frbus (\n    .ctrl_frbus_ex2_wb_req     ( ex2_inst_wb & ex2_inst_wb_vld_q ),\n    .dp_frbus_ex2_data         ( dp_frbus_ex2_data   ),\n    .dp_frbus_ex2_fflags       ( dp_frbus_ex2_fflags ),\n    .fdsu_frbus_data           ( fdsu_frbus_data     ),\n    .fdsu_frbus_fflags         ( fdsu_frbus_fflags   ),\n    .fdsu_frbus_wb_vld         ( fdsu_frbus_wb_vld   ),\n    .fpu_idu_fwd_data          ( fpu_idu_fwd_data    ),  // output\n    .fpu_idu_fwd_fflags        ( fpu_idu_fwd_fflags  ),  // output\n    .fpu_idu_fwd_vld           ( fpu_idu_fwd_vld     )   // output\n  );\n\n  always_comb begin\n    unit_result[31:0] = fpu_idu_fwd_data[31:0];\n    unit_status[4:0]  = fpu_idu_fwd_fflags[4:0];\n    unit_done         = fpu_idu_fwd_vld;\n  end\n\n  // The Hold register (load, no reset)\n  `FFLNR(held_result_q, unit_result, hold_result, clk_i)\n  `FFLNR(held_status_q, unit_status, hold_result, clk_i)\n\n  // --------------\n  // Output Select\n  // --------------\n  logic [WIDTH-1:0]   result_d;\n  fpnew_pkg::status_t status_d;\n  // Prioritize hold register data\n  assign result_d = data_is_held ? held_result_q : unit_result;\n  assign status_d = data_is_held ? held_status_q : unit_status;\n\n  // ----------------\n  // Output Pipeline\n  // ----------------\n  // Output pipeline signals, index i holds signal after i register stages\n  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;\n  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;\n  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;\n  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;\n  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;\n  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;\n  // Ready signal is combinatorial for all stages\n  logic [0:NUM_OUT_REGS] out_pipe_ready;\n\n  // Input stage: First element of pipeline is taken from inputs\n  assign out_pipe_result_q[0] = result_d;\n  assign out_pipe_status_q[0] = status_d;\n  assign out_pipe_tag_q[0]    = result_tag_q;\n  assign out_pipe_mask_q[0]   = result_mask_q;\n  assign out_pipe_aux_q[0]    = result_aux_q;\n  assign out_pipe_valid_q[0]  = out_valid;\n  // Input stage: Propagate pipeline ready signal to inside pipe\n  assign out_ready = out_pipe_ready[0];\n  // Generate the register stages\n  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline\n    // Internal register enable for this stage\n    logic reg_ena;\n    // Determine the ready signal of the current stage - advance the pipeline:\n    // 1. if the next stage is ready for our data\n    // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];\n    // Valid: enabled by ready signal, synchronous clear with the flush signal\n    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n    // Enable register if pipleine ready and a valid data item is present\n    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];\n    // Generate the pipeline registers within the stages, use enable-registers\n    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)\n    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)\n    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))\n    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)\n    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))\n  end\n  // Output stage: Ready travels backwards from output side, driven by downstream circuitry\n  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;\n  // Output stage: assign module outputs\n  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];\n  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];\n  assign extension_bit_o = 1'b1; // always NaN-Box result\n  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];\n  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];\n  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];\n  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];\n  assign busy_o          = (| {inp_pipe_valid_q, unit_busy, out_pipe_valid_q});\nendmodule\n","lang":"verilog"};
processSrcData(g_data);