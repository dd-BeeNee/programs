var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/src/fpnew_fma_multi.sv","src":"// Copyright 2019 ETH Zurich and University of Bologna.\n//\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// SPDX-License-Identifier: SHL-0.51\n\n// Author: Stefan Mach <smach@iis.ee.ethz.ch>\n\n`include \"common_cells/registers.svh\"\n\nmodule fpnew_fma_multi #(\n  parameter fpnew_pkg::fmt_logic_t   FpFmtConfig = '1,\n  parameter int unsigned             NumPipeRegs = 0,\n  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,\n  parameter type                     TagType     = logic,\n  parameter type                     AuxType     = logic,\n  // Do not change\n  localparam int unsigned WIDTH       = fpnew_pkg::max_fp_width(FpFmtConfig),\n  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,\n  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs\n) (\n  input  logic                        clk_i,\n  input  logic                        rst_ni,\n  // Input signals\n  input  logic [2:0][WIDTH-1:0]       operands_i, // 3 operands\n  input  logic [NUM_FORMATS-1:0][2:0] is_boxed_i, // 3 operands\n  input  fpnew_pkg::roundmode_e       rnd_mode_i,\n  input  fpnew_pkg::operation_e       op_i,\n  input  logic                        op_mod_i,\n  input  fpnew_pkg::fp_format_e       src_fmt_i, // format of the multiplicands\n  input  fpnew_pkg::fp_format_e       dst_fmt_i, // format of the addend and result\n  input  TagType                      tag_i,\n  input  logic                        mask_i,\n  input  AuxType                      aux_i,\n  // Input Handshake\n  input  logic                        in_valid_i,\n  output logic                        in_ready_o,\n  input  logic                        flush_i,\n  // Output signals\n  output logic [WIDTH-1:0]            result_o,\n  output fpnew_pkg::status_t          status_o,\n  output logic                        extension_bit_o,\n  output TagType                      tag_o,\n  output logic                        mask_o,\n  output AuxType                      aux_o,\n  // Output handshake\n  output logic                        out_valid_o,\n  input  logic                        out_ready_i,\n  // Indication of valid data in flight\n  output logic                        busy_o,\n  // External register enable override\n  input  logic [ExtRegEnaWidth-1:0]   reg_ena_i\n);\n\n  // ----------\n  // Constants\n  // ----------\n  // The super-format that can hold all formats\n  localparam fpnew_pkg::fp_encoding_t SUPER_FORMAT = fpnew_pkg::super_format(FpFmtConfig);\n\n  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;\n  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;\n\n  // Precision bits 'p' include the implicit bit\n  localparam int unsigned PRECISION_BITS = SUPER_MAN_BITS + 1;\n  // The lower 2p+3 bits of the internal FMA result will be needed for leading-zero detection\n  localparam int unsigned LOWER_SUM_WIDTH  = 2 * PRECISION_BITS + 3;\n  localparam int unsigned LZC_RESULT_WIDTH = $clog2(LOWER_SUM_WIDTH);\n  // Internal exponent width of FMA must accomodate all meaningful exponent values in order to avoid\n  // datapath leakage. This is either given by the exponent bits or the width of the LZC result.\n  // In most reasonable FP formats the internal exponent will be wider than the LZC result.\n  localparam int unsigned EXP_WIDTH = fpnew_pkg::maximum(SUPER_EXP_BITS + 2, LZC_RESULT_WIDTH);\n  // Shift amount width: maximum internal mantissa size is 3p+4 bits\n  localparam int unsigned SHIFT_AMOUNT_WIDTH = $clog2(3 * PRECISION_BITS + 5);\n  // Pipelines\n  localparam NUM_INP_REGS = PipeConfig == fpnew_pkg::BEFORE\n                            ? NumPipeRegs\n                            : (PipeConfig == fpnew_pkg::DISTRIBUTED\n                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs\n                               : 0); // no regs here otherwise\n  localparam NUM_MID_REGS = PipeConfig == fpnew_pkg::INSIDE\n                          ? NumPipeRegs\n                          : (PipeConfig == fpnew_pkg::DISTRIBUTED\n                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs\n                             : 0); // no regs here otherwise\n  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER\n                            ? NumPipeRegs\n                            : (PipeConfig == fpnew_pkg::DISTRIBUTED\n                               ? (NumPipeRegs / 3) // Last to get distributed regs\n                               : 0); // no regs here otherwise\n\n  // ----------------\n  // Type definition\n  // ----------------\n  typedef struct packed {\n    logic                      sign;\n    logic [SUPER_EXP_BITS-1:0] exponent;\n    logic [SUPER_MAN_BITS-1:0] mantissa;\n  } fp_t;\n\n  // ---------------\n  // Input pipeline\n  // ---------------\n  // Selected pipeline output signals as non-arrays\n  logic [2:0][WIDTH-1:0] operands_q;\n  fpnew_pkg::fp_format_e src_fmt_q;\n  fpnew_pkg::fp_format_e dst_fmt_q;\n\n  // Input pipeline signals, index i holds signal after i register stages\n  logic                  [0:NUM_INP_REGS][2:0][WIDTH-1:0]       inp_pipe_operands_q;\n  logic                  [0:NUM_INP_REGS][NUM_FORMATS-1:0][2:0] inp_pipe_is_boxed_q;\n  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;\n  fpnew_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;\n  logic                  [0:NUM_INP_REGS]                       inp_pipe_op_mod_q;\n  fpnew_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_src_fmt_q;\n  fpnew_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_dst_fmt_q;\n  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;\n  logic                  [0:NUM_INP_REGS]                       inp_pipe_mask_q;\n  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;\n  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;\n  // Ready signal is combinatorial for all stages\n  logic [0:NUM_INP_REGS] inp_pipe_ready;\n\n  // Input stage: First element of pipeline is taken from inputs\n  assign inp_pipe_operands_q[0] = operands_i;\n  assign inp_pipe_is_boxed_q[0] = is_boxed_i;\n  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;\n  assign inp_pipe_op_q[0]       = op_i;\n  assign inp_pipe_op_mod_q[0]   = op_mod_i;\n  assign inp_pipe_src_fmt_q[0]  = src_fmt_i;\n  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;\n  assign inp_pipe_tag_q[0]      = tag_i;\n  assign inp_pipe_mask_q[0]     = mask_i;\n  assign inp_pipe_aux_q[0]      = aux_i;\n  assign inp_pipe_valid_q[0]    = in_valid_i;\n  // Input stage: Propagate pipeline ready signal to updtream circuitry\n  assign in_ready_o = inp_pipe_ready[0];\n  // Generate the register stages\n  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline\n    // Internal register enable for this stage\n    logic reg_ena;\n    // Determine the ready signal of the current stage - advance the pipeline:\n    // 1. if the next stage is ready for our data\n    // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];\n    // Valid: enabled by ready signal, synchronous clear with the flush signal\n    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n    // Enable register if pipleine ready and a valid data item is present\n    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];\n    // Generate the pipeline registers within the stages, use enable-registers\n    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)\n    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)\n    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)\n    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)\n    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)\n    `FFL(inp_pipe_src_fmt_q[i+1],  inp_pipe_src_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))\n    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))\n    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))\n    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)\n    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))\n  end\n  // Output stage: assign selected pipe outputs to signals for later use\n  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];\n  assign src_fmt_q  = inp_pipe_src_fmt_q[NUM_INP_REGS];\n  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];\n\n  // -----------------\n  // Input processing\n  // -----------------\n  logic        [NUM_FORMATS-1:0][2:0]                     fmt_sign;\n  logic signed [NUM_FORMATS-1:0][2:0][SUPER_EXP_BITS-1:0] fmt_exponent;\n  logic        [NUM_FORMATS-1:0][2:0][SUPER_MAN_BITS-1:0] fmt_mantissa;\n\n  fpnew_pkg::fp_info_t [NUM_FORMATS-1:0][2:0] info_q;\n\n  // FP Input initialization\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_init_inputs\n    // Set up some constants\n    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));\n\n    if (FpFmtConfig[fmt]) begin : active_format\n      logic [2:0][FP_WIDTH-1:0] trimmed_ops;\n\n      // Classify input\n      fpnew_classifier #(\n        .FpFormat    ( fpnew_pkg::fp_format_e'(fmt) ),\n        .NumOperands ( 3                            )\n      ) i_fpnew_classifier (\n        .operands_i ( trimmed_ops                            ),\n        .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS][fmt] ),\n        .info_o     ( info_q[fmt]                            )\n      );\n      for (genvar op = 0; op < 3; op++) begin : gen_operands\n        assign trimmed_ops[op]       = operands_q[op][FP_WIDTH-1:0];\n        assign fmt_sign[fmt][op]     = operands_q[op][FP_WIDTH-1];\n        assign fmt_exponent[fmt][op] = signed'({1'b0, operands_q[op][MAN_BITS+:EXP_BITS]});\n        assign fmt_mantissa[fmt][op] = {info_q[fmt][op].is_normal, operands_q[op][MAN_BITS-1:0]} <<\n                                       (SUPER_MAN_BITS - MAN_BITS); // move to left of mantissa\n      end\n    end else begin : inactive_format\n      assign info_q[fmt]                 = '{default: fpnew_pkg::DONT_CARE}; // format disabled\n      assign fmt_sign[fmt]               = fpnew_pkg::DONT_CARE;             // format disabled\n      assign fmt_exponent[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled\n      assign fmt_mantissa[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled\n    end\n  end\n\n  fp_t                 operand_a, operand_b, operand_c;\n  fpnew_pkg::fp_info_t info_a,    info_b,    info_c;\n\n  // Operation selection and operand adjustment\n  // | \\c op_q  | \\c op_mod_q | Operation Adjustment\n  // |:--------:|:-----------:|---------------------\n  // | FMADD    | \\c 0        | FMADD: none\n  // | FMADD    | \\c 1        | FMSUB: Invert sign of operand C\n  // | FNMSUB   | \\c 0        | FNMSUB: Invert sign of operand A\n  // | FNMSUB   | \\c 1        | FNMADD: Invert sign of operands A and C\n  // | ADD      | \\c 0        | ADD: Set operand A to +1.0\n  // | ADD      | \\c 1        | SUB: Set operand A to +1.0, invert sign of operand C\n  // | MUL      | \\c 0        | MUL: Set operand C to +0.0 or -0.0 depending on the rounding mode\n  // | *others* | \\c -        | *invalid*\n  // \\note \\c op_mod_q always inverts the sign of the addend.\n  always_comb begin : op_select\n\n    // Default assignments - packing-order-agnostic\n    operand_a = {fmt_sign[src_fmt_q][0], fmt_exponent[src_fmt_q][0], fmt_mantissa[src_fmt_q][0]};\n    operand_b = {fmt_sign[src_fmt_q][1], fmt_exponent[src_fmt_q][1], fmt_mantissa[src_fmt_q][1]};\n    operand_c = {fmt_sign[dst_fmt_q][2], fmt_exponent[dst_fmt_q][2], fmt_mantissa[dst_fmt_q][2]};\n    info_a    = info_q[src_fmt_q][0];\n    info_b    = info_q[src_fmt_q][1];\n    info_c    = info_q[dst_fmt_q][2];\n\n    // op_mod_q inverts sign of operand C\n    operand_c.sign = operand_c.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];\n\n    unique case (inp_pipe_op_q[NUM_INP_REGS])\n      fpnew_pkg::FMADD:  ; // do nothing\n      fpnew_pkg::FNMSUB: operand_a.sign = ~operand_a.sign; // invert sign of product\n      fpnew_pkg::ADD: begin // Set multiplicand to +1\n        operand_a = '{sign: 1'b0, exponent: fpnew_pkg::bias(src_fmt_q), mantissa: '0};\n        info_a    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.\n      end\n      fpnew_pkg::MUL: begin // Set addend to +0 or -0, depending whether the rounding mode is RDN\n        if (inp_pipe_rnd_mode_q[NUM_INP_REGS] == fpnew_pkg::RDN)\n          operand_c = '{sign: 1'b0, exponent: '0, mantissa: '0};\n        else\n          operand_c = '{sign: 1'b1, exponent: '0, mantissa: '0};\n        info_c    = '{is_zero: 1'b1, is_boxed: 1'b1, default: 1'b0}; //zero, boxed value.\n      end\n      default: begin // propagate don't cares\n        operand_a  = '{default: fpnew_pkg::DONT_CARE};\n        operand_b  = '{default: fpnew_pkg::DONT_CARE};\n        operand_c  = '{default: fpnew_pkg::DONT_CARE};\n        info_a     = '{default: fpnew_pkg::DONT_CARE};\n        info_b     = '{default: fpnew_pkg::DONT_CARE};\n        info_c     = '{default: fpnew_pkg::DONT_CARE};\n      end\n    endcase\n  end\n\n  // ---------------------\n  // Input classification\n  // ---------------------\n  logic any_operand_inf;\n  logic any_operand_nan;\n  logic signalling_nan;\n  logic effective_subtraction;\n  logic tentative_sign;\n\n  // Reduction for special case handling\n  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf,        info_c.is_inf});\n  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan,        info_c.is_nan});\n  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling, info_c.is_signalling});\n  // Effective subtraction in FMA occurs when product and addend signs differ\n  assign effective_subtraction = operand_a.sign ^ operand_b.sign ^ operand_c.sign;\n  // The tentative sign of the FMA shall be the sign of the product\n  assign tentative_sign = operand_a.sign ^ operand_b.sign;\n\n  // ----------------------\n  // Special case handling\n  // ----------------------\n  logic [WIDTH-1:0]   special_result;\n  fpnew_pkg::status_t special_status;\n  logic               result_is_special;\n\n  logic [NUM_FORMATS-1:0][WIDTH-1:0]    fmt_special_result;\n  fpnew_pkg::status_t [NUM_FORMATS-1:0] fmt_special_status;\n  logic [NUM_FORMATS-1:0]               fmt_result_is_special;\n\n\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results\n    // Set up some constants\n    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));\n\n    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;\n    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);\n    localparam logic [MAN_BITS-1:0] ZERO_MANTISSA = '0;\n\n    if (FpFmtConfig[fmt]) begin : active_format\n      always_comb begin : special_results\n        logic [FP_WIDTH-1:0] special_res;\n\n        // Default assignment\n        special_res                = {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN\n        fmt_special_status[fmt]    = '0;\n        fmt_result_is_special[fmt] = 1'b0;\n\n        // Handle potentially mixed nan & infinity input => important for the case where infinity and\n        // zero are multiplied and added to a qnan.\n        // RISC-V mandates raising the NV exception in these cases:\n        // (inf * 0) + c or (0 * inf) + c INVALID, no matter c (even quiet NaNs)\n        if ((info_a.is_inf && info_b.is_zero) || (info_a.is_zero && info_b.is_inf)) begin\n          fmt_result_is_special[fmt] = 1'b1; // bypass FMA, output is the canonical qNaN\n          fmt_special_status[fmt].NV = 1'b1; // invalid operation\n        // NaN Inputs cause canonical quiet NaN at the output and maybe invalid OP\n        end else if (any_operand_nan) begin\n          fmt_result_is_special[fmt] = 1'b1;           // bypass FMA, output is the canonical qNaN\n          fmt_special_status[fmt].NV = signalling_nan; // raise the invalid operation flag if signalling\n        // Special cases involving infinity\n        end else if (any_operand_inf) begin\n          fmt_result_is_special[fmt] = 1'b1; // bypass FMA\n          // Effective addition of opposite infinities (±inf - ±inf) is invalid!\n          if ((info_a.is_inf || info_b.is_inf) && info_c.is_inf && effective_subtraction)\n            fmt_special_status[fmt].NV = 1'b1; // invalid operation\n          // Handle cases where output will be inf because of inf product input\n          else if (info_a.is_inf || info_b.is_inf) begin\n            // Result is infinity with the sign of the product\n            special_res = {operand_a.sign ^ operand_b.sign, QNAN_EXPONENT, ZERO_MANTISSA};\n          // Handle cases where the addend is inf\n          end else if (info_c.is_inf) begin\n            // Result is inifinity with sign of the addend (= operand_c)\n            special_res = {operand_c.sign, QNAN_EXPONENT, ZERO_MANTISSA};\n          end\n        end\n        // Initialize special result with ones (NaN-box)\n        fmt_special_result[fmt]               = '1;\n        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;\n      end\n    end else begin : inactive_format\n      assign fmt_special_result[fmt] = '{default: fpnew_pkg::DONT_CARE};\n      assign fmt_special_status[fmt] = '0;\n      assign fmt_result_is_special[fmt] = 1'b0;\n    end\n  end\n\n  // Detect special case from source format, I2F casts don't produce a special result\n  assign result_is_special = fmt_result_is_special[dst_fmt_q]; // they're all the same\n  // Signalling input NaNs raise invalid flag, otherwise no flags set\n  assign special_status = fmt_special_status[dst_fmt_q];\n  // Assemble result according to destination format\n  assign special_result = fmt_special_result[dst_fmt_q]; // destination format\n\n  // ---------------------------\n  // Initial exponent data path\n  // ---------------------------\n  logic signed [EXP_WIDTH-1:0] exponent_a, exponent_b, exponent_c;\n  logic signed [EXP_WIDTH-1:0] exponent_addend, exponent_product, exponent_difference;\n  logic signed [EXP_WIDTH-1:0] tentative_exponent;\n\n  // Zero-extend exponents into signed container - implicit width extension\n  assign exponent_a = signed'({1'b0, operand_a.exponent});\n  assign exponent_b = signed'({1'b0, operand_b.exponent});\n  assign exponent_c = signed'({1'b0, operand_c.exponent});\n\n  // Calculate internal exponents from encoded values. Real exponents are (ex = Ex - bias + 1 - nx)\n  // with Ex the encoded exponent and nx the implicit bit. Internal exponents are biased to dst fmt.\n  assign exponent_addend = signed'(exponent_c + $signed({1'b0, ~info_c.is_normal})); // 0 as subnorm\n  // Biased product exponent is the sum of encoded exponents minus the bias.\n  assign exponent_product = (info_a.is_zero || info_b.is_zero) // in case the product is zero, set minimum exp.\n                            ? 2 - signed'(fpnew_pkg::bias(dst_fmt_q))\n                            : signed'(exponent_a + info_a.is_subnormal\n                                      + exponent_b + info_b.is_subnormal\n                                      - 2*signed'(fpnew_pkg::bias(src_fmt_q))\n                                      + signed'(fpnew_pkg::bias(dst_fmt_q))); // rebias for dst fmt\n  // Exponent difference is the addend exponent minus the product exponent\n  assign exponent_difference = exponent_addend - exponent_product;\n  // The tentative exponent will be the larger of the product or addend exponent\n  assign tentative_exponent = (exponent_difference > 0) ? exponent_addend : exponent_product;\n\n  // Shift amount for addend based on exponents (unsigned as only right shifts)\n  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt;\n\n  always_comb begin : addend_shift_amount\n    // Product-anchored case, saturated shift (addend is only in the sticky bit)\n    if (exponent_difference <= signed'(-2 * PRECISION_BITS - 1))\n      addend_shamt = 3 * PRECISION_BITS + 4;\n    // Addend and product will have mutual bits to add\n    else if (exponent_difference <= signed'(PRECISION_BITS + 2))\n      addend_shamt = unsigned'(signed'(PRECISION_BITS) + 3 - exponent_difference);\n    // Addend-anchored case, saturated shift (product is only in the sticky bit)\n    else\n      addend_shamt = 0;\n  end\n\n  // ------------------\n  // Product data path\n  // ------------------\n  logic [PRECISION_BITS-1:0]   mantissa_a, mantissa_b, mantissa_c;\n  logic [2*PRECISION_BITS-1:0] product;             // the p*p product is 2p bits wide\n  logic [3*PRECISION_BITS+3:0] product_shifted;     // addends are 3p+4 bit wide (including G/R)\n\n  // Add implicit bits to mantissae\n  assign mantissa_a = {info_a.is_normal, operand_a.mantissa};\n  assign mantissa_b = {info_b.is_normal, operand_b.mantissa};\n  assign mantissa_c = {info_c.is_normal, operand_c.mantissa};\n\n  // Mantissa multiplier (a*b)\n  assign product = mantissa_a * mantissa_b;\n\n  // Product is placed into a 3p+4 bit wide vector, padded with 2 bits for round and sticky:\n  // | 000...000 | product | RS |\n  //  <-  p+2  -> <-  2p -> < 2>\n  assign product_shifted = product << 2; // constant shift\n\n  // -----------------\n  // Addend data path\n  // -----------------\n  logic [3*PRECISION_BITS+3:0] addend_after_shift;  // upper 3p+4 bits are needed to go on\n  logic [PRECISION_BITS-1:0]   addend_sticky_bits;  // up to p bit of shifted addend are sticky\n  logic                        sticky_before_add;   // they are compressed into a single sticky bit\n  logic [3*PRECISION_BITS+3:0] addend_shifted;      // addends are 3p+4 bit wide (including G/R)\n  logic                        inject_carry_in;     // inject carry for subtractions if needed\n\n  // In parallel, the addend is right-shifted according to the exponent difference. Up to p bits are\n  // shifted out and compressed into a sticky bit.\n  // BEFORE THE SHIFT:\n  // | mantissa_c | 000..000 |\n  //  <-    p   -> <- 3p+4 ->\n  // AFTER THE SHIFT:\n  // | 000..........000 | mantissa_c | 000...............0GR |  sticky bits  |\n  //  <- addend_shamt -> <-    p   -> <- 2p+4-addend_shamt -> <-  up to p  ->\n  assign {addend_after_shift, addend_sticky_bits} =\n      (mantissa_c << (3 * PRECISION_BITS + 4)) >> addend_shamt;\n\n  assign sticky_before_add     = (| addend_sticky_bits);\n\n  // In case of a subtraction, the addend is inverted\n  assign addend_shifted = (effective_subtraction) ? ~addend_after_shift : addend_after_shift;\n  assign inject_carry_in = effective_subtraction & ~sticky_before_add;\n\n  // ------\n  // Adder\n  // ------\n  logic [3*PRECISION_BITS+4:0] sum_raw;   // added one bit for the carry\n  logic                        sum_carry; // observe carry bit from sum for sign fixing\n  logic [3*PRECISION_BITS+3:0] sum;       // discard carry as sum won't overflow\n  logic                        final_sign;\n\n  //Mantissa adder (ab+c). In normal addition, it cannot overflow.\n  assign sum_raw = product_shifted + addend_shifted + inject_carry_in;\n  assign sum_carry = sum_raw[3*PRECISION_BITS+4];\n\n  // Complement negative sum (can only happen in subtraction -> overflows for positive results)\n  assign sum        = (effective_subtraction && ~sum_carry) ? -sum_raw : sum_raw;\n\n  // In case of a mispredicted subtraction result, do a sign flip\n  assign final_sign = (effective_subtraction && (sum_carry == tentative_sign))\n                      ? 1'b1\n                      : (effective_subtraction ? 1'b0 : tentative_sign);\n\n  // ---------------\n  // Internal pipeline\n  // ---------------\n  // Pipeline output signals as non-arrays\n  logic                          effective_subtraction_q;\n  logic signed [EXP_WIDTH-1:0]   exponent_product_q;\n  logic signed [EXP_WIDTH-1:0]   exponent_difference_q;\n  logic signed [EXP_WIDTH-1:0]   tentative_exponent_q;\n  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt_q;\n  logic                          sticky_before_add_q;\n  logic [3*PRECISION_BITS+3:0]   sum_q;\n  logic                          final_sign_q;\n  fpnew_pkg::fp_format_e         dst_fmt_q2;\n  fpnew_pkg::roundmode_e         rnd_mode_q;\n  logic                          result_is_special_q;\n  fp_t                           special_result_q;\n  fpnew_pkg::status_t            special_status_q;\n  // Internal pipeline signals, index i holds signal after i register stages\n  logic                  [0:NUM_MID_REGS]                         mid_pipe_eff_sub_q;\n  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_prod_q;\n  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_diff_q;\n  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_tent_exp_q;\n  logic                  [0:NUM_MID_REGS][SHIFT_AMOUNT_WIDTH-1:0] mid_pipe_add_shamt_q;\n  logic                  [0:NUM_MID_REGS]                         mid_pipe_sticky_q;\n  logic                  [0:NUM_MID_REGS][3*PRECISION_BITS+3:0]   mid_pipe_sum_q;\n  logic                  [0:NUM_MID_REGS]                         mid_pipe_final_sign_q;\n  fpnew_pkg::roundmode_e [0:NUM_MID_REGS]                         mid_pipe_rnd_mode_q;\n  fpnew_pkg::fp_format_e [0:NUM_MID_REGS]                         mid_pipe_dst_fmt_q;\n  logic                  [0:NUM_MID_REGS]                         mid_pipe_res_is_spec_q;\n  fp_t                   [0:NUM_MID_REGS]                         mid_pipe_spec_res_q;\n  fpnew_pkg::status_t    [0:NUM_MID_REGS]                         mid_pipe_spec_stat_q;\n  TagType                [0:NUM_MID_REGS]                         mid_pipe_tag_q;\n  logic                  [0:NUM_MID_REGS]                         mid_pipe_mask_q;\n  AuxType                [0:NUM_MID_REGS]                         mid_pipe_aux_q;\n  logic                  [0:NUM_MID_REGS]                         mid_pipe_valid_q;\n  // Ready signal is combinatorial for all stages\n  logic [0:NUM_MID_REGS] mid_pipe_ready;\n\n  // Input stage: First element of pipeline is taken from upstream logic\n  assign mid_pipe_eff_sub_q[0]     = effective_subtraction;\n  assign mid_pipe_exp_prod_q[0]    = exponent_product;\n  assign mid_pipe_exp_diff_q[0]    = exponent_difference;\n  assign mid_pipe_tent_exp_q[0]    = tentative_exponent;\n  assign mid_pipe_add_shamt_q[0]   = addend_shamt;\n  assign mid_pipe_sticky_q[0]      = sticky_before_add;\n  assign mid_pipe_sum_q[0]         = sum;\n  assign mid_pipe_final_sign_q[0]  = final_sign;\n  assign mid_pipe_rnd_mode_q[0]    = inp_pipe_rnd_mode_q[NUM_INP_REGS];\n  assign mid_pipe_dst_fmt_q[0]     = dst_fmt_q;\n  assign mid_pipe_res_is_spec_q[0] = result_is_special;\n  assign mid_pipe_spec_res_q[0]    = special_result;\n  assign mid_pipe_spec_stat_q[0]   = special_status;\n  assign mid_pipe_tag_q[0]         = inp_pipe_tag_q[NUM_INP_REGS];\n  assign mid_pipe_mask_q[0]        = inp_pipe_mask_q[NUM_INP_REGS];\n  assign mid_pipe_aux_q[0]         = inp_pipe_aux_q[NUM_INP_REGS];\n  assign mid_pipe_valid_q[0]       = inp_pipe_valid_q[NUM_INP_REGS];\n  // Input stage: Propagate pipeline ready signal to input pipe\n  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];\n\n  // Generate the register stages\n  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline\n    // Internal register enable for this stage\n    logic reg_ena;\n    // Determine the ready signal of the current stage - advance the pipeline:\n    // 1. if the next stage is ready for our data\n    // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];\n    // Valid: enabled by ready signal, synchronous clear with the flush signal\n    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n    // Enable register if pipleine ready and a valid data item is present\n    assign reg_ena = (mid_pipe_ready[i] & mid_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];\n    // Generate the pipeline registers within the stages, use enable-registers\n    `FFL(mid_pipe_eff_sub_q[i+1],     mid_pipe_eff_sub_q[i],     reg_ena, '0)\n    `FFL(mid_pipe_exp_prod_q[i+1],    mid_pipe_exp_prod_q[i],    reg_ena, '0)\n    `FFL(mid_pipe_exp_diff_q[i+1],    mid_pipe_exp_diff_q[i],    reg_ena, '0)\n    `FFL(mid_pipe_tent_exp_q[i+1],    mid_pipe_tent_exp_q[i],    reg_ena, '0)\n    `FFL(mid_pipe_add_shamt_q[i+1],   mid_pipe_add_shamt_q[i],   reg_ena, '0)\n    `FFL(mid_pipe_sticky_q[i+1],      mid_pipe_sticky_q[i],      reg_ena, '0)\n    `FFL(mid_pipe_sum_q[i+1],         mid_pipe_sum_q[i],         reg_ena, '0)\n    `FFL(mid_pipe_final_sign_q[i+1],  mid_pipe_final_sign_q[i],  reg_ena, '0)\n    `FFL(mid_pipe_rnd_mode_q[i+1],    mid_pipe_rnd_mode_q[i],    reg_ena, fpnew_pkg::RNE)\n    `FFL(mid_pipe_dst_fmt_q[i+1],     mid_pipe_dst_fmt_q[i],     reg_ena, fpnew_pkg::fp_format_e'(0))\n    `FFL(mid_pipe_res_is_spec_q[i+1], mid_pipe_res_is_spec_q[i], reg_ena, '0)\n    `FFL(mid_pipe_spec_res_q[i+1],    mid_pipe_spec_res_q[i],    reg_ena, '0)\n    `FFL(mid_pipe_spec_stat_q[i+1],   mid_pipe_spec_stat_q[i],   reg_ena, '0)\n    `FFL(mid_pipe_tag_q[i+1],         mid_pipe_tag_q[i],         reg_ena, TagType'('0))\n    `FFL(mid_pipe_mask_q[i+1],        mid_pipe_mask_q[i],        reg_ena, '0)\n    `FFL(mid_pipe_aux_q[i+1],         mid_pipe_aux_q[i],         reg_ena, AuxType'('0))\n  end\n  // Output stage: assign selected pipe outputs to signals for later use\n  assign effective_subtraction_q = mid_pipe_eff_sub_q[NUM_MID_REGS];\n  assign exponent_product_q      = mid_pipe_exp_prod_q[NUM_MID_REGS];\n  assign exponent_difference_q   = mid_pipe_exp_diff_q[NUM_MID_REGS];\n  assign tentative_exponent_q    = mid_pipe_tent_exp_q[NUM_MID_REGS];\n  assign addend_shamt_q          = mid_pipe_add_shamt_q[NUM_MID_REGS];\n  assign sticky_before_add_q     = mid_pipe_sticky_q[NUM_MID_REGS];\n  assign sum_q                   = mid_pipe_sum_q[NUM_MID_REGS];\n  assign final_sign_q            = mid_pipe_final_sign_q[NUM_MID_REGS];\n  assign rnd_mode_q              = mid_pipe_rnd_mode_q[NUM_MID_REGS];\n  assign dst_fmt_q2              = mid_pipe_dst_fmt_q[NUM_MID_REGS];\n  assign result_is_special_q     = mid_pipe_res_is_spec_q[NUM_MID_REGS];\n  assign special_result_q        = mid_pipe_spec_res_q[NUM_MID_REGS];\n  assign special_status_q        = mid_pipe_spec_stat_q[NUM_MID_REGS];\n\n  // --------------\n  // Normalization\n  // --------------\n  logic        [LOWER_SUM_WIDTH-1:0]  sum_lower;              // lower 2p+3 bits of sum are searched\n  logic        [LZC_RESULT_WIDTH-1:0] leading_zero_count;     // the number of leading zeroes\n  logic signed [LZC_RESULT_WIDTH:0]   leading_zero_count_sgn; // signed leading-zero count\n  logic                               lzc_zeroes;             // in case only zeroes found\n\n  logic        [SHIFT_AMOUNT_WIDTH-1:0] norm_shamt; // Normalization shift amount\n  logic signed [EXP_WIDTH-1:0]          normalized_exponent;\n\n  logic [3*PRECISION_BITS+4:0] sum_shifted;       // result after first normalization shift\n  logic [PRECISION_BITS:0]     final_mantissa;    // final mantissa before rounding with round bit\n  logic [2*PRECISION_BITS+2:0] sum_sticky_bits;   // remaining 2p+3 sticky bits after normalization\n  logic                        sticky_after_norm; // sticky bit after normalization\n\n  logic signed [EXP_WIDTH-1:0] final_exponent;\n\n  assign sum_lower = sum_q[LOWER_SUM_WIDTH-1:0];\n\n  // Leading zero counter for cancellations\n  lzc #(\n    .WIDTH ( LOWER_SUM_WIDTH ),\n    .MODE  ( 1               ) // MODE = 1 counts leading zeroes\n  ) i_lzc (\n    .in_i    ( sum_lower          ),\n    .cnt_o   ( leading_zero_count ),\n    .empty_o ( lzc_zeroes         )\n  );\n\n  assign leading_zero_count_sgn = signed'({1'b0, leading_zero_count});\n\n  // Normalization shift amount based on exponents and LZC (unsigned as only left shifts)\n  always_comb begin : norm_shift_amount\n    // Product-anchored case or cancellations require LZC\n    if ((exponent_difference_q <= 0) || (effective_subtraction_q && (exponent_difference_q <= 2))) begin\n      // Normal result (biased exponent > 0 and not a zero)\n      if ((exponent_product_q - leading_zero_count_sgn + 1 >= 0) && !lzc_zeroes) begin\n        // Undo initial product shift, remove the counted zeroes\n        norm_shamt          = PRECISION_BITS + 2 + leading_zero_count;\n        normalized_exponent = exponent_product_q - leading_zero_count_sgn + 1; // account for shift\n      // Subnormal result\n      end else begin\n        // Cap the shift distance to align mantissa with minimum exponent\n        norm_shamt          = unsigned'(signed'(PRECISION_BITS + 2 + exponent_product_q));\n        normalized_exponent = 0; // subnormals encoded as 0\n      end\n    // Addend-anchored case\n    end else begin\n      norm_shamt          = addend_shamt_q; // Undo the initial shift\n      normalized_exponent = tentative_exponent_q;\n    end\n  end\n\n  // Do the large normalization shift\n  assign sum_shifted       = sum_q << norm_shamt;\n\n  // The addend-anchored case needs a 1-bit normalization since the leading-one can be to the left\n  // or right of the (non-carry) MSB of the sum.\n  always_comb begin : small_norm\n    // Default assignment, discarding carry bit\n    {final_mantissa, sum_sticky_bits} = sum_shifted;\n    final_exponent                    = normalized_exponent;\n\n    // The normalized sum has overflown, align right and fix exponent\n    if (sum_shifted[3*PRECISION_BITS+4]) begin // check the carry bit\n      {final_mantissa, sum_sticky_bits} = sum_shifted >> 1;\n      final_exponent                    = normalized_exponent + 1;\n    // The normalized sum is normal, nothing to do\n    end else if (sum_shifted[3*PRECISION_BITS+3]) begin // check the sum MSB\n      // do nothing\n    // The normalized sum is still denormal, align left - unless the result is not already subnormal\n    end else if (normalized_exponent > 1) begin\n      {final_mantissa, sum_sticky_bits} = sum_shifted << 1;\n      final_exponent                    = normalized_exponent - 1;\n    // Otherwise we're denormal\n    end else begin\n      final_exponent = '0;\n    end\n  end\n\n  // Update the sticky bit with the shifted-out bits\n  assign sticky_after_norm = (| {sum_sticky_bits}) | sticky_before_add_q;\n\n  // ----------------------------\n  // Rounding and classification\n  // ----------------------------\n  logic                                     pre_round_sign;\n  logic [SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] pre_round_abs; // absolute value of result before rounding\n  logic [1:0]                               round_sticky_bits;\n\n  logic of_before_round, of_after_round; // overflow\n  logic uf_before_round, uf_after_round; // underflow\n\n  logic [NUM_FORMATS-1:0][SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] fmt_pre_round_abs; // per format\n  logic [NUM_FORMATS-1:0][1:0]                               fmt_round_sticky_bits;\n\n  logic [NUM_FORMATS-1:0]                                    fmt_of_after_round;\n  logic [NUM_FORMATS-1:0]                                    fmt_uf_after_round;\n\n  logic                                     rounded_sign;\n  logic [SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] rounded_abs; // absolute value of result after rounding\n  logic                                     result_zero;\n\n  // Classification before round. RISC-V mandates checking underflow AFTER rounding!\n  assign of_before_round = final_exponent >= 2**(fpnew_pkg::exp_bits(dst_fmt_q2))-1; // infinity exponent is all ones\n  assign uf_before_round = final_exponent == 0;               // exponent for subnormals capped to 0\n\n  // Pack exponent and mantissa into proper rounding form\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble\n    // Set up some constants\n    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));\n\n    logic [EXP_BITS-1:0] pre_round_exponent;\n    logic [MAN_BITS-1:0] pre_round_mantissa;\n\n    if (FpFmtConfig[fmt]) begin : active_format\n\n      assign pre_round_exponent = (of_before_round) ? 2**EXP_BITS-2 : final_exponent[EXP_BITS-1:0];\n      assign pre_round_mantissa = (of_before_round) ? '1 : final_mantissa[SUPER_MAN_BITS-:MAN_BITS];\n      // Assemble result before rounding. In case of overflow, the largest normal value is set.\n      assign fmt_pre_round_abs[fmt] = {pre_round_exponent, pre_round_mantissa}; // 0-extend\n\n      // Round bit is after mantissa (1 in case of overflow for rounding)\n      assign fmt_round_sticky_bits[fmt][1] = final_mantissa[SUPER_MAN_BITS-MAN_BITS] |\n                                             of_before_round;\n\n      // remaining bits in mantissa to sticky (1 in case of overflow for rounding)\n      if (MAN_BITS < SUPER_MAN_BITS) begin : narrow_sticky\n        assign fmt_round_sticky_bits[fmt][0] = (| final_mantissa[SUPER_MAN_BITS-MAN_BITS-1:0]) |\n                                               sticky_after_norm | of_before_round;\n      end else begin : normal_sticky\n        assign fmt_round_sticky_bits[fmt][0] = sticky_after_norm | of_before_round;\n      end\n    end else begin : inactive_format\n      assign fmt_pre_round_abs[fmt] = '{default: fpnew_pkg::DONT_CARE};\n      assign fmt_round_sticky_bits[fmt] = '{default: fpnew_pkg::DONT_CARE};\n    end\n  end\n\n  // Assemble result before rounding. In case of overflow, the largest normal value is set.\n  assign pre_round_sign     = final_sign_q;\n  assign pre_round_abs      = fmt_pre_round_abs[dst_fmt_q2];\n\n  // In case of overflow, the round and sticky bits are set for proper rounding\n  assign round_sticky_bits  = fmt_round_sticky_bits[dst_fmt_q2];\n\n  // Perform the rounding\n  fpnew_rounding #(\n    .AbsWidth ( SUPER_EXP_BITS + SUPER_MAN_BITS )\n  ) i_fpnew_rounding (\n    .abs_value_i             ( pre_round_abs           ),\n    .sign_i                  ( pre_round_sign          ),\n    .round_sticky_bits_i     ( round_sticky_bits       ),\n    .rnd_mode_i              ( rnd_mode_q              ),\n    .effective_subtraction_i ( effective_subtraction_q ),\n    .abs_rounded_o           ( rounded_abs             ),\n    .sign_o                  ( rounded_sign            ),\n    .exact_zero_o            ( result_zero             )\n  );\n\n  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_result;\n\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject\n    // Set up some constants\n    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));\n\n    if (FpFmtConfig[fmt]) begin : active_format\n      always_comb begin : post_process\n        // detect of / uf        \n        fmt_uf_after_round[fmt] = (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) // denormal\n        || ((pre_round_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) && (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == 1) && \n              ((round_sticky_bits != 2'b11) || (!sum_sticky_bits[MAN_BITS*2 + 4] && ((rnd_mode_i == fpnew_pkg::RNE) || (rnd_mode_i == fpnew_pkg::RMM)))));\n        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.\n\n        // Assemble regular result, nan box short ones.\n        fmt_result[fmt]               = '1;\n        fmt_result[fmt][FP_WIDTH-1:0] = {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};\n      end\n    end else begin : inactive_format\n      assign fmt_uf_after_round[fmt] = fpnew_pkg::DONT_CARE;\n      assign fmt_of_after_round[fmt] = fpnew_pkg::DONT_CARE;\n      assign fmt_result[fmt]         = '{default: fpnew_pkg::DONT_CARE};\n    end\n  end\n\n  // Classification after rounding select by destination format\n  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];\n  assign of_after_round = fmt_of_after_round[dst_fmt_q2];\n\n\n  // -----------------\n  // Result selection\n  // -----------------\n  logic [WIDTH-1:0]     regular_result;\n  fpnew_pkg::status_t   regular_status;\n\n  // Assemble regular result\n  assign regular_result = fmt_result[dst_fmt_q2];\n  assign regular_status.NV = 1'b0; // only valid cases are handled in regular path\n  assign regular_status.DZ = 1'b0; // no divisions\n  assign regular_status.OF = of_before_round | of_after_round;   // rounding can introduce overflow\n  assign regular_status.UF = uf_after_round & regular_status.NX; // only inexact results raise UF\n  assign regular_status.NX = (| round_sticky_bits) | of_before_round | of_after_round;\n\n  // Final results for output pipeline\n  logic [WIDTH-1:0]   result_d;\n  fpnew_pkg::status_t status_d;\n\n  // Select output depending on special case detection\n  assign result_d = result_is_special_q ? special_result_q : regular_result;\n  assign status_d = result_is_special_q ? special_status_q : regular_status;\n\n  // ----------------\n  // Output Pipeline\n  // ----------------\n  // Output pipeline signals, index i holds signal after i register stages\n  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;\n  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;\n  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;\n  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;\n  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;\n  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;\n  // Ready signal is combinatorial for all stages\n  logic [0:NUM_OUT_REGS] out_pipe_ready;\n\n  // Input stage: First element of pipeline is taken from inputs\n  assign out_pipe_result_q[0] = result_d;\n  assign out_pipe_status_q[0] = status_d;\n  assign out_pipe_tag_q[0]    = mid_pipe_tag_q[NUM_MID_REGS];\n  assign out_pipe_mask_q[0]   = mid_pipe_mask_q[NUM_MID_REGS];\n  assign out_pipe_aux_q[0]    = mid_pipe_aux_q[NUM_MID_REGS];\n  assign out_pipe_valid_q[0]  = mid_pipe_valid_q[NUM_MID_REGS];\n  // Input stage: Propagate pipeline ready signal to inside pipe\n  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];\n  // Generate the register stages\n  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline\n    // Internal register enable for this stage\n    logic reg_ena;\n    // Determine the ready signal of the current stage - advance the pipeline:\n    // 1. if the next stage is ready for our data\n    // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];\n    // Valid: enabled by ready signal, synchronous clear with the flush signal\n    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n    // Enable register if pipleine ready and a valid data item is present\n    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + NUM_MID_REGS + i];\n    // Generate the pipeline registers within the stages, use enable-registers\n    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)\n    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)\n    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))\n    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)\n    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))\n  end\n  // Output stage: Ready travels backwards from output side, driven by downstream circuitry\n  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;\n  // Output stage: assign module outputs\n  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];\n  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];\n  assign extension_bit_o = 1'b1; // always NaN-Box result\n  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];\n  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];\n  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];\n  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];\n  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});\nendmodule\n","lang":"verilog"};
processSrcData(g_data);