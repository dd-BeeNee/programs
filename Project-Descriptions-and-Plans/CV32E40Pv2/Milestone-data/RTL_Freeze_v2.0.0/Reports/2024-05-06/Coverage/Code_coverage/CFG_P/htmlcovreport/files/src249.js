var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_ex_stage.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Renzo Andri - andrire@student.ethz.ch                      //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Execute stage                                              //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Execution stage: Hosts ALU and MAC unit                    //\n//                 ALU: computes additions/subtractions/comparisons           //\n//                 MULT: computes normal multiplications                      //\n//                 APU_DISP: offloads instructions to the shared unit.        //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_ex_stage\n  import cv32e40p_pkg::*;\n  import cv32e40p_apu_core_pkg::*;\n#(\n    parameter COREV_PULP       = 0,\n    parameter FPU              = 0,\n    parameter APU_NARGS_CPU    = 3,\n    parameter APU_WOP_CPU      = 6,\n    parameter APU_NDSFLAGS_CPU = 15,\n    parameter APU_NUSFLAGS_CPU = 5\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // ALU signals from ID stage\n    input alu_opcode_e        alu_operator_i,\n    input logic        [31:0] alu_operand_a_i,\n    input logic        [31:0] alu_operand_b_i,\n    input logic        [31:0] alu_operand_c_i,\n    input logic               alu_en_i,\n    input logic        [ 4:0] bmask_a_i,\n    input logic        [ 4:0] bmask_b_i,\n    input logic        [ 1:0] imm_vec_ext_i,\n    input logic        [ 1:0] alu_vec_mode_i,\n    input logic               alu_is_clpx_i,\n    input logic               alu_is_subrot_i,\n    input logic        [ 1:0] alu_clpx_shift_i,\n\n    // Multiplier signals\n    input mul_opcode_e        mult_operator_i,\n    input logic        [31:0] mult_operand_a_i,\n    input logic        [31:0] mult_operand_b_i,\n    input logic        [31:0] mult_operand_c_i,\n    input logic               mult_en_i,\n    input logic               mult_sel_subword_i,\n    input logic        [ 1:0] mult_signed_mode_i,\n    input logic        [ 4:0] mult_imm_i,\n\n    input logic [31:0] mult_dot_op_a_i,\n    input logic [31:0] mult_dot_op_b_i,\n    input logic [31:0] mult_dot_op_c_i,\n    input logic [ 1:0] mult_dot_signed_i,\n    input logic        mult_is_clpx_i,\n    input logic [ 1:0] mult_clpx_shift_i,\n    input logic        mult_clpx_img_i,\n\n    output logic mult_multicycle_o,\n\n    input logic data_req_i,\n    input logic data_rvalid_i,\n    input logic data_misaligned_ex_i,\n    input logic data_misaligned_i,\n\n    input logic [1:0] ctrl_transfer_insn_in_dec_i,\n\n    // FPU signals\n    output logic fpu_fflags_we_o,\n    output logic [APU_NUSFLAGS_CPU-1:0] fpu_fflags_o,\n\n    // APU signals\n    input logic                              apu_en_i,\n    input logic [     APU_WOP_CPU-1:0]       apu_op_i,\n    input logic [                 1:0]       apu_lat_i,\n    input logic [   APU_NARGS_CPU-1:0][31:0] apu_operands_i,\n    input logic [                 5:0]       apu_waddr_i,\n    input logic [APU_NUSFLAGS_CPU-1:0]       apu_flags_i,\n\n    input  logic [2:0][5:0] apu_read_regs_i,\n    input  logic [2:0]      apu_read_regs_valid_i,\n    output logic            apu_read_dep_o,\n    output logic            apu_read_dep_for_jalr_o,\n    input  logic [1:0][5:0] apu_write_regs_i,\n    input  logic [1:0]      apu_write_regs_valid_i,\n    output logic            apu_write_dep_o,\n\n    output logic apu_perf_type_o,\n    output logic apu_perf_cont_o,\n    output logic apu_perf_wb_o,\n\n    output logic apu_busy_o,\n    output logic apu_ready_wb_o,\n\n    // apu-interconnect\n    // handshake signals\n    output logic                           apu_req_o,\n    input  logic                           apu_gnt_i,\n    // request channel\n    output logic [APU_NARGS_CPU-1:0][31:0] apu_operands_o,\n    output logic [  APU_WOP_CPU-1:0]       apu_op_o,\n    // response channel\n    input  logic                           apu_rvalid_i,\n    input  logic [             31:0]       apu_result_i,\n\n    input logic        lsu_en_i,\n    input logic [31:0] lsu_rdata_i,\n\n    // input from ID stage\n    input logic       branch_in_ex_i,\n    input logic [5:0] regfile_alu_waddr_i,\n    input logic       regfile_alu_we_i,\n\n    // directly passed through to WB stage, not used in EX\n    input logic       regfile_we_i,\n    input logic [5:0] regfile_waddr_i,\n\n    // CSR access\n    input logic        csr_access_i,\n    input logic [31:0] csr_rdata_i,\n\n    // Output of EX stage pipeline\n    output logic [ 5:0] regfile_waddr_wb_o,\n    output logic        regfile_we_wb_o,\n    output logic        regfile_we_wb_power_o,\n    output logic [31:0] regfile_wdata_wb_o,\n\n    // Forwarding ports : to ID stage\n    output logic [ 5:0] regfile_alu_waddr_fw_o,\n    output logic        regfile_alu_we_fw_o,\n    output logic        regfile_alu_we_fw_power_o,\n    output logic [31:0] regfile_alu_wdata_fw_o,  // forward to RF and ID/EX pipe, ALU & MUL\n\n    // To IF: Jump and branch target and decision\n    output logic [31:0] jump_target_o,\n    output logic        branch_decision_o,\n\n    // Stall Control\n    input logic is_decoding_i, // Used to mask data Dependency inside the APU dispatcher in case of an istruction non valid\n    input logic lsu_ready_ex_i,  // EX part of LSU is done\n    input logic lsu_err_i,\n\n    output logic ex_ready_o,  // EX stage ready for new data\n    output logic ex_valid_o,  // EX stage gets new data\n    input  logic wb_ready_i  // WB stage ready for new data\n);\n\n  logic [                31:0] alu_result;\n  logic [                31:0] mult_result;\n  logic                        alu_cmp_result;\n\n  logic                        regfile_we_lsu;\n  logic [                 5:0] regfile_waddr_lsu;\n\n  logic                        wb_contention;\n  logic                        wb_contention_lsu;\n\n  logic                        alu_ready;\n  logic                        mulh_active;\n  logic                        mult_ready;\n\n  // APU signals\n  logic                        apu_valid;\n  logic [                 5:0] apu_waddr;\n  logic [                31:0] apu_result;\n  logic                        apu_stall;\n  logic                        apu_active;\n  logic                        apu_singlecycle;\n  logic                        apu_multicycle;\n  logic                        apu_req;\n  logic                        apu_gnt;\n\n  logic                        apu_rvalid_q;\n  logic [                31:0] apu_result_q;\n  logic [APU_NUSFLAGS_CPU-1:0] apu_flags_q;\n\n  // ALU write port mux\n  always_comb begin\n    regfile_alu_wdata_fw_o    = '0;\n    regfile_alu_waddr_fw_o    = '0;\n    regfile_alu_we_fw_o       = 1'b0;\n    regfile_alu_we_fw_power_o = 1'b0;\n    wb_contention             = 1'b0;\n\n    // APU single cycle operations, and multicycle operations (> 2cycles) are written back on ALU port\n    if (apu_valid & (apu_singlecycle | apu_multicycle)) begin\n      regfile_alu_we_fw_o       = 1'b1;\n      regfile_alu_we_fw_power_o = 1'b1;\n      regfile_alu_waddr_fw_o    = apu_waddr;\n      regfile_alu_wdata_fw_o    = apu_result;\n\n      if (regfile_alu_we_i & ~apu_en_i) begin\n        wb_contention = 1'b1;\n      end\n    end else begin\n      regfile_alu_we_fw_o = regfile_alu_we_i & ~apu_en_i;\n      regfile_alu_we_fw_power_o = (COREV_PULP == 0) ? regfile_alu_we_i & ~apu_en_i : \n                                                     regfile_alu_we_i & ~apu_en_i &\n                                                     mult_ready & alu_ready & lsu_ready_ex_i;\n      regfile_alu_waddr_fw_o = regfile_alu_waddr_i;\n      if (alu_en_i) regfile_alu_wdata_fw_o = alu_result;\n      if (mult_en_i) regfile_alu_wdata_fw_o = mult_result;\n      if (csr_access_i) regfile_alu_wdata_fw_o = csr_rdata_i;\n    end\n  end\n\n  // LSU write port mux\n  always_comb begin\n    regfile_we_wb_o       = 1'b0;\n    regfile_we_wb_power_o = 1'b0;\n    regfile_waddr_wb_o    = regfile_waddr_lsu;\n    regfile_wdata_wb_o    = lsu_rdata_i;\n    wb_contention_lsu     = 1'b0;\n\n    if (regfile_we_lsu) begin\n      regfile_we_wb_o       = 1'b1;\n      regfile_we_wb_power_o = (COREV_PULP == 0) ? 1'b1 : ~data_misaligned_ex_i & wb_ready_i;\n      if (apu_valid & (!apu_singlecycle & !apu_multicycle)) begin\n        wb_contention_lsu = 1'b1;\n      end\n      // APU two-cycle operations are written back on LSU port\n    end else if (apu_valid & (!apu_singlecycle & !apu_multicycle)) begin\n      regfile_we_wb_o       = 1'b1;\n      regfile_we_wb_power_o = 1'b1;\n      regfile_waddr_wb_o    = apu_waddr;\n      regfile_wdata_wb_o    = apu_result;\n    end\n  end\n\n  // branch handling\n  assign branch_decision_o = alu_cmp_result;\n  assign jump_target_o     = alu_operand_c_i;\n\n\n  ////////////////////////////\n  //     _    _    _   _    //\n  //    / \\  | |  | | | |   //\n  //   / _ \\ | |  | | | |   //\n  //  / ___ \\| |__| |_| |   //\n  // /_/   \\_\\_____\\___/    //\n  //                        //\n  ////////////////////////////\n\n  cv32e40p_alu alu_i (\n      .clk        (clk),\n      .rst_n      (rst_n),\n      .enable_i   (alu_en_i),\n      .operator_i (alu_operator_i),\n      .operand_a_i(alu_operand_a_i),\n      .operand_b_i(alu_operand_b_i),\n      .operand_c_i(alu_operand_c_i),\n\n      .vector_mode_i(alu_vec_mode_i),\n      .bmask_a_i    (bmask_a_i),\n      .bmask_b_i    (bmask_b_i),\n      .imm_vec_ext_i(imm_vec_ext_i),\n\n      .is_clpx_i   (alu_is_clpx_i),\n      .clpx_shift_i(alu_clpx_shift_i),\n      .is_subrot_i (alu_is_subrot_i),\n\n      .result_o           (alu_result),\n      .comparison_result_o(alu_cmp_result),\n\n      .ready_o   (alu_ready),\n      .ex_ready_i(ex_ready_o)\n  );\n\n\n  ////////////////////////////////////////////////////////////////\n  //  __  __ _   _ _   _____ ___ ____  _     ___ _____ ____     //\n  // |  \\/  | | | | | |_   _|_ _|  _ \\| |   |_ _| ____|  _ \\    //\n  // | |\\/| | | | | |   | |  | || |_) | |    | ||  _| | |_) |   //\n  // | |  | | |_| | |___| |  | ||  __/| |___ | || |___|  _ <    //\n  // |_|  |_|\\___/|_____|_| |___|_|   |_____|___|_____|_| \\_\\   //\n  //                                                            //\n  ////////////////////////////////////////////////////////////////\n\n  cv32e40p_mult mult_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .enable_i  (mult_en_i),\n      .operator_i(mult_operator_i),\n\n      .short_subword_i(mult_sel_subword_i),\n      .short_signed_i (mult_signed_mode_i),\n\n      .op_a_i(mult_operand_a_i),\n      .op_b_i(mult_operand_b_i),\n      .op_c_i(mult_operand_c_i),\n      .imm_i (mult_imm_i),\n\n      .dot_op_a_i  (mult_dot_op_a_i),\n      .dot_op_b_i  (mult_dot_op_b_i),\n      .dot_op_c_i  (mult_dot_op_c_i),\n      .dot_signed_i(mult_dot_signed_i),\n      .is_clpx_i   (mult_is_clpx_i),\n      .clpx_shift_i(mult_clpx_shift_i),\n      .clpx_img_i  (mult_clpx_img_i),\n\n      .result_o(mult_result),\n\n      .multicycle_o (mult_multicycle_o),\n      .mulh_active_o(mulh_active),\n      .ready_o      (mult_ready),\n      .ex_ready_i   (ex_ready_o)\n  );\n\n  generate\n    if (FPU == 1) begin : gen_apu\n      ////////////////////////////////////////////////////\n      //     _    ____  _   _   ____ ___ ____  ____     //\n      //    / \\  |  _ \\| | | | |  _ \\_ _/ ___||  _ \\    //\n      //   / _ \\ | |_) | | | | | | | | |\\___ \\| |_) |   //\n      //  / ___ \\|  __/| |_| | | |_| | | ___) |  __/    //\n      // /_/   \\_\\_|    \\___/  |____/___|____/|_|       //\n      //                                                //\n      ////////////////////////////////////////////////////\n\n      cv32e40p_apu_disp apu_disp_i (\n          .clk_i (clk),\n          .rst_ni(rst_n),\n\n          .enable_i   (apu_en_i),\n          .apu_lat_i  (apu_lat_i),\n          .apu_waddr_i(apu_waddr_i),\n\n          .apu_waddr_o      (apu_waddr),\n          .apu_multicycle_o (apu_multicycle),\n          .apu_singlecycle_o(apu_singlecycle),\n\n          .active_o(apu_active),\n          .stall_o (apu_stall),\n\n          .is_decoding_i      (is_decoding_i),\n          .read_regs_i        (apu_read_regs_i),\n          .read_regs_valid_i  (apu_read_regs_valid_i),\n          .read_dep_o         (apu_read_dep_o),\n          .read_dep_for_jalr_o(apu_read_dep_for_jalr_o),\n          .write_regs_i       (apu_write_regs_i),\n          .write_regs_valid_i (apu_write_regs_valid_i),\n          .write_dep_o        (apu_write_dep_o),\n\n          .perf_type_o(apu_perf_type_o),\n          .perf_cont_o(apu_perf_cont_o),\n\n          // apu-interconnect\n          // handshake signals\n          .apu_req_o   (apu_req),\n          .apu_gnt_i   (apu_gnt),\n          // response channel\n          .apu_rvalid_i(apu_valid)\n      );\n\n      assign apu_perf_wb_o  = wb_contention | wb_contention_lsu;\n      assign apu_ready_wb_o = ~(apu_active | apu_en_i | apu_stall) | apu_valid;\n\n      ///////////////////////////////////////\n      // APU result memorization Register  //\n      ///////////////////////////////////////\n      always_ff @(posedge clk, negedge rst_n) begin : APU_Result_Memorization\n        if (~rst_n) begin\n          apu_rvalid_q <= 1'b0;\n          apu_result_q <= 'b0;\n          apu_flags_q  <= 'b0;\n        end else begin\n          if (apu_rvalid_i && apu_multicycle &&\n              (data_misaligned_i || data_misaligned_ex_i ||\n               ((data_req_i || data_rvalid_i) && regfile_alu_we_i) ||\n               (mulh_active && (mult_operator_i == MUL_H)) ||\n               ((ctrl_transfer_insn_in_dec_i == BRANCH_JALR) &&\n                regfile_alu_we_i && ~apu_read_dep_for_jalr_o))) begin\n            apu_rvalid_q <= 1'b1;\n            apu_result_q <= apu_result_i;\n            apu_flags_q  <= apu_flags_i;\n          end else if (apu_rvalid_q && !(data_misaligned_i || data_misaligned_ex_i ||\n                                         ((data_req_i || data_rvalid_i) && regfile_alu_we_i) ||\n                                         (mulh_active && (mult_operator_i == MUL_H)) ||\n                                         ((ctrl_transfer_insn_in_dec_i == BRANCH_JALR) &&\n                                          regfile_alu_we_i && ~apu_read_dep_for_jalr_o))) begin\n            apu_rvalid_q <= 1'b0;\n          end\n        end\n      end\n\n      assign apu_req_o = apu_req;\n      assign apu_gnt = apu_gnt_i;\n      assign apu_valid = (apu_multicycle && (data_misaligned_i || data_misaligned_ex_i ||\n                                             ((data_req_i || data_rvalid_i) && regfile_alu_we_i) ||\n                                             (mulh_active && (mult_operator_i == MUL_H)) ||\n                                             ((ctrl_transfer_insn_in_dec_i == BRANCH_JALR) &&\n                                              regfile_alu_we_i && ~apu_read_dep_for_jalr_o)))\n                         ? 1'b0 : (apu_rvalid_i || apu_rvalid_q);\n      assign apu_operands_o = apu_operands_i;\n      assign apu_op_o = apu_op_i;\n      assign apu_result = apu_rvalid_q ? apu_result_q : apu_result_i;\n      assign fpu_fflags_we_o = apu_valid;\n      assign fpu_fflags_o = apu_rvalid_q ? apu_flags_q : apu_flags_i;\n    end else begin : gen_no_apu\n      // default assignements for the case when no FPU/APU is attached.\n      assign apu_req_o               = '0;\n      assign apu_operands_o[0]       = '0;\n      assign apu_operands_o[1]       = '0;\n      assign apu_operands_o[2]       = '0;\n      assign apu_op_o                = '0;\n      assign apu_req                 = 1'b0;\n      assign apu_gnt                 = 1'b0;\n      assign apu_result              = 32'b0;\n      assign apu_valid               = 1'b0;\n      assign apu_waddr               = 6'b0;\n      assign apu_stall               = 1'b0;\n      assign apu_active              = 1'b0;\n      assign apu_ready_wb_o          = 1'b1;\n      assign apu_perf_wb_o           = 1'b0;\n      assign apu_perf_cont_o         = 1'b0;\n      assign apu_perf_type_o         = 1'b0;\n      assign apu_singlecycle         = 1'b0;\n      assign apu_multicycle          = 1'b0;\n      assign apu_read_dep_o          = 1'b0;\n      assign apu_read_dep_for_jalr_o = 1'b0;\n      assign apu_write_dep_o         = 1'b0;\n      assign fpu_fflags_o            = '0;\n      assign fpu_fflags_we_o         = '0;\n    end\n  endgenerate\n\n  assign apu_busy_o = apu_active;\n\n  ///////////////////////////////////////\n  // EX/WB Pipeline Register           //\n  ///////////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin : EX_WB_Pipeline_Register\n    if (~rst_n) begin\n      regfile_waddr_lsu <= '0;\n      regfile_we_lsu    <= 1'b0;\n    end else begin\n      if (ex_valid_o) // wb_ready_i is implied\n      begin\n        regfile_we_lsu <= regfile_we_i & ~lsu_err_i;\n        if (regfile_we_i & ~lsu_err_i) begin\n          regfile_waddr_lsu <= regfile_waddr_i;\n        end\n      end else if (wb_ready_i) begin\n        // we are ready for a new instruction, but there is none available,\n        // so we just flush the current one out of the pipe\n        regfile_we_lsu <= 1'b0;\n      end\n    end\n  end\n\n  // As valid always goes to the right and ready to the left, and we are able\n  // to finish branches without going to the WB stage, ex_valid does not\n  // depend on ex_ready.\n  assign ex_ready_o = (~apu_stall & alu_ready & mult_ready & lsu_ready_ex_i\n                       & wb_ready_i & ~wb_contention) | (branch_in_ex_i);\n  assign ex_valid_o = (apu_valid | alu_en_i | mult_en_i | csr_access_i | lsu_en_i)\n                       & (alu_ready & mult_ready & lsu_ready_ex_i & wb_ready_i);\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);