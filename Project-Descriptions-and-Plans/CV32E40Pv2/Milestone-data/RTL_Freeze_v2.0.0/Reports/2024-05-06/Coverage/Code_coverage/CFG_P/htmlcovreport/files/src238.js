var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_fifo.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n\n// Copy of fifo_v3 from https://github.com/pulp-platform/common_cells b2a4b2d3decdfc152ad9b4564a48ed3b2649fd6c\n\nmodule cv32e40p_fifo #(\n    parameter bit FALL_THROUGH = 1'b0,  // fifo is in fall-through mode\n    parameter int unsigned DATA_WIDTH = 32,  // default data width if the fifo is of type logic\n    parameter int unsigned DEPTH = 8,  // depth can be arbitrary from 0 to 2**32\n    // DO NOT OVERWRITE THIS PARAMETER\n    parameter int unsigned ADDR_DEPTH = (DEPTH > 1) ? $clog2(DEPTH) : 1\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    input logic flush_i,  // flush the queue\n    input logic flush_but_first_i,  // flush the queue except the first instruction\n    input logic testmode_i,  // test_mode to bypass clock gating\n    // status flags\n    output logic full_o,  // queue is full\n    output logic empty_o,  // queue is empty\n    output logic [ADDR_DEPTH:0] cnt_o,  // FIFO counter\n    // as long as the queue is not full we can push new data\n    input logic [DATA_WIDTH-1:0] data_i,  // data to push into the queue\n    input logic push_i,  // data is valid and can be pushed to the queue\n    // as long as the queue is not empty we can pop new elements\n    output logic [DATA_WIDTH-1:0] data_o,  // output data\n    input logic pop_i  // pop head from queue\n);\n  // local parameter\n  // FIFO depth - handle the case of pass-through, synthesizer will do constant propagation\n  localparam int unsigned FIFO_DEPTH = (DEPTH > 0) ? DEPTH : 1;\n  // clock gating control\n  logic gate_clock;\n  // pointer to the read and write section of the queue\n  logic [ADDR_DEPTH - 1:0] read_pointer_n, read_pointer_q, write_pointer_n, write_pointer_q;\n  // keep a counter to keep track of the current queue status\n  logic [ADDR_DEPTH:0]\n      status_cnt_n, status_cnt_q;  // this integer will be truncated by the synthesis tool\n  // actual memory\n  logic [FIFO_DEPTH - 1:0][DATA_WIDTH-1:0] mem_n, mem_q;\n\n  assign cnt_o = status_cnt_q;\n\n  // status flags\n  generate\n    if (DEPTH == 0) begin : gen_zero_depth\n      assign empty_o = ~push_i;\n      assign full_o  = ~pop_i;\n    end else begin : gen_non_zero_depth\n      assign full_o  = (status_cnt_q == FIFO_DEPTH[ADDR_DEPTH:0]);\n      assign empty_o = (status_cnt_q == 0) & ~(FALL_THROUGH & push_i);\n    end\n  endgenerate\n\n  // read and write queue logic\n  always_comb begin : read_write_comb\n    // default assignment\n    read_pointer_n  = read_pointer_q;\n    write_pointer_n = write_pointer_q;\n    status_cnt_n    = status_cnt_q;\n    data_o          = (DEPTH == 0) ? data_i : mem_q[read_pointer_q];\n    mem_n           = mem_q;\n    gate_clock      = 1'b1;\n\n    // push a new element to the queue\n    if (push_i && ~full_o) begin\n      // push the data onto the queue\n      mem_n[write_pointer_q] = data_i;\n      // un-gate the clock, we want to write something\n      gate_clock = 1'b0;\n      // increment the write counter\n      if (write_pointer_q == FIFO_DEPTH[ADDR_DEPTH-1:0] - 1) write_pointer_n = '0;\n      else write_pointer_n = write_pointer_q + 1;\n      // increment the overall counter\n      status_cnt_n = status_cnt_q + 1;\n    end\n\n    if (pop_i && ~empty_o) begin\n      // read from the queue is a default assignment\n      // but increment the read pointer...\n      if (read_pointer_n == FIFO_DEPTH[ADDR_DEPTH-1:0] - 1) read_pointer_n = '0;\n      else read_pointer_n = read_pointer_q + 1;\n      // ... and decrement the overall count\n      status_cnt_n = status_cnt_q - 1;\n    end\n\n    // keep the count pointer stable if we push and pop at the same time\n    if (push_i && pop_i && ~full_o && ~empty_o) status_cnt_n = status_cnt_q;\n\n    // FIFO is in pass through mode -> do not change the pointers\n    if (FALL_THROUGH && (status_cnt_q == 0) && push_i) begin\n      data_o = data_i;\n      if (pop_i) begin\n        status_cnt_n = status_cnt_q;\n        read_pointer_n = read_pointer_q;\n        write_pointer_n = write_pointer_q;\n      end\n    end\n  end\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      read_pointer_q  <= '0;\n      write_pointer_q <= '0;\n      status_cnt_q    <= '0;\n    end else begin\n      unique case (1'b1)\n        // Flush the FIFO\n        flush_i: begin\n          read_pointer_q  <= '0;\n          write_pointer_q <= '0;\n          status_cnt_q    <= '0;\n        end\n        // Flush the FIFO but keep the first instruction alive if present\n        flush_but_first_i: begin\n          read_pointer_q  <= (status_cnt_q > 0) ? read_pointer_q : '0;\n          write_pointer_q <= (status_cnt_q > 0) ? read_pointer_q + 1 : '0;\n          status_cnt_q    <= (status_cnt_q > 0) ? 1'b1 : '0;\n        end\n        // If we are not flushing, update the pointers\n        default: begin\n          read_pointer_q  <= read_pointer_n;\n          write_pointer_q <= write_pointer_n;\n          status_cnt_q    <= status_cnt_n;\n        end\n      endcase\n    end\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      mem_q <= '0;\n    end else if (!gate_clock) begin\n      mem_q <= mem_n;\n    end\n  end\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Assertions\n  //////////////////////////////////////////////////////////////////////////////\n\n`ifdef CV32E40P_ASSERT_ON\n\n  initial begin\n    assert (DEPTH > 0)\n    else $error(\"DEPTH must be greater than 0.\");\n  end\n\n  full_write :\n  assert property (@(posedge clk_i) disable iff (~rst_ni) (full_o |-> ~push_i))\n  else $fatal(1, \"Trying to push new data although the FIFO is full.\");\n\n  empty_read :\n  assert property (@(posedge clk_i) disable iff (~rst_ni) (empty_o |-> ~pop_i))\n  else $fatal(1, \"Trying to pop data although the FIFO is empty.\");\n`endif\n\nendmodule  // cv32e40p_fifo\n","lang":"verilog"};
processSrcData(g_data);