var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/vendor/opene906/E906_RTL_FACTORY/gen_rtl/fdsu/rtl/pa_fdsu_special.v","src":"/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// &ModuleBeg; @23\nmodule pa_fdsu_special(\n  cp0_fpu_xx_dqnan,\n  dp_xx_ex1_cnan,\n  dp_xx_ex1_id,\n  dp_xx_ex1_inf,\n  dp_xx_ex1_qnan,\n  dp_xx_ex1_snan,\n  dp_xx_ex1_zero,\n  ex1_div,\n  ex1_op0_id,\n  ex1_op0_norm,\n  ex1_op0_sign,\n  ex1_op1_id,\n  ex1_op1_norm,\n  ex1_result_sign,\n  ex1_sqrt,\n  ex1_srt_skip,\n  fdsu_fpu_ex1_fflags,\n  fdsu_fpu_ex1_special_sel,\n  fdsu_fpu_ex1_special_sign\n);\n\n// &Ports; @24\ninput          cp0_fpu_xx_dqnan;         \ninput   [2:0]  dp_xx_ex1_cnan;           \ninput   [2:0]  dp_xx_ex1_id;             \ninput   [2:0]  dp_xx_ex1_inf;            \ninput   [2:0]  dp_xx_ex1_qnan;           \ninput   [2:0]  dp_xx_ex1_snan;           \ninput   [2:0]  dp_xx_ex1_zero;           \ninput          ex1_div;                  \ninput          ex1_op0_sign;             \ninput          ex1_result_sign;          \ninput          ex1_sqrt;                 \noutput         ex1_op0_id;               \noutput         ex1_op0_norm;             \noutput         ex1_op1_id;               \noutput         ex1_op1_norm;             \noutput         ex1_srt_skip;             \noutput  [4:0]  fdsu_fpu_ex1_fflags;      \noutput  [7:0]  fdsu_fpu_ex1_special_sel; \noutput  [3:0]  fdsu_fpu_ex1_special_sign; \n\n// &Regs; @25\nreg            ex1_result_cnan;          \nreg            ex1_result_qnan_op0;      \nreg            ex1_result_qnan_op1;      \n\n// &Wires; @26\nwire           cp0_fpu_xx_dqnan;         \nwire    [2:0]  dp_xx_ex1_cnan;           \nwire    [2:0]  dp_xx_ex1_id;             \nwire    [2:0]  dp_xx_ex1_inf;            \nwire    [2:0]  dp_xx_ex1_qnan;           \nwire    [2:0]  dp_xx_ex1_snan;           \nwire    [2:0]  dp_xx_ex1_zero;           \nwire           ex1_div;                  \nwire           ex1_div_dz;               \nwire           ex1_div_nv;               \nwire           ex1_div_rst_inf;          \nwire           ex1_div_rst_qnan;         \nwire           ex1_div_rst_zero;         \nwire           ex1_dz;                   \nwire    [4:0]  ex1_fflags;               \nwire           ex1_nv;                   \nwire           ex1_op0_cnan;             \nwire           ex1_op0_id;               \nwire           ex1_op0_inf;              \nwire           ex1_op0_is_qnan;          \nwire           ex1_op0_is_snan;          \nwire           ex1_op0_norm;             \nwire           ex1_op0_qnan;             \nwire           ex1_op0_sign;             \nwire           ex1_op0_snan;             \nwire           ex1_op0_tt_zero;          \nwire           ex1_op0_zero;             \nwire           ex1_op1_cnan;             \nwire           ex1_op1_id;               \nwire           ex1_op1_inf;              \nwire           ex1_op1_is_qnan;          \nwire           ex1_op1_is_snan;          \nwire           ex1_op1_norm;             \nwire           ex1_op1_qnan;             \nwire           ex1_op1_snan;             \nwire           ex1_op1_tt_zero;          \nwire           ex1_op1_zero;             \nwire           ex1_result_inf;           \nwire           ex1_result_lfn;           \nwire           ex1_result_qnan;          \nwire           ex1_result_sign;          \nwire           ex1_result_zero;          \nwire           ex1_rst_default_qnan;     \nwire    [7:0]  ex1_special_sel;          \nwire    [3:0]  ex1_special_sign;         \nwire           ex1_sqrt;                 \nwire           ex1_sqrt_nv;              \nwire           ex1_sqrt_rst_inf;         \nwire           ex1_sqrt_rst_qnan;        \nwire           ex1_sqrt_rst_zero;        \nwire           ex1_srt_skip;             \nwire    [4:0]  fdsu_fpu_ex1_fflags;      \nwire    [7:0]  fdsu_fpu_ex1_special_sel; \nwire    [3:0]  fdsu_fpu_ex1_special_sign; \n\n\n//infinity number\n// &Force(\"bus\", \"dp_xx_ex1_inf\", 2, 0); @29\nassign  ex1_op0_inf                = dp_xx_ex1_inf[0];\nassign  ex1_op1_inf                = dp_xx_ex1_inf[1];\n\n//zero\n// &Force(\"bus\", \"dp_xx_ex1_zero\", 2, 0); @34\nassign ex1_op0_zero                = dp_xx_ex1_zero[0];\nassign ex1_op1_zero                = dp_xx_ex1_zero[1];\n\n//denormalize number\n// &Force(\"bus\", \"dp_xx_ex1_id\", 2, 0); @39\nassign ex1_op0_id                  = dp_xx_ex1_id[0];\nassign ex1_op1_id                  = dp_xx_ex1_id[1];\n\n//cNaN\n// &Force(\"bus\", \"dp_xx_ex1_cnan\", 2, 0); @44\nassign ex1_op0_cnan                = dp_xx_ex1_cnan[0];\nassign ex1_op1_cnan                = dp_xx_ex1_cnan[1];\n\n//sNaN\n// &Force(\"bus\", \"dp_xx_ex1_snan\", 2, 0); @49\nassign ex1_op0_snan                = dp_xx_ex1_snan[0];\nassign ex1_op1_snan                = dp_xx_ex1_snan[1];\n\n//qNaN\n// &Force(\"bus\", \"dp_xx_ex1_qnan\", 2, 0); @54\nassign ex1_op0_qnan                = dp_xx_ex1_qnan[0];\nassign ex1_op1_qnan                = dp_xx_ex1_qnan[1];\n\n\n//======================EX1 expt detect=====================\n//ex1_id_detect\n//any opration is zero\n// no input denormalize exception anymore\n//\n//ex1_nv_detect\n//div_nv\n//  1.any operation is sNaN\n//  2.0/0(include DN flush to zero)\n//  3.inf/inf\n//sqrt_nv\n//  1.any operation is sNaN\n//  2.operation sign is 1 && operation is not zero/qNaN\nassign ex1_nv      = ex1_div  && ex1_div_nv  ||\n                     ex1_sqrt && ex1_sqrt_nv;\n//ex1_div_nv\nassign ex1_div_nv  = ex1_op0_snan ||\n                     ex1_op1_snan ||\n                    (ex1_op0_tt_zero && ex1_op1_tt_zero)||\n                    (ex1_op0_inf && ex1_op1_inf);\nassign ex1_op0_tt_zero = ex1_op0_zero;\nassign ex1_op1_tt_zero = ex1_op1_zero;\n//ex1_sqrt_nv\nassign ex1_sqrt_nv = ex1_op0_snan ||\n                     ex1_op0_sign &&\n                    (ex1_op0_norm ||\n                     ex1_op0_inf );\n\n// This 'norm' also include denorm.\nassign ex1_op0_norm = !ex1_op0_inf && !ex1_op0_zero && !ex1_op0_snan && !ex1_op0_qnan && !ex1_op0_cnan;\nassign ex1_op1_norm = !ex1_op1_inf && !ex1_op1_zero && !ex1_op1_snan && !ex1_op1_qnan && !ex1_op1_cnan;\n\n//ex1_of_detect\n//div_of\n//  1.only detect id overflow case\n//assign ex1_of      = ex1_div && ex1_div_of;\n//assign ex1_div_of  = ex1_op1_id_fm1 &&\n//                     ex1_op0_norm &&\n//                     ex1_div_id_of;\n//\n////ex1_uf_detect\n////div_uf\n////  1.only detect id underflow case\n//assign ex1_uf      = ex1_div && ex1_div_uf;\n//assign ex1_div_uf  = ex1_op0_id &&\n//                     ex1_op1_norm &&\n//                     ex1_div_id_uf;\n//ex1_dz_detect\n//div_dz\n//  1.op0 is normal && op1 zero\nassign ex1_dz      = ex1_div && ex1_div_dz;\nassign ex1_div_dz  = ex1_op1_tt_zero && ex1_op0_norm;\n\n//===================special cal result=====================\n//ex1 result is zero\n//div_zero\n//  1.op0 is zero && op1 is normal\n//  2.op0 is zero/normal && op1 is inf\n//sqrt_zero\n//  1.op0 is zero\nassign ex1_result_zero   = ex1_div_rst_zero  && ex1_div  ||\n                           ex1_sqrt_rst_zero && ex1_sqrt;\nassign ex1_div_rst_zero  = (ex1_op0_tt_zero && ex1_op1_norm ) ||\n                           // (!ex1_expnt0_max && !ex1_op0_cnan && ex1_op1_inf);\n                           (!ex1_op0_inf && !ex1_op0_qnan && !ex1_op0_snan && !ex1_op0_cnan && ex1_op1_inf);\nassign ex1_sqrt_rst_zero = ex1_op0_tt_zero;\n\n//ex1 result is qNaN\n//ex1_nv\n//div_qnan\n//  1.op0 is qnan || op1 is qnan\n//sqrt_qnan\n//  1.op0 is qnan\nassign ex1_result_qnan   = ex1_div_rst_qnan  && ex1_div  ||\n                           ex1_sqrt_rst_qnan && ex1_sqrt ||\n                           ex1_nv;\nassign ex1_div_rst_qnan  = ex1_op0_qnan ||\n                           ex1_op1_qnan;\nassign ex1_sqrt_rst_qnan = ex1_op0_qnan;\n\n//ex1_rst_default_qnan\n//0/0, inf/inf, sqrt negative should get default qNaN\nassign ex1_rst_default_qnan = (ex1_div && ex1_op0_zero && ex1_op1_zero) ||\n                              (ex1_div && ex1_op0_inf  && ex1_op1_inf)  ||\n                              (ex1_sqrt&& ex1_op0_sign && (ex1_op0_norm || ex1_op0_inf));\n\n//ex1 result is inf\n//ex1_dz\n//\n//div_inf\n//  1.op0 is inf && op1 is normal/zero\n//sqrt_inf\n//  1.op0 is inf\nassign ex1_result_inf    = ex1_div_rst_inf  && ex1_div  ||\n                           ex1_sqrt_rst_inf && ex1_sqrt ||\n                           ex1_dz ;\n// assign ex1_div_rst_inf   = ex1_op0_inf && !ex1_expnt1_max && !ex1_op1_cnan;\nassign ex1_div_rst_inf   = ex1_op0_inf && !ex1_op1_inf && !ex1_op1_qnan && !ex1_op1_snan && !ex1_op1_cnan;\nassign ex1_sqrt_rst_inf  = ex1_op0_inf && !ex1_op0_sign;\n\n//ex1 result is lfn\n//ex1_of && round result toward not inc 1\nassign ex1_result_lfn = 1'b0;\n\n//Default_qnan/Standard_qnan Select\nassign ex1_op0_is_snan      = ex1_op0_snan;\nassign ex1_op1_is_snan      = ex1_op1_snan && ex1_div;\nassign ex1_op0_is_qnan      = ex1_op0_qnan;\nassign ex1_op1_is_qnan      = ex1_op1_qnan && ex1_div;\n\n// &CombBeg; @169\nalways @( ex1_op0_is_snan\n       or ex1_op0_cnan\n       or ex1_result_qnan\n       or ex1_op0_is_qnan\n       or ex1_rst_default_qnan\n       or cp0_fpu_xx_dqnan\n       or ex1_op1_cnan\n       or ex1_op1_is_qnan\n       or ex1_op1_is_snan)\nbegin\nif(ex1_rst_default_qnan)\nbegin\n  ex1_result_qnan_op0  = 1'b0;\n  ex1_result_qnan_op1  = 1'b0;\n  ex1_result_cnan      = ex1_result_qnan;\nend\nelse if(ex1_op0_is_snan && cp0_fpu_xx_dqnan)\nbegin\n  ex1_result_qnan_op0  = ex1_result_qnan;\n  ex1_result_qnan_op1  = 1'b0;\n  ex1_result_cnan      = 1'b0;\nend\nelse if(ex1_op1_is_snan && cp0_fpu_xx_dqnan)\nbegin\n  ex1_result_qnan_op0  = 1'b0;\n  ex1_result_qnan_op1  = ex1_result_qnan;\n  ex1_result_cnan      = 1'b0;\nend\nelse if(ex1_op0_is_qnan && cp0_fpu_xx_dqnan)\nbegin\n  ex1_result_qnan_op0  = ex1_result_qnan && !ex1_op0_cnan;\n  ex1_result_qnan_op1  = 1'b0;\n  ex1_result_cnan      = ex1_result_qnan &&  ex1_op0_cnan;\nend\nelse if(ex1_op1_is_qnan && cp0_fpu_xx_dqnan)\nbegin\n  ex1_result_qnan_op0  = 1'b0;\n  ex1_result_qnan_op1  = ex1_result_qnan && !ex1_op1_cnan;\n  ex1_result_cnan      = ex1_result_qnan &&  ex1_op1_cnan;\nend\nelse\nbegin\n  ex1_result_qnan_op0  = 1'b0;\n  ex1_result_qnan_op1  = 1'b0;\n  ex1_result_cnan      = ex1_result_qnan;\nend\n// &CombEnd; @206\nend\n\n\n//Special result should skip SRT logic\nassign ex1_srt_skip = ex1_result_zero ||\n                      ex1_result_qnan ||\n                      ex1_result_lfn  ||\n                      ex1_result_inf;\n// fflags:\n// NV, DZ, OF, UF, NX\nassign ex1_fflags[4:0] = {ex1_nv, ex1_dz, 3'b0};\n// Special Sel[7:0]:\n// qnan_src2, qnan_src1, qnan_src0, cnan, lfn, inf, zero, src2\nassign ex1_special_sel[7:0] = {1'b0, ex1_result_qnan_op1, ex1_result_qnan_op0,\n                               ex1_result_cnan, ex1_result_lfn, ex1_result_inf,\n                               ex1_result_zero, 1'b0};\n// Special Sign[3:0]\n// lfn, inf, zero, src2\nassign ex1_special_sign[3:0] = {ex1_result_sign, ex1_result_sign, ex1_result_sign, 1'b0};\n\n//==========================================================\n//                      Output Signal\n//==========================================================\nassign fdsu_fpu_ex1_fflags[4:0]       = ex1_fflags[4:0];\nassign fdsu_fpu_ex1_special_sel[7:0]  = ex1_special_sel[7:0];\nassign fdsu_fpu_ex1_special_sign[3:0] = ex1_special_sign[3:0];\n\n// &Force(\"output\", \"ex1_op0_norm\"); @233\n// &Force(\"output\", \"ex1_op1_norm\"); @234\n\n// &ModuleEnd; @236\nendmodule\n\n\n\n","lang":"verilog"};
processSrcData(g_data);