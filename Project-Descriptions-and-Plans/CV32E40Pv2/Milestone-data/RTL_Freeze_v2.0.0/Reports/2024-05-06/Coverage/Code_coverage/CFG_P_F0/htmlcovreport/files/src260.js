var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/src/fpnew_opgroup_multifmt_slice.sv","src":"// Copyright 2019 ETH Zurich and University of Bologna.\n//\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// SPDX-License-Identifier: SHL-0.51\n\n// Author: Stefan Mach <smach@iis.ee.ethz.ch>\n\n`include \"common_cells/registers.svh\"\n\nmodule fpnew_opgroup_multifmt_slice #(\n  parameter fpnew_pkg::opgroup_e     OpGroup       = fpnew_pkg::CONV,\n  parameter int unsigned             Width         = 64,\n  // FPU configuration\n  parameter fpnew_pkg::fmt_logic_t   FpFmtConfig   = '1,\n  parameter fpnew_pkg::ifmt_logic_t  IntFmtConfig  = '1,\n  parameter logic                    EnableVectors = 1'b1,\n  parameter logic                    PulpDivsqrt   = 1'b1,\n  parameter int unsigned             NumPipeRegs   = 0,\n  parameter fpnew_pkg::pipe_config_t PipeConfig    = fpnew_pkg::BEFORE,\n  parameter logic                    ExtRegEna     = 1'b0,\n  parameter type                     TagType       = logic,\n  // Do not change\n  localparam int unsigned NUM_OPERANDS = fpnew_pkg::num_operands(OpGroup),\n  localparam int unsigned NUM_FORMATS  = fpnew_pkg::NUM_FP_FORMATS,\n  localparam int unsigned NUM_SIMD_LANES = fpnew_pkg::max_num_lanes(Width, FpFmtConfig, EnableVectors),\n  localparam type         MaskType     = logic [NUM_SIMD_LANES-1:0],\n  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs\n) (\n  input logic                                     clk_i,\n  input logic                                     rst_ni,\n  // Input signals\n  input logic [NUM_OPERANDS-1:0][Width-1:0]       operands_i,\n  input logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed_i,\n  input fpnew_pkg::roundmode_e                    rnd_mode_i,\n  input fpnew_pkg::operation_e                    op_i,\n  input logic                                     op_mod_i,\n  input fpnew_pkg::fp_format_e                    src_fmt_i,\n  input fpnew_pkg::fp_format_e                    dst_fmt_i,\n  input fpnew_pkg::int_format_e                   int_fmt_i,\n  input logic                                     vectorial_op_i,\n  input TagType                                   tag_i,\n  input MaskType                                  simd_mask_i,\n  // Input Handshake\n  input  logic                                    in_valid_i,\n  output logic                                    in_ready_o,\n  input  logic                                    flush_i,\n  // Output signals\n  output logic [Width-1:0]                        result_o,\n  output fpnew_pkg::status_t                      status_o,\n  output logic                                    extension_bit_o,\n  output TagType                                  tag_o,\n  // Output handshake\n  output logic                                    out_valid_o,\n  input  logic                                    out_ready_i,\n  // Indication of valid data in flight\n  output logic                                    busy_o,\n  // External register enable override\n  input  logic [ExtRegEnaWidth-1:0]               reg_ena_i\n);\n\n  if ((OpGroup == fpnew_pkg::DIVSQRT) && !PulpDivsqrt &&\n      !((FpFmtConfig[0] == 1) && (FpFmtConfig[1:NUM_FORMATS-1] == '0))) begin\n    $fatal(1, \"T-Head-based DivSqrt unit supported only in FP32-only configurations. \\\nSet PulpDivsqrt to 1 not to use the PULP DivSqrt unit \\\nor set Features.FpFmtMask to support only FP32\");\n  end\n\n  localparam int unsigned MAX_FP_WIDTH   = fpnew_pkg::max_fp_width(FpFmtConfig);\n  localparam int unsigned MAX_INT_WIDTH  = fpnew_pkg::max_int_width(IntFmtConfig);\n  localparam int unsigned NUM_LANES = fpnew_pkg::max_num_lanes(Width, FpFmtConfig, 1'b1);\n  localparam int unsigned NUM_INT_FORMATS = fpnew_pkg::NUM_INT_FORMATS;\n  // We will send the format information along with the data\n  localparam int unsigned FMT_BITS =\n      fpnew_pkg::maximum($clog2(NUM_FORMATS), $clog2(NUM_INT_FORMATS));\n  localparam int unsigned AUX_BITS = FMT_BITS + 2; // also add vectorial and integer flags\n\n  logic [NUM_LANES-1:0] lane_in_ready, lane_out_valid, divsqrt_done, divsqrt_ready; // Handshake signals for the lanes\n  logic                 vectorial_op;\n  logic [FMT_BITS-1:0]  dst_fmt; // destination format to pass along with operation\n  logic [AUX_BITS-1:0]  aux_data;\n\n  // additional flags for CONV\n  logic       dst_fmt_is_int, dst_is_cpk;\n  logic [1:0] dst_vec_op; // info for vectorial results (for packing)\n  logic [2:0] target_aux_d;\n  logic       is_up_cast, is_down_cast;\n\n  logic [NUM_FORMATS-1:0][Width-1:0]     fmt_slice_result;\n  logic [NUM_INT_FORMATS-1:0][Width-1:0] ifmt_slice_result;\n\n  logic [Width-1:0] conv_target_d, conv_target_q; // vectorial conversions update a register\n\n  fpnew_pkg::status_t [NUM_LANES-1:0]   lane_status;\n  logic   [NUM_LANES-1:0]               lane_ext_bit; // only the first one is actually used\n  TagType [NUM_LANES-1:0]               lane_tags; // only the first one is actually used\n  logic   [NUM_LANES-1:0]               lane_masks;\n  logic   [NUM_LANES-1:0][AUX_BITS-1:0] lane_aux; // only the first one is actually used\n  logic   [NUM_LANES-1:0]               lane_busy; // dito\n\n  logic                result_is_vector;\n  logic [FMT_BITS-1:0] result_fmt;\n  logic                result_fmt_is_int, result_is_cpk;\n  logic [1:0]          result_vec_op; // info for vectorial results (for packing)\n\n  logic simd_synch_rdy, simd_synch_done;\n\n  // -----------\n  // Input Side\n  // -----------\n  assign in_ready_o   = lane_in_ready[0]; // Upstream ready is given by first lane\n  assign vectorial_op = vectorial_op_i & EnableVectors; // only do vectorial stuff if enabled\n\n  // Cast-and-Pack ops are encoded in operation and modifier\n  assign dst_fmt_is_int = (OpGroup == fpnew_pkg::CONV) & (op_i == fpnew_pkg::F2I);\n  assign dst_is_cpk     = (OpGroup == fpnew_pkg::CONV) & (op_i == fpnew_pkg::CPKAB ||\n                                                          op_i == fpnew_pkg::CPKCD);\n  assign dst_vec_op     = (OpGroup == fpnew_pkg::CONV) & {(op_i == fpnew_pkg::CPKCD), op_mod_i};\n\n  assign is_up_cast   = (fpnew_pkg::fp_width(dst_fmt_i) > fpnew_pkg::fp_width(src_fmt_i));\n  assign is_down_cast = (fpnew_pkg::fp_width(dst_fmt_i) < fpnew_pkg::fp_width(src_fmt_i));\n\n  // The destination format is the int format for F2I casts\n  assign dst_fmt    = dst_fmt_is_int ? int_fmt_i : dst_fmt_i;\n\n  // The data sent along consists of the vectorial flag and format bits\n  assign aux_data      = {dst_fmt_is_int, vectorial_op, dst_fmt};\n  assign target_aux_d  = {dst_vec_op, dst_is_cpk};\n\n  // CONV passes one operand for assembly after the unit: opC for cpk, opB for others\n  if (OpGroup == fpnew_pkg::CONV) begin : conv_target\n    assign conv_target_d = dst_is_cpk ? operands_i[2] : operands_i[1];\n  end else begin : not_conv_target\n    assign conv_target_d = '0;\n  end\n\n  // For 2-operand units, prepare boxing info\n  logic [NUM_FORMATS-1:0]      is_boxed_1op;\n  logic [NUM_FORMATS-1:0][1:0] is_boxed_2op;\n\n  always_comb begin : boxed_2op\n    for (int fmt = 0; fmt < NUM_FORMATS; fmt++) begin\n      is_boxed_1op[fmt] = is_boxed_i[fmt][0];\n      is_boxed_2op[fmt] = is_boxed_i[fmt][1:0];\n    end\n  end\n\n  // ---------------\n  // Generate Lanes\n  // ---------------\n  for (genvar lane = 0; lane < int'(NUM_LANES); lane++) begin : gen_num_lanes\n    localparam int unsigned LANE = unsigned'(lane); // unsigned to please the linter\n    // Get a mask of active formats for this lane\n    localparam fpnew_pkg::fmt_logic_t ACTIVE_FORMATS =\n        fpnew_pkg::get_lane_formats(Width, FpFmtConfig, LANE);\n    localparam fpnew_pkg::ifmt_logic_t ACTIVE_INT_FORMATS =\n        fpnew_pkg::get_lane_int_formats(Width, FpFmtConfig, IntFmtConfig, LANE);\n    localparam int unsigned MAX_WIDTH = fpnew_pkg::max_fp_width(ACTIVE_FORMATS);\n\n    // Cast-specific parameters\n    localparam fpnew_pkg::fmt_logic_t CONV_FORMATS =\n        fpnew_pkg::get_conv_lane_formats(Width, FpFmtConfig, LANE);\n    localparam fpnew_pkg::ifmt_logic_t CONV_INT_FORMATS =\n        fpnew_pkg::get_conv_lane_int_formats(Width, FpFmtConfig, IntFmtConfig, LANE);\n    localparam int unsigned CONV_WIDTH = fpnew_pkg::max_fp_width(CONV_FORMATS);\n\n    // Lane parameters from Opgroup\n    localparam fpnew_pkg::fmt_logic_t LANE_FORMATS = (OpGroup == fpnew_pkg::CONV)\n                                                     ? CONV_FORMATS : ACTIVE_FORMATS;\n    localparam int unsigned LANE_WIDTH = (OpGroup == fpnew_pkg::CONV) ? CONV_WIDTH : MAX_WIDTH;\n\n    logic [LANE_WIDTH-1:0] local_result; // lane-local results\n\n    // Generate instances only if needed, lane 0 always generated\n    if ((lane == 0) || EnableVectors) begin : active_lane\n      logic in_valid, out_valid, out_ready; // lane-local handshake\n\n      logic [NUM_OPERANDS-1:0][LANE_WIDTH-1:0] local_operands;  // lane-local oprands\n      logic [LANE_WIDTH-1:0]                   op_result;       // lane-local results\n      fpnew_pkg::status_t                      op_status;\n\n      assign in_valid = in_valid_i & ((lane == 0) | vectorial_op); // upper lanes only for vectors\n\n      // Slice out the operands for this lane, upper bits are ignored in the unit\n      always_comb begin : prepare_input\n        for (int unsigned i = 0; i < NUM_OPERANDS; i++) begin\n          if (i == 2) begin\n            local_operands[i] = operands_i[i] >> LANE*fpnew_pkg::fp_width(dst_fmt_i);\n          end else begin\n            local_operands[i] = operands_i[i] >> LANE*fpnew_pkg::fp_width(src_fmt_i);\n          end\n        end\n\n        // override operand 0 for some conversions\n        if (OpGroup == fpnew_pkg::CONV) begin\n          // Source is an integer\n          if (op_i == fpnew_pkg::I2F) begin\n            local_operands[0] = operands_i[0] >> LANE*fpnew_pkg::int_width(int_fmt_i);\n          // vectorial F2F up casts\n          end else if (op_i == fpnew_pkg::F2F) begin\n            if (vectorial_op && op_mod_i && is_up_cast) begin // up cast with upper half\n              local_operands[0] = operands_i[0] >> LANE*fpnew_pkg::fp_width(src_fmt_i) +\n                                                   MAX_FP_WIDTH/2;\n            end\n          // CPK\n          end else if (dst_is_cpk) begin\n            if (lane == 1) begin\n              local_operands[0] = operands_i[1][LANE_WIDTH-1:0]; // using opB as second argument\n            end\n          end\n        end\n      end\n\n      // Instantiate the operation from the selected opgroup\n      if (OpGroup == fpnew_pkg::ADDMUL) begin : lane_instance\n        fpnew_fma_multi #(\n          .FpFmtConfig ( LANE_FORMATS         ),\n          .NumPipeRegs ( NumPipeRegs          ),\n          .PipeConfig  ( PipeConfig           ),\n          .TagType     ( TagType              ),\n          .AuxType     ( logic [AUX_BITS-1:0] )\n        ) i_fpnew_fma_multi (\n          .clk_i,\n          .rst_ni,\n          .operands_i      ( local_operands  ),\n          .is_boxed_i,\n          .rnd_mode_i,\n          .op_i,\n          .op_mod_i,\n          .src_fmt_i,\n          .dst_fmt_i,\n          .tag_i,\n          .mask_i          ( simd_mask_i[lane]   ),\n          .aux_i           ( aux_data            ),\n          .in_valid_i      ( in_valid            ),\n          .in_ready_o      ( lane_in_ready[lane] ),\n          .flush_i,\n          .result_o        ( op_result           ),\n          .status_o        ( op_status           ),\n          .extension_bit_o ( lane_ext_bit[lane]  ),\n          .tag_o           ( lane_tags[lane]     ),\n          .mask_o          ( lane_masks[lane]    ),\n          .aux_o           ( lane_aux[lane]      ),\n          .out_valid_o     ( out_valid           ),\n          .out_ready_i     ( out_ready           ),\n          .busy_o          ( lane_busy[lane]     ),\n          .reg_ena_i\n        );\n\n      end else if (OpGroup == fpnew_pkg::DIVSQRT) begin : lane_instance\n        if (!PulpDivsqrt && LANE_FORMATS[0] && (LANE_FORMATS[1:fpnew_pkg::NUM_FP_FORMATS-1] == '0)) begin\n          // The T-head-based DivSqrt unit is supported only in FP32-only configurations\n          fpnew_divsqrt_th_32 #(\n            .NumPipeRegs ( NumPipeRegs          ),\n            .PipeConfig  ( PipeConfig           ),\n            .TagType     ( TagType              ),\n            .AuxType     ( logic [AUX_BITS-1:0] )\n          ) i_fpnew_divsqrt_multi_th (\n            .clk_i,\n            .rst_ni,\n            .operands_i      ( local_operands[1:0] ), // 2 operands\n            .is_boxed_i      ( is_boxed_2op        ), // 2 operands\n            .rnd_mode_i,\n            .op_i,\n            .tag_i,\n            .mask_i          ( simd_mask_i[lane]   ),\n            .aux_i           ( aux_data            ),\n            .in_valid_i      ( in_valid            ),\n            .in_ready_o      ( lane_in_ready[lane] ),\n            .flush_i,\n            .result_o        ( op_result           ),\n            .status_o        ( op_status           ),\n            .extension_bit_o ( lane_ext_bit[lane]  ),\n            .tag_o           ( lane_tags[lane]     ),\n            .mask_o          ( lane_masks[lane]    ),\n            .aux_o           ( lane_aux[lane]      ),\n            .out_valid_o     ( out_valid           ),\n            .out_ready_i     ( out_ready           ),\n            .busy_o          ( lane_busy[lane]     ),\n            .reg_ena_i\n          );\n        end else begin\n          fpnew_divsqrt_multi #(\n            .FpFmtConfig ( LANE_FORMATS         ),\n            .NumPipeRegs ( NumPipeRegs          ),\n            .PipeConfig  ( PipeConfig           ),\n            .TagType     ( TagType              ),\n            .AuxType     ( logic [AUX_BITS-1:0] )\n          ) i_fpnew_divsqrt_multi (\n            .clk_i,\n            .rst_ni,\n            .operands_i       ( local_operands[1:0] ), // 2 operands\n            .is_boxed_i       ( is_boxed_2op        ), // 2 operands\n            .rnd_mode_i,\n            .op_i,\n            .dst_fmt_i,\n            .tag_i,\n            .mask_i           ( simd_mask_i[lane]   ),\n            .aux_i            ( aux_data            ),\n            .vectorial_op_i   ( vectorial_op        ),\n            .in_valid_i       ( in_valid            ),\n            .in_ready_o       ( lane_in_ready[lane] ),\n            .divsqrt_done_o   ( divsqrt_done[lane]  ),\n            .simd_synch_done_i( simd_synch_done     ),\n            .divsqrt_ready_o  ( divsqrt_ready[lane] ),\n            .simd_synch_rdy_i ( simd_synch_rdy      ),\n            .flush_i,\n            .result_o         ( op_result           ),\n            .status_o         ( op_status           ),\n            .extension_bit_o  ( lane_ext_bit[lane]  ),\n            .tag_o            ( lane_tags[lane]     ),\n            .mask_o           ( lane_masks[lane]    ),\n            .aux_o            ( lane_aux[lane]      ),\n            .out_valid_o      ( out_valid           ),\n            .out_ready_i      ( out_ready           ),\n            .busy_o           ( lane_busy[lane]     ),\n            .reg_ena_i\n          );\n        end\n      end else if (OpGroup == fpnew_pkg::NONCOMP) begin : lane_instance\n\n      end else if (OpGroup == fpnew_pkg::CONV) begin : lane_instance\n        fpnew_cast_multi #(\n          .FpFmtConfig  ( LANE_FORMATS         ),\n          .IntFmtConfig ( CONV_INT_FORMATS     ),\n          .NumPipeRegs  ( NumPipeRegs          ),\n          .PipeConfig   ( PipeConfig           ),\n          .TagType      ( TagType              ),\n          .AuxType      ( logic [AUX_BITS-1:0] )\n        ) i_fpnew_cast_multi (\n          .clk_i,\n          .rst_ni,\n          .operands_i      ( local_operands[0]   ),\n          .is_boxed_i      ( is_boxed_1op        ),\n          .rnd_mode_i,\n          .op_i,\n          .op_mod_i,\n          .src_fmt_i,\n          .dst_fmt_i,\n          .int_fmt_i,\n          .tag_i,\n          .mask_i          ( simd_mask_i[lane]   ),\n          .aux_i           ( aux_data            ),\n          .in_valid_i      ( in_valid            ),\n          .in_ready_o      ( lane_in_ready[lane] ),\n          .flush_i,\n          .result_o        ( op_result           ),\n          .status_o        ( op_status           ),\n          .extension_bit_o ( lane_ext_bit[lane]  ),\n          .tag_o           ( lane_tags[lane]     ),\n          .mask_o          ( lane_masks[lane]    ),\n          .aux_o           ( lane_aux[lane]      ),\n          .out_valid_o     ( out_valid           ),\n          .out_ready_i     ( out_ready           ),\n          .busy_o          ( lane_busy[lane]     ),\n          .reg_ena_i\n        );\n      end // ADD OTHER OPTIONS HERE\n\n      // Handshakes are only done if the lane is actually used\n      assign out_ready            = out_ready_i & ((lane == 0) | result_is_vector);\n      assign lane_out_valid[lane] = out_valid & ((lane == 0) | result_is_vector);\n\n      // Properly NaN-box or sign-extend the slice result if not in use\n      assign local_result      = (lane_out_valid[lane] | ExtRegEna) ? op_result : '{default: lane_ext_bit[0]};\n      assign lane_status[lane] = (lane_out_valid[lane] | ExtRegEna) ? op_status : '0;\n\n    // Otherwise generate constant sign-extension\n    end else begin : inactive_lane\n      assign lane_out_valid[lane] = 1'b0; // unused lane\n      assign lane_in_ready[lane]  = 1'b0; // unused lane\n      assign lane_aux[lane]       = 1'b0; // unused lane\n      assign lane_masks[lane]     = 1'b1; // unused lane\n      assign lane_tags[lane]      = 1'b0; // unused lane\n      assign divsqrt_done[lane]   = 1'b0; // unused lane\n      assign divsqrt_ready[lane]  = 1'b0; // unused lane\n      assign lane_ext_bit[lane]   = 1'b1; // NaN-box unused lane\n      assign local_result         = {(LANE_WIDTH){lane_ext_bit[0]}}; // sign-extend/nan box\n      assign lane_status[lane]    = '0;\n      assign lane_busy[lane]      = 1'b0;\n    end\n\n    // Generate result packing depending on float format\n    for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : pack_fp_result\n      // Set up some constants\n      localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));\n      // only for active formats within the lane\n      if (ACTIVE_FORMATS[fmt]) begin\n        assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =\n            local_result[FP_WIDTH-1:0];\n      end else if ((LANE+1)*FP_WIDTH <= Width) begin\n        assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =\n            '{default: lane_ext_bit[LANE]};\n      end else if (LANE*FP_WIDTH < Width) begin\n        assign fmt_slice_result[fmt][Width-1:LANE*FP_WIDTH] =\n            '{default: lane_ext_bit[LANE]};\n      end\n    end\n\n    // Generate result packing depending on integer format\n    if (OpGroup == fpnew_pkg::CONV) begin : int_results_enabled\n      for (genvar ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin : pack_int_result\n        // Set up some constants\n        localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));\n        if (ACTIVE_INT_FORMATS[ifmt]) begin\n          assign ifmt_slice_result[ifmt][(LANE+1)*INT_WIDTH-1:LANE*INT_WIDTH] =\n            local_result[INT_WIDTH-1:0];\n        end else if ((LANE+1)*INT_WIDTH <= Width) begin\n          assign ifmt_slice_result[ifmt][(LANE+1)*INT_WIDTH-1:LANE*INT_WIDTH] = '0;\n        end else if (LANE*INT_WIDTH < Width) begin\n          assign ifmt_slice_result[ifmt][Width-1:LANE*INT_WIDTH] = '0;\n        end\n      end\n    end\n  end\n\n  // Extend slice result if needed\n  for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : extend_fp_result\n    // Set up some constants\n    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));\n    if (NUM_LANES*FP_WIDTH < Width)\n      assign fmt_slice_result[fmt][Width-1:NUM_LANES*FP_WIDTH] = '{default: lane_ext_bit[0]};\n  end\n\n  for (genvar ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin : extend_or_mute_int_result\n    // Mute int results if unused\n    if (OpGroup != fpnew_pkg::CONV) begin : mute_int_result\n      assign ifmt_slice_result[ifmt] = '0;\n\n    // Extend slice result if needed\n    end else begin : extend_int_result\n      // Set up some constants\n      localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));\n      if (NUM_LANES*INT_WIDTH < Width)\n        assign ifmt_slice_result[ifmt][Width-1:NUM_LANES*INT_WIDTH] = '0;\n    end\n  end\n\n  // Bypass lanes with target operand for vectorial casts\n  if (OpGroup == fpnew_pkg::CONV) begin : target_regs\n    // Bypass pipeline signals, index i holds signal after i register stages\n    logic [0:NumPipeRegs][Width-1:0] byp_pipe_target_q;\n    logic [0:NumPipeRegs][2:0]       byp_pipe_aux_q;\n    logic [0:NumPipeRegs]            byp_pipe_valid_q;\n    // Ready signal is combinatorial for all stages\n    logic [0:NumPipeRegs] byp_pipe_ready;\n\n    // Input stage: First element of pipeline is taken from inputs\n    assign byp_pipe_target_q[0]  = conv_target_d;\n    assign byp_pipe_aux_q[0]     = target_aux_d;\n    assign byp_pipe_valid_q[0]   = in_valid_i & vectorial_op;\n    // Generate the register stages\n    for (genvar i = 0; i < NumPipeRegs; i++) begin : gen_bypass_pipeline\n      // Internal register enable for this stage\n      logic reg_ena;\n      // Determine the ready signal of the current stage - advance the pipeline:\n      // 1. if the next stage is ready for our data\n      // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n      assign byp_pipe_ready[i] = byp_pipe_ready[i+1] | ~byp_pipe_valid_q[i+1];\n      // Valid: enabled by ready signal, synchronous clear with the flush signal\n      `FFLARNC(byp_pipe_valid_q[i+1], byp_pipe_valid_q[i], byp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n      // Enable register if pipleine ready and a valid data item is present\n      assign reg_ena = (byp_pipe_ready[i] & byp_pipe_valid_q[i]) | reg_ena_i[i];\n      // Generate the pipeline registers within the stages, use enable-registers\n      `FFL(byp_pipe_target_q[i+1],  byp_pipe_target_q[i],  reg_ena, '0)\n      `FFL(byp_pipe_aux_q[i+1],     byp_pipe_aux_q[i],     reg_ena, '0)\n    end\n    // Output stage: Ready travels backwards from output side, driven by downstream circuitry\n    assign byp_pipe_ready[NumPipeRegs] = out_ready_i & result_is_vector;\n    // Output stage: assign module outputs\n    assign conv_target_q = byp_pipe_target_q[NumPipeRegs];\n\n    // decode the aux data\n    assign {result_vec_op, result_is_cpk} = byp_pipe_aux_q[NumPipeRegs];\n  end else begin : no_conv\n    assign {result_vec_op, result_is_cpk} = '0;\n    assign conv_target_q = '0;\n  end\n\n  if (PulpDivsqrt) begin\n    // Synch lanes if there is more than one\n    assign simd_synch_rdy  = EnableVectors ? &divsqrt_ready : divsqrt_ready[0];\n    assign simd_synch_done = EnableVectors ? &divsqrt_done  : divsqrt_done[0];\n  end else begin\n    // Unused (alternative divider only supported for scalar FP32 divsqrt)\n    assign simd_synch_rdy  = '0;\n    assign simd_synch_done = '0;\n  end\n\n  // ------------\n  // Output Side\n  // ------------\n  assign {result_fmt_is_int, result_is_vector, result_fmt} = lane_aux[0];\n\n  assign result_o = result_fmt_is_int\n                    ? ifmt_slice_result[result_fmt]\n                    : fmt_slice_result[result_fmt];\n\n  assign extension_bit_o = lane_ext_bit[0]; // don't care about upper ones\n  assign tag_o           = lane_tags[0];    // don't care about upper ones\n  assign busy_o          = (| lane_busy);\n\n  assign out_valid_o     = lane_out_valid[0]; // don't care about upper ones\n\n  // Collapse the status\n  always_comb begin : output_processing\n    // Collapse the status\n    automatic fpnew_pkg::status_t temp_status;\n    temp_status = '0;\n    for (int i = 0; i < int'(NUM_LANES); i++)\n      temp_status |= lane_status[i] & {5{lane_masks[i]}};\n    status_o = temp_status;\n  end\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);