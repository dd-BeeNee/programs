var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_prefetch_controller.sv","src":"// Copyright 2020 Silicon Labs, Inc.\n//\n// This file, and derivatives thereof are licensed under the\n// Solderpad License, Version 2.0 (the \"License\").\n//\n// Use of this file means you agree to the terms and conditions\n// of the license and are in full compliance with the License.\n//\n// You may obtain a copy of the License at:\n//\n//     https://solderpad.org/licenses/SHL-2.0/\n//\n// Unless required by applicable law or agreed to in writing, software\n// and hardware implementations thereof distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n// OF ANY KIND, EITHER EXPRESSED OR IMPLIED.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Arjan Bink - arjan.bink@silabs.com                         //\n//                                                                            //\n// Design Name:    Prefetcher Controller                                      //\n// Project Name:   CV32E40P                                                   //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Prefetch Controller which receives control flow            //\n//                 information (req_i, branch_*) from the Fetch stage         //\n//                 and based on that performs transactions requests to the    //\n//                 bus interface adapter instructions. Prefetching based on   //\n//                 incrementing addressed is performed when no new control    //\n//                 flow change is requested. New transaction requests are     //\n//                 only performed if it can be guaranteed that the fetch FIFO //\n//                 will not overflow (resulting in a maximum of DEPTH         //\n//                 outstanding transactions.                                  //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_prefetch_controller #(\n    parameter PULP_OBI = 0,  // Legacy PULP OBI behavior\n    parameter COREV_PULP = 1,  // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding cv.elw)\n    parameter DEPTH = 4,  // Prefetch FIFO Depth\n    parameter FIFO_ADDR_DEPTH = (DEPTH > 1) ? $clog2(DEPTH) : 1  // Do not override this parameter\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // Fetch stage interface\n    input  logic        req_i,  // Fetch stage requests instructions\n    input  logic        branch_i,  // Taken branch\n    input  logic [31:0] branch_addr_i,  // Taken branch address (only valid when branch_i = 1)\n    output logic        busy_o,  // Prefetcher busy\n\n    // HW loop signals\n    input logic        hwlp_jump_i,\n    input logic [31:0] hwlp_target_i,\n\n    // Transaction request interface\n    output logic trans_valid_o,  // Transaction request valid (to bus interface adapter)\n    input  logic                     trans_ready_i,           // Transaction request ready (transaction gets accepted when trans_valid_o and trans_ready_i are both 1)\n    output logic [31:0]              trans_addr_o,            // Transaction address (only valid when trans_valid_o = 1). No stability requirements.\n\n    // Transaction response interface\n    input logic resp_valid_i,  // Note: Consumer is assumed to be 'ready' whenever resp_valid_i = 1\n\n    // Fetch interface is ready/valid\n    input  logic fetch_ready_i,\n    output logic fetch_valid_o,\n\n    // FIFO interface\n    output logic fifo_push_o,  // PUSH an instruction into the FIFO\n    output logic fifo_pop_o,  // POP an instruction from the FIFO\n    output logic fifo_flush_o,  // Flush the FIFO\n    output logic                     fifo_flush_but_first_o,  // Flush the FIFO, but keep the first instruction if present\n    input logic [FIFO_ADDR_DEPTH:0] fifo_cnt_i,  // Number of valid items/words in the prefetch FIFO\n    input logic fifo_empty_i  // FIFO is empty\n);\n\n  import cv32e40p_pkg::*;\n\n  prefetch_state_e state_q, next_state;\n\n  logic [FIFO_ADDR_DEPTH:0] cnt_q;  // Transaction counter\n  logic [FIFO_ADDR_DEPTH:0] next_cnt;  // Next value for cnt_q\n  logic                          count_up;                        // Increment outstanding transaction count by 1 (can happen at same time as count_down)\n  logic                          count_down;                      // Decrement outstanding transaction count by 1 (can happen at same time as count_up)\n\n  logic  [FIFO_ADDR_DEPTH:0]     flush_cnt_q;                     // Response flush counter (to flush speculative responses after branch)\n  logic [FIFO_ADDR_DEPTH:0] next_flush_cnt;  // Next value for flush_cnt_q\n\n  // Transaction address\n  logic [31:0] trans_addr_q, trans_addr_incr;\n\n  // Word-aligned branch target address\n  logic [31:0] aligned_branch_addr;  // Word aligned branch target address\n\n  // FIFO auxiliary signal\n  logic fifo_valid;  // FIFO output valid (if !fifo_empty)\n  logic [FIFO_ADDR_DEPTH:0]      fifo_cnt_masked;                 // FIFO_cnt signal, masked when we are branching to allow a new memory request in that cycle\n\n  // HW loop support signals\n  logic hwlp_wait_resp_flush;  // Trigger for the delayed flush\n  logic hwlp_flush_after_resp;  // Wait for HWLP_END and then flush the wrong granted requests\n  logic [FIFO_ADDR_DEPTH:0]      hwlp_flush_cnt_delayed_q;        // The number of outstanding requests to flush when HWLP_END is returned\n  logic hwlp_flush_resp_delayed;  // Actual delayed flush\n  logic hwlp_flush_resp;  // Response flush counter when hwlp occurs\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Prefetch buffer status\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Busy if there are ongoing (or potentially outstanding) transfers\n  assign busy_o = (cnt_q != 3'b000) || trans_valid_o;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // IF/ID interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Fectch valid control. Fetch never valid if jumping or flushing responses.\n  // Fetch valid if there are instructions in FIFO or there is an incoming\n  // instruction from memory.\n  assign fetch_valid_o = (fifo_valid || resp_valid_i) && !(branch_i || (flush_cnt_q > 0));\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Transaction request generation\n  //\n  // Assumes that corresponding response is at least 1 cycle after request\n  //\n  // - Only request transaction when fetch stage requires fetch (req_i), and\n  // - make sure that FIFO (cv32e40p_fetch_fifo) never overflows (fifo_cnt_i + cnt_q < DEPTH)\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Prefetcher will only perform word fetches\n  assign aligned_branch_addr = {branch_addr_i[31:2], 2'b00};\n\n  // Increment address (always word fetch)\n  assign trans_addr_incr = {trans_addr_q[31:2], 2'b00} + 32'd4;\n\n  // Transaction request generation\n  generate\n    if (PULP_OBI == 0) begin : gen_no_pulp_obi\n      // OBI compatible (avoids combinatorial path from instr_rvalid_i to instr_req_o).\n      // Multiple trans_* transactions can be issued (and accepted) before a response\n      // (resp_*) is received.\n      assign trans_valid_o = req_i && (fifo_cnt_masked + cnt_q < DEPTH);\n    end else begin : gen_pulp_obi\n      // Legacy PULP OBI behavior, i.e. only issue subsequent transaction if preceding transfer\n      // is about to finish (re-introducing timing critical path from instr_rvalid_i to instr_req_o)\n      assign trans_valid_o = (cnt_q == 3'b000) ? req_i && (fifo_cnt_masked + cnt_q < DEPTH) :\n                                                 req_i && (fifo_cnt_masked + cnt_q < DEPTH) && resp_valid_i;\n    end\n  endgenerate\n\n  // Optimization:\n  // fifo_cnt is used to understand if we can perform new memory requests\n  // When branching, we flush both the FIFO and the outstanding requests. Therefore,\n  // there is surely space for a new request.\n  // Masking fifo_cnt in this case allows for making a new request when the FIFO\n  // is not empty and we are jumping, and (fifo_cnt_i + cnt_q == DEPTH)\n  assign fifo_cnt_masked = (branch_i || hwlp_jump_i) ? '0 : fifo_cnt_i;\n\n  // FSM (state_q, next_state) to control OBI A channel signals.\n  always_comb begin\n    next_state   = state_q;\n    trans_addr_o = trans_addr_q;\n\n    case (state_q)\n      // Default state (pass on branch target address or transaction with incremented address)\n      IDLE: begin\n        begin\n          if (branch_i) begin\n            // Jumps must have the highest priority (e.g. an interrupt must\n            // have higher priority than a HW-loop branch)\n            trans_addr_o = aligned_branch_addr;\n          end else if (hwlp_jump_i) begin\n            trans_addr_o = hwlp_target_i;\n          end else begin\n            trans_addr_o = trans_addr_incr;\n          end\n        end\n        if ((branch_i || hwlp_jump_i) && !(trans_valid_o && trans_ready_i)) begin\n          // Taken branch, but transaction not yet accepted by bus interface adapter.\n          next_state = BRANCH_WAIT;\n        end\n      end  // case: IDLE\n\n      BRANCH_WAIT: begin\n        // Replay previous branch target address (trans_addr_q) or new branch address (this can\n        // occur if for example an interrupt is taken right after a taken jump which did not\n        // yet have its target address accepted by the bus interface adapter.\n        trans_addr_o = branch_i ? aligned_branch_addr : trans_addr_q;\n        if (trans_valid_o && trans_ready_i) begin\n          // Transaction with branch target address has been accepted. Start regular prefetch again.\n          next_state = IDLE;\n        end\n      end  // case: BRANCH_WAIT\n    endcase\n  end\n\n  //////////////////////////////////////////////////////////////////////////////\n  // FIFO management\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Pass on response transfer directly to FIFO (which should be ready, otherwise\n  // the corresponding transfer would not have been requested via trans_valid_o).\n  // Upon a branch (branch_i) all incoming responses (resp_valid_i) are flushed\n  // until the flush count is 0 again. (The flush count is initialized with the\n  // number of outstanding transactions at the time of the branch).\n  assign fifo_valid = !fifo_empty_i;\n  assign fifo_push_o = resp_valid_i && (fifo_valid || !fetch_ready_i) && !(branch_i || (flush_cnt_q > 0));\n  assign fifo_pop_o = fifo_valid && fetch_ready_i;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Counter (cnt_q, next_cnt) to count number of outstanding OBI transactions\n  // (maximum = DEPTH)\n  //\n  // Counter overflow is prevented by limiting the number of outstanding transactions\n  // to DEPTH. Counter underflow is prevented by the assumption that resp_valid_i = 1\n  // will only occur in response to accepted transfer request (as per the OBI protocol).\n  //////////////////////////////////////////////////////////////////////////////\n\n  assign count_up = trans_valid_o && trans_ready_i;  // Increment upon accepted transfer request\n  assign count_down = resp_valid_i;  // Decrement upon accepted transfer response\n\n  always_comb begin\n    case ({\n      count_up, count_down\n    })\n      2'b00: begin\n        next_cnt = cnt_q;\n      end\n      2'b01: begin\n        next_cnt = cnt_q - 1'b1;\n      end\n      2'b10: begin\n        next_cnt = cnt_q + 1'b1;\n      end\n      2'b11: begin\n        next_cnt = cnt_q;\n      end\n    endcase\n  end\n\n  generate\n    if (COREV_PULP) begin : gen_hwlp\n\n      // Flush the FIFO if it is not empty and we are hwlp branching.\n      // If HWLP_END is not going to ID, save it from the flush.\n      // Don't flush the FIFO if it is empty (maybe we must accept\n      // HWLP_end from the memory in this cycle)\n      assign fifo_flush_o           = branch_i || (hwlp_jump_i && !fifo_empty_i && fifo_pop_o);\n      assign fifo_flush_but_first_o = (hwlp_jump_i && !fifo_empty_i && !fifo_pop_o);\n\n      //////////////////////////////////////////////////////////////////////////////\n      // HWLP main resp flush controller\n      //////////////////////////////////////////////////////////////////////////////\n\n      // If HWLP_END-4 is in ID and HWLP_END is being/was returned by the memory\n      // we can flush all the eventual outstanding requests up to now\n      assign hwlp_flush_resp        = hwlp_jump_i && !(fifo_empty_i && !resp_valid_i);\n\n      //////////////////////////////////////////////////////////////////////////////\n      // HWLP delayed flush controller\n      //////////////////////////////////////////////////////////////////////////////\n\n      // If HWLP_END-4 is in ID and HWLP_END has not been returned yet,\n      // save the present number of outstanding requests (subtract the HWLP_END one).\n      // Wait for HWLP_END then flush the saved number of (wrong) outstanding requests\n      assign hwlp_wait_resp_flush   = hwlp_jump_i && (fifo_empty_i && !resp_valid_i);\n\n      always_ff @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n          hwlp_flush_after_resp    <= 1'b0;\n          hwlp_flush_cnt_delayed_q <= 2'b00;\n        end else begin\n          if (branch_i) begin\n            // Reset the flush request if an interrupt is taken\n            hwlp_flush_after_resp    <= 1'b0;\n            hwlp_flush_cnt_delayed_q <= 2'b00;\n          end else begin\n            if (hwlp_wait_resp_flush) begin\n              hwlp_flush_after_resp    <= 1'b1;\n              // cnt_q > 0 checked by an assertion\n              hwlp_flush_cnt_delayed_q <= cnt_q - 1'b1;\n            end else begin\n              // Reset the delayed flush request when it's completed\n              if (hwlp_flush_resp_delayed) begin\n                hwlp_flush_after_resp    <= 1'b0;\n                hwlp_flush_cnt_delayed_q <= 2'b00;\n              end\n            end\n          end\n        end\n      end\n\n      // This signal is masked by branch_i in the flush counter process,\n      // because if an interrupt occurs during a delayed flush, the interrupt\n      // is served first so the flush should be normal (caused by branch_i)\n      assign hwlp_flush_resp_delayed = hwlp_flush_after_resp && resp_valid_i;\n\n    end else begin : gen_no_hwlp\n\n      // Flush the FIFO if it is not empty\n      assign fifo_flush_o             = branch_i;\n      assign fifo_flush_but_first_o   = 1'b0;\n      assign hwlp_flush_resp          = 1'b0;\n      assign hwlp_wait_resp_flush     = 1'b0;\n\n      assign hwlp_flush_after_resp    = 1'b0;\n      assign hwlp_flush_cnt_delayed_q = 2'b00;\n      assign hwlp_flush_resp_delayed  = 1'b0;\n\n\n    end\n  endgenerate\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Counter (flush_cnt_q, next_flush_cnt) to count reseponses to be flushed.\n  //////////////////////////////////////////////////////////////////////////////\n\n  always_comb begin\n    next_flush_cnt = flush_cnt_q;\n\n    // Number of outstanding transfers at time of branch equals the number of\n    // responses that will need to be flushed (responses already in the FIFO will\n    // be flushed there)\n    if (branch_i || hwlp_flush_resp) begin\n      next_flush_cnt = cnt_q;\n      if (resp_valid_i && (cnt_q > 0)) begin\n        next_flush_cnt = cnt_q - 1'b1;\n      end\n    end else if (hwlp_flush_resp_delayed) begin\n      // Delayed flush has a lower priority than the normal flush,\n      // because HW loops branches have lower priority than\n      // taken interrupts\n      next_flush_cnt = hwlp_flush_cnt_delayed_q;\n    end else if (resp_valid_i && (flush_cnt_q > 0)) begin\n      next_flush_cnt = flush_cnt_q - 1'b1;\n    end\n  end\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Registers\n  //////////////////////////////////////////////////////////////////////////////\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      state_q      <= IDLE;\n      cnt_q        <= '0;\n      flush_cnt_q  <= '0;\n      trans_addr_q <= '0;\n    end else begin\n      state_q     <= next_state;\n      cnt_q       <= next_cnt;\n      flush_cnt_q <= next_flush_cnt;\n      if (branch_i || hwlp_jump_i || (trans_valid_o && trans_ready_i)) begin\n        trans_addr_q <= trans_addr_o;\n      end\n    end\n  end\n\nendmodule  // cv32e40p_prefetch_controller\n","lang":"verilog"};
processSrcData(g_data);