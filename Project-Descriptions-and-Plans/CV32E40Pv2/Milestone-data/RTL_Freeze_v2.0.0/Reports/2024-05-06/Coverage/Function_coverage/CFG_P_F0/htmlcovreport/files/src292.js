var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/tb/uvmt/uvmt_cv32e40p_debug_assert.sv","src":"//\n// Copyright 2020 OpenHW Group\n// Copyright 2020 Datum Technology Corporation\n// \n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n//     https://solderpad.org/licenses/\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n\nmodule uvmt_cv32e40p_debug_assert  \n  import uvm_pkg::*;\n  import cv32e40p_pkg::*;\n  (\n      uvmt_cv32e40p_debug_cov_assert_if cov_assert_if\n  );\n\n  // ---------------------------------------------------------------------------\n  // Local parameters\n  // ---------------------------------------------------------------------------  \n    localparam WFI_INSTR_MASK = 32'hffffffff;\n    localparam WFI_INSTR_DATA = 32'h10500073;\n  // ---------------------------------------------------------------------------\n  // Local variables\n  // ---------------------------------------------------------------------------\n  string info_tag = \"CV32E40P_DEBUG_ASSERT\";\n  logic [31:0] pc_at_dbg_req; // Capture PC when debug_req_i or ebreak is active\n  logic [31:0] pc_at_ebreak; // Capture PC when ebreak\n  logic [31:0] halt_addr_at_entry;\n  logic halt_addr_at_entry_flag;\n  logic [31:0] exception_addr_at_entry;\n  logic exception_addr_at_entry_flag;\n  logic [31:0] tdata2_at_entry;\n  // Locally track which debug cause should be used\n  logic       is_decoding_v1;\n  logic [2:0] debug_cause_pri;\n  logic [31:0] boot_addr_at_entry;\n\n  // Locally track pc in ID stage to detect first instruction of debug code\n  logic [31:0] prev_id_pc;\n  logic first_debug_ins_flag;\n  logic first_debug_ins;\n  logic decode_valid;\n  // ---------------------------------------------------------------------------\n  // Clocking blocks\n  // ---------------------------------------------------------------------------\n\n  assign is_decoding_v1 = cov_assert_if.is_decoding ||\n                          (((cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE && !cov_assert_if.branch_taken_ex_i &&\n                             !cov_assert_if.data_err_i && !cov_assert_if.is_fetch_failed_i) ||\n                            cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE_HWLOOP\n                           ) && cov_assert_if.id_stage_instr_valid_i &&\n                           (cov_assert_if.debug_req_i || cov_assert_if.trigger_match_i) && !cov_assert_if.debug_mode_q\n                          );\n\n  // Single clock, single reset design, use default clocking\n  default clocking @(posedge cov_assert_if.clk_i); endclocking\n  default disable iff !(cov_assert_if.rst_ni);\n  \n  assign cov_assert_if.is_ebreak = is_decoding_v1 &\n                                   cov_assert_if.id_stage_instr_valid_i &\n                     (cov_assert_if.id_stage_instr_rdata_i == 32'h00100073) & \n                     cov_assert_if.id_stage_is_compressed == 1'b0;\n\n  assign cov_assert_if.is_cebreak = is_decoding_v1 &\n                                    cov_assert_if.id_stage_instr_valid_i &\n                     (cov_assert_if.id_stage_instr_rdata_i == 32'h00100073) & \n                     cov_assert_if.id_stage_is_compressed == 1'b1;\n\n  assign cov_assert_if.is_mulhsu = is_decoding_v1 &\n                                   cov_assert_if.id_stage_instr_valid_i & \n                                   cov_assert_if.id_stage_instr_rdata_i[31:25] == 7'h1 &\n                                   cov_assert_if.id_stage_instr_rdata_i[14:12] == 3'b010 &\n                                   cov_assert_if.id_stage_instr_rdata_i[6:0]   == 7'h33;\n\n\n  assign decode_valid =  cov_assert_if.id_stage_instr_valid_i & ((cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE) || (cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE_HWLOOP));\n    // ---------------------------------------\n    // Assertions\n    // ---------------------------------------\n\n    // check that we enter debug mode when expected. \n    // CSR checks are done in other assertions\n    property p_enter_debug;\n        $changed(debug_cause_pri) && (debug_cause_pri != 3'b000) && !cov_assert_if.debug_mode_q\n        |-> decode_valid [->1:2] ##0 cov_assert_if.debug_mode_q;\n    endproperty\n    a_enter_debug: assert property(p_enter_debug)\n        else\n            `uvm_error(info_tag, $sformatf(\"Debug mode not entered after exepected cause %d\", debug_cause_pri));\n\n    // Checck that depc gets the correct value when debug mode is entered.\n    property p_debug_mode_pc;\n        $rose(first_debug_ins) |-> cov_assert_if.debug_mode_q && (prev_id_pc == halt_addr_at_entry) && (cov_assert_if.depc_q == pc_at_dbg_req);\n    endproperty   \n\n    a_debug_mode_pc: assert property(p_debug_mode_pc)\n        else\n            `uvm_error(info_tag, $sformatf(\"Debug mode entered with wrong pc. pc==%08x\",prev_id_pc));\n\n    // Check that debug with cause haltreq is correct\n    property p_debug_mode_ext_req;\n        $rose(cov_assert_if.debug_mode_q) && (cov_assert_if.dcsr_q[8:6] == cv32e40p_pkg::DBG_CAUSE_HALTREQ) \n        |-> debug_cause_pri == cv32e40p_pkg::DBG_CAUSE_HALTREQ;\n    endproperty\n    \n    a_debug_mode_ext_req: assert property(p_debug_mode_ext_req)\n        else\n            `uvm_error(info_tag, $sformatf(\"Debug cause not correct for haltreq, cause = %d\",cov_assert_if.dcsr_q[8:6]));\n\n    // Check that debug with cause ebreak is correct\n    property p_cebreak_debug_mode;\n        $rose(cov_assert_if.debug_mode_q) && (cov_assert_if.dcsr_q[8:6] == cv32e40p_pkg::DBG_CAUSE_EBREAK)\n        |-> debug_cause_pri == cv32e40p_pkg::DBG_CAUSE_EBREAK;\n    endproperty\n\n    a_cebreak_debug_mode: assert property(p_cebreak_debug_mode)\n        else\n            `uvm_error(info_tag,$sformatf(\"Debug mode with wrong cause after ebreak, case = %d\",cov_assert_if.dcsr_q[8:6]));\n\n    ////////////////////////////////////////////////////////////////////////////\n    // It appears that the properties \"p_cebreak_exception\" and\n    // \"p_ebreak_exception\" are identical in all but name.  However, those two\n    // properties are not duplicate as they are using two different instruction\n    // decoding signals:\n    //    - property p_ebreak_exception uses i_ebreak.\n    //    - property p_cebreak_exception uses i_cebreak which differs thanks to\n    //      cov_assert_if.id_stage_is_compressed value.\n    //\n\n\n    // c.ebreak without dcsr.ebreakm results in exception at mtvec\n    // Exclude single stepping as the sequence gets very complicated\n    property p_cebreak_exception;\n        disable iff(cov_assert_if.debug_req_i | !cov_assert_if.rst_ni)\n        $rose(cov_assert_if.is_cebreak) && cov_assert_if.dcsr_q[15] == 1'b0 && !cov_assert_if.debug_mode_q  && is_decoding_v1 && cov_assert_if.id_valid &&\n        !cov_assert_if.debug_req_i && !cov_assert_if.dcsr_q[2]\n        |-> (decode_valid) [->1:2] ##0  !cov_assert_if.debug_mode_q && (cov_assert_if.mcause_q[5:0] === cv32e40p_pkg::EXC_CAUSE_BREAKPOINT) \n                                                                && (cov_assert_if.mepc_q == pc_at_ebreak) &&\n                                                                   (cov_assert_if.id_stage_pc == cov_assert_if.mtvec);\n    endproperty\n\n    a_cebreak_exception: assert property(p_cebreak_exception)\n        else\n            `uvm_error(info_tag,$sformatf(\"Exception not entered correctly after c.ebreak with dcsr.ebreak=0\"));\n\n    // ebreak without dcsr.ebreakm results in exception at mtvec\n    // Exclude single stepping as the sequence gets very complicated\n    property p_ebreak_exception;\n        disable iff(cov_assert_if.debug_req_i | !cov_assert_if.rst_ni)\n        $rose(cov_assert_if.is_ebreak) && cov_assert_if.dcsr_q[15] == 1'b0 && !cov_assert_if.debug_mode_q  && is_decoding_v1 && cov_assert_if.id_valid &&\n        !cov_assert_if.debug_req_i && !cov_assert_if.dcsr_q[2] \n        |-> (decode_valid) [->1:2] ##0  !cov_assert_if.debug_mode_q && (cov_assert_if.mcause_q[5:0] === cv32e40p_pkg::EXC_CAUSE_BREAKPOINT) \n                                                                && (cov_assert_if.mepc_q == pc_at_ebreak) &&\n                                                                   (cov_assert_if.id_stage_pc == cov_assert_if.mtvec);\n    endproperty\n\n    // TODO: Fails formal as above\n    a_ebreak_exception: assert property(p_ebreak_exception)\n        else\n            `uvm_error(info_tag,$sformatf(\"Exception not entered correctly after ebreak with dcsr.ebreak=0\"));\n    // c.ebreak during debug mode results in relaunch of debug mode\n\n    property p_cebreak_during_debug_mode;\n        $rose(cov_assert_if.is_cebreak) ##0 cov_assert_if.debug_mode_q  |-> decode_valid [->2] ##0 cov_assert_if.debug_mode_q  &&\n                                                       (cov_assert_if.id_stage_pc == halt_addr_at_entry); // TODO should check no change in dpc and dcsr\n    endproperty\n\n    a_cebreak_during_debug_mode: assert property(p_cebreak_during_debug_mode)\n        else\n            `uvm_error(info_tag,$sformatf(\"Debug mode not restarted after c.ebreak\"));\n\n    // ebreak during debug mode results in relaunch\n    property p_ebreak_during_debug_mode;\n        $rose(cov_assert_if.is_ebreak) ##0 cov_assert_if.debug_mode_q   |-> decode_valid [->2] ##0 cov_assert_if.debug_mode_q && \n                                                     (cov_assert_if.id_stage_pc == halt_addr_at_entry); // TODO should check no change in dpc and dcsr\n    endproperty\n\n    a_ebreak_during_debug_mode: assert property(p_ebreak_during_debug_mode)\n        else\n            `uvm_error(info_tag,$sformatf(\"Debug mode not restarted after ebreak\"));\n\n    // Trigger match results in debug mode\n    property p_trigger_match;\n        cov_assert_if.trigger_match_i ##0 cov_assert_if.tdata1[2] ##0 !cov_assert_if.debug_mode_q ##0 cov_assert_if.id_stage_instr_valid_i ##0 is_decoding_v1\n        |-> decode_valid [->2] ##0 (cov_assert_if.debug_mode_q && (cov_assert_if.dcsr_q[8:6]=== cv32e40p_pkg::DBG_CAUSE_TRIGGER) && \n                                                            (cov_assert_if.depc_q == tdata2_at_entry)) &&\n                                                            (cov_assert_if.id_stage_pc == halt_addr_at_entry);\n    endproperty   \n\n    a_trigger_match: assert property(p_trigger_match)\n        else\n            `uvm_error(info_tag, $sformatf(\"Debug mode not correctly entered after trigger match depc=%08x,  tdata2=%08x\", cov_assert_if.depc_q, tdata2_at_entry)); \n\n    // Address match without trigger enabled should NOT result in debug mode\n    property p_trigger_match_disabled;\n        $rose(cov_assert_if.addr_match) && !cov_assert_if.debug_mode_q |-> ##[1:6] !cov_assert_if.debug_mode_q;\n    endproperty\n\n    a_trigger_match_disabled: assert property(p_trigger_match_disabled)\n        else\n            `uvm_error(info_tag, \"Trigger match with tdata[2]==0 resulted in debug mode\");\n\n    // Exception in debug mode results in pc->dm_exception_addr_i\n    property p_debug_mode_exception;\n        $rose(cov_assert_if.illegal_insn_i) && cov_assert_if.debug_mode_q && is_decoding_v1 |-> (decode_valid & cov_assert_if.id_valid) [->2] ##0 cov_assert_if.debug_mode_q && (cov_assert_if.id_stage_pc == exception_addr_at_entry);\n    endproperty\n\n    a_debug_mode_exception : assert property(p_debug_mode_exception)\n        else\n            `uvm_error(info_tag, $sformatf(\"Exception in debug mode not handled incorrectly. dm=%d, pc=%08x\", cov_assert_if.debug_mode_q, cov_assert_if.id_stage_pc));\n\n    // ECALL in debug mode results in pc->dm_exception_addr_i\n    property p_debug_mode_ecall;\n        $rose(cov_assert_if.ecall_insn_i) && cov_assert_if.debug_mode_q  && is_decoding_v1 && cov_assert_if.id_stage_instr_valid_i\n        |-> (decode_valid & cov_assert_if.id_valid) [->1:3] ##0 cov_assert_if.debug_mode_q && (cov_assert_if.id_stage_pc == exception_addr_at_entry);\n    endproperty\n\n    a_debug_mode_ecall : assert property(p_debug_mode_ecall)\n        else\n            `uvm_error(info_tag, $sformatf(\"ECALL in debug mode not handled incorrectly. dm=%d, pc=%08x\", cov_assert_if.debug_mode_q, cov_assert_if.id_stage_pc));\n\n    // IRQ in debug mode are masked\n    property p_irq_in_debug;\n        cov_assert_if.debug_mode_q |-> !cov_assert_if.irq_ack_o;\n    endproperty\n\n    a_irq_in_debug : assert property(p_irq_in_debug)\n        else\n            `uvm_error(info_tag, $sformatf(\"IRQ not ignored while in debug mode\"));\n\n    // WFI in debug mode does not sleep\n    property p_wfi_in_debug;\n        cov_assert_if.debug_mode_q && $rose(cov_assert_if.is_wfi) |-> ##6 !cov_assert_if.core_sleep_o;\n    endproperty\n\n    a_wfi_in_debug : assert property(p_wfi_in_debug)\n        else\n            `uvm_error(info_tag, $sformatf(\"WFI in debug mode cause core_sleep_o=1\"));\n\n    // Debug request while sleeping makes core wake up and enter debug mode\n    // wit cause=haltreq\n    property p_sleep_debug_req;\n        cov_assert_if.in_wfi && cov_assert_if.debug_req_i |=> !cov_assert_if.core_sleep_o |-> decode_valid [->1:2] ##0 cov_assert_if.debug_mode_q &&\n        cov_assert_if.dcsr_q[8:6] == cv32e40p_pkg::DBG_CAUSE_HALTREQ;\n    endproperty\n\n    a_sleep_debug_req : assert property(p_sleep_debug_req)\n        else\n            `uvm_error(info_tag, $sformatf(\"Did not exit sleep(== %d) after debug_req_i. Debug_mode = %d cause = %d\", cov_assert_if.core_sleep_o, cov_assert_if.debug_mode_q, cov_assert_if.dcsr_q[8:6]));\n\n    // Accessing debug regs in m-mode is illegal\n    property p_debug_regs_mmode;\n        cov_assert_if.csr_access && !cov_assert_if.debug_mode_q && cov_assert_if.id_stage_instr_rdata_i[31:20] inside {'h7B0, 'h7B1, 'h7B2, 'h7B3} |->\n                 cov_assert_if.illegal_insn_i; \n    endproperty\n\n    a_debug_regs_mmode : assert property(p_debug_regs_mmode)\n        else\n            `uvm_error(info_tag, \"Accessing debug regs in M-mode did not result in illegal instruction\");\n\n    // Exception while single step -> PC is set to exception handler before\n    // debug\n    property p_single_step_exception;\n        !cov_assert_if.debug_mode_q && cov_assert_if.dcsr_q[2] && cov_assert_if.illegal_insn_q |-> ##[1:20] cov_assert_if.debug_mode_q && (cov_assert_if.depc_q == cov_assert_if.mtvec);\n    endproperty\n\n    a_single_step_exception : assert property(p_single_step_exception)\n        else\n            `uvm_error(info_tag, \"PC not set to exception handler after single step with exception\");\n\n    // Trigger during single step \n    property p_single_step_trigger;\n        !cov_assert_if.debug_mode_q && cov_assert_if.dcsr_q[2] && cov_assert_if.addr_match && cov_assert_if.tdata1[2] && cov_assert_if.id_stage_instr_valid_i|->\n                ##[1:20] cov_assert_if.debug_mode_q && (cov_assert_if.dcsr_q[8:6] == cv32e40p_pkg::DBG_CAUSE_TRIGGER) && (cov_assert_if.depc_q == pc_at_dbg_req);\n    endproperty\n\n    a_single_step_trigger : assert property (p_single_step_trigger)\n        else\n            `uvm_error(info_tag, $sformatf(\"Single step and trigger error: depc = %08x, cause = %d\",cov_assert_if.depc_q, cov_assert_if.dcsr_q[8:6]));\n\n    // Single step WFI must not result in sleeping\n    property p_single_step_wfi;\n        !cov_assert_if.debug_mode_q && cov_assert_if.dcsr_q[2] && cov_assert_if.is_wfi |->\n                decode_valid [->2] ##0 cov_assert_if.debug_mode_q && !cov_assert_if.core_sleep_o;\n    endproperty\n\n    a_single_step_wfi : assert property(p_single_step_wfi)\n        else\n            `uvm_error(info_tag, \"Debug mode not entered after single step WFI or core went sleeping\");\n\n    // Executing with single step with no irq results in debug mode\n    property p_single_step;\n        !cov_assert_if.debug_mode_q && cov_assert_if.dcsr_q[2] && !cov_assert_if.dcsr_q[11] && decode_valid |=>  decode_valid [->1] ##0 cov_assert_if.debug_mode_q;\n    endproperty\n\n    a_single_step: assert property(p_single_step)\n        else\n            `uvm_error(info_tag, \"Debug mode not entered for single step\");\n\n    // dret in M-mode will cause illegal instruction\n    // If pending debug req, illegal insn will not assert\n    // until resume\n    property p_mmode_dret;\n        !cov_assert_if.debug_mode_q && cov_assert_if.is_dret && !cov_assert_if.debug_req_i   |-> ##1 cov_assert_if.illegal_insn_q;\n    endproperty\n\n    a_mmode_dret : assert property(p_mmode_dret)\n        else\n            `uvm_error(info_tag, \"Executing dret in M-mode did not result in illegal instruction\");\n\n    // dret in D-mode will restore pc and exit D-mode\n    property p_dmode_dret;\n        cov_assert_if.debug_mode_q && cov_assert_if.is_dret |-> decode_valid [->2] ##0  !cov_assert_if.debug_mode_q && (cov_assert_if.id_stage_pc == cov_assert_if.depc_q);\n    endproperty\n\n    a_dmode_dret : assert property(p_dmode_dret)\n        else\n            `uvm_error(info_tag, \"Dret did not cause correct return from debug mode\");\n\n    // Check that trigger regs cannot be written from M-mode\n    // TSEL, and TDATA3 are tied to zero, hence no register to check \n    property p_mmode_tdata1_write;\n        !cov_assert_if.debug_mode_q && cov_assert_if.csr_access && cov_assert_if.csr_op == 'h1 && cov_assert_if.id_stage_instr_rdata_i[31:20] == 'h7A1 |-> ##2 $stable(cov_assert_if.tdata1);\n    endproperty\n\n    a_mmode_tdata1_write : assert property(p_mmode_tdata1_write)\n        else\n            `uvm_error(info_tag, \"Writing tdata1 from M-mode not allowed to change register value!\");\n\n  property p_mmode_tdata2_write;\n        !cov_assert_if.debug_mode_q && cov_assert_if.csr_access && cov_assert_if.csr_op == 'h1 && cov_assert_if.id_stage_instr_rdata_i[31:20] == 'h7A2 |-> ##2 $stable(cov_assert_if.tdata2);\n    endproperty\n\n    a_mmode_tdata2_write : assert property(p_mmode_tdata2_write)\n        else\n            `uvm_error(info_tag, \"Writing tdata2 from M-mode not allowed to change register value!\");\n\n    // Check that mcycle works as expected when not sleeping\n    // Counter can be written an arbitrary value, check that\n    // it changed only when not being written to\n    property p_mcycle_count;\n        !cov_assert_if.mcountinhibit_q[0] && !cov_assert_if.core_sleep_o  && !(cov_assert_if.csr_we_int && (cov_assert_if.csr_addr ==12'hB00 || cov_assert_if.csr_addr == 12'hB80)) |=>  $changed(cov_assert_if.mcycle);\n    endproperty\n\n    a_mcycle_count : assert property(p_mcycle_count)\n        else\n            `uvm_error(info_tag, \"Mcycle not counting when mcountinhibit[0] is cleared!\");\n\n    // Check that minstret works as expected when not sleeping\n    // Check only when not written to\n    property p_minstret_count;\n        !cov_assert_if.mcountinhibit_q[2] && cov_assert_if.inst_ret && !cov_assert_if.core_sleep_o\n        && !(cov_assert_if.csr_we_int && (cov_assert_if.csr_addr == 12'hB02 || cov_assert_if.csr_addr == 12'hB82))\n        |=> (cov_assert_if.minstret == ($past(cov_assert_if.minstret)+1));\n    endproperty\n\n    a_minstret_count : assert property(p_minstret_count)\n        else\n            `uvm_error(info_tag, \"Minstret not counting when mcountinhibit[2] is cleared!\");\n\n    // Check debug_req_i and irq on same cycle. \n    // Should result in debug mode with regular pc in depc,\n    // not pc from interrupt handler\n    // PC is checked in another assertion\n    property p_debug_req_and_irq;\n        cov_assert_if.debug_req_i && cov_assert_if.pending_enabled_irq  && ((cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE) || (cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE_HWLOOP))\n        |-> (decode_valid & cov_assert_if.id_valid) [->1:2] ##0 cov_assert_if.debug_mode_q;\n    endproperty\n\n    a_debug_req_and_irq : assert property(p_debug_req_and_irq)\n        else\n            `uvm_error(info_tag, \"Debug mode not entered after debug_req_i and irq on same cycle\");\n\n    // debug_req at reset should result in debug mode and no instructions\n    // executed\n    property p_debug_at_reset;\n        cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::RESET && cov_assert_if.debug_req_i |->\n        decode_valid [->1:2] ##0 cov_assert_if.debug_mode_q && (cov_assert_if.depc_q == boot_addr_at_entry);\n \n    endproperty    \n\n    a_debug_at_reset : assert property(p_debug_at_reset)\n        else\n            `uvm_error(info_tag, \"Debug mode not entered correctly at reset!\");\n\n    // Check that we cover the case where a debug_req_i\n    // comes while flushing due to an illegal insn, causing\n    // dpc to be set to the exception handler entry addr\n    property p_illegal_insn_debug_req;\n        (cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::FLUSH_EX | cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::FLUSH_WB) && cov_assert_if.illegal_insn_q & cov_assert_if.debug_req_i & !cov_assert_if.debug_mode_q|-> decode_valid [->1:2] ##0 cov_assert_if.debug_mode_q &&  cov_assert_if.depc_q == cov_assert_if.mtvec;\n    endproperty\n    \n    a_illegal_insn_debug_req : assert property(p_illegal_insn_debug_req)\n        else\n            `uvm_error(info_tag, \"Debug mode not entered correctly while handling illegal instruction!\");\n// -------------------------------------------\n    // Capture internal states for use in checking\n    // -------------------------------------------\n    always @(posedge cov_assert_if.clk_i or negedge cov_assert_if.rst_ni) begin\n        if(!cov_assert_if.rst_ni) begin\n            pc_at_dbg_req <= 32'h0;\n            pc_at_ebreak <= 32'h0;\n        end else begin\n            // Capture debug pc\n            if(cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DBG_TAKEN_ID) begin\n                pc_at_dbg_req <= cov_assert_if.id_stage_pc;\n            end else if(cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DBG_TAKEN_IF) begin\n                pc_at_dbg_req <= cov_assert_if.if_stage_pc;\n            end\n\n            // Capture pc at ebreak\n            if(cov_assert_if.is_ebreak || cov_assert_if.is_cebreak ) begin\n                pc_at_ebreak <= cov_assert_if.id_stage_pc;\n            end\n       end\n    end        \n\n    // Keep track of wfi state\n    always @(posedge cov_assert_if.clk_i or negedge cov_assert_if.rst_ni) begin\n    if (!cov_assert_if.rst_ni) begin\n      cov_assert_if.in_wfi <= 1'b0;\n    end\n    else begin\n      // Enter wfi if we have a valid instruction, not in debug mode and not\n      // single stepping\n      if (cov_assert_if.is_wfi && !cov_assert_if.debug_mode_q && is_decoding_v1 && cov_assert_if.id_stage_instr_valid_i & !cov_assert_if.dcsr_q[2]) begin\n        cov_assert_if.in_wfi <= 1'b1;\n\n      end else if (cov_assert_if.pending_enabled_irq || cov_assert_if.debug_req_i)\n        cov_assert_if.in_wfi <= 1'b0;\n       \n    end\n  end\n\n  // Capture dm_halt_addr_i value\n  always@ (posedge cov_assert_if.clk_i or negedge cov_assert_if.rst_ni) begin\n      if(!cov_assert_if.rst_ni) begin\n          halt_addr_at_entry_flag <= 1'b0;\n      end else begin\n          if(!halt_addr_at_entry_flag) begin\n              if(cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DBG_TAKEN_ID | cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DBG_TAKEN_IF) begin\n                  halt_addr_at_entry <= {cov_assert_if.dm_halt_addr_i[31:2], 2'b00};\n                  tdata2_at_entry <= cov_assert_if.tdata2;\n                  halt_addr_at_entry_flag <= 1'b1;\n              end\n          end\n\n          // Clear flag while not in dmode or we see ebreak in debug\n          if((!cov_assert_if.debug_mode_q & halt_addr_at_entry_flag) | (cov_assert_if.debug_mode_q & (cov_assert_if.is_ebreak | cov_assert_if.is_cebreak)))\n              halt_addr_at_entry_flag <= 1'b0;\n\n          // Capture boot addr\n          if(cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::BOOT_SET)\n              boot_addr_at_entry <= {cov_assert_if.boot_addr_i[31:2], 2'b00};\n      end\n  end\n  always@ (posedge cov_assert_if.clk_i)  begin\n      if((cov_assert_if.illegal_insn_i | cov_assert_if.ecall_insn_i) & cov_assert_if.pc_set & cov_assert_if.debug_mode_q)\n          exception_addr_at_entry = {cov_assert_if.dm_exception_addr_i[31:2], 2'b00};\n  end\n\n    assign cov_assert_if.addr_match   = (cov_assert_if.id_stage_pc == cov_assert_if.tdata2);\n    assign cov_assert_if.dpc_will_hit = (cov_assert_if.depc_n == cov_assert_if.tdata2);\n    assign cov_assert_if.is_wfi = cov_assert_if.id_stage_instr_valid_i & cov_assert_if.id_valid &\n                                  ((cov_assert_if.id_stage_instr_rdata_i & WFI_INSTR_MASK) == WFI_INSTR_DATA);\n    assign cov_assert_if.pending_enabled_irq = |(cov_assert_if.irq_i & cov_assert_if.mie_q);\n    assign cov_assert_if.is_dret             = cov_assert_if.id_valid & cov_assert_if.id_stage_instr_valid_i & is_decoding_v1 & (cov_assert_if.id_stage_instr_rdata_i == 32'h7B200073);\n\n    // Track which debug cause should be expected\n    always@ (posedge cov_assert_if.clk_i or negedge cov_assert_if.rst_ni) begin\n        if( !cov_assert_if.rst_ni) begin\n            debug_cause_pri <= 3'b000;\n        end else begin\n            // Debug evaluated in decode state with valid instructions only\n            //if(cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE & !cov_assert_if.debug_mode_q) begin\n            if((cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE || cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DECODE_HWLOOP)) begin\n                if(is_decoding_v1 & cov_assert_if.id_stage_instr_valid_i) begin\n                    if(cov_assert_if.trigger_match_i)\n                        debug_cause_pri <= 3'b010;\n                    else if((cov_assert_if.dcsr_q[15]) & (cov_assert_if.is_ebreak | cov_assert_if.is_cebreak))\n                        debug_cause_pri <= 3'b001;\n                    else if(cov_assert_if.debug_req_i) \n                        debug_cause_pri <= 3'b011;\n                    else if(cov_assert_if.dcsr_q[2])\n                        debug_cause_pri <= 3'b100;\n                    else\n                        debug_cause_pri <= 3'b000;\n\n                end\n\n            end else if(cov_assert_if.ctrl_fsm_cs == cv32e40p_pkg::DBG_TAKEN_IF) begin\n                if(cov_assert_if.debug_req_i) begin\n                    debug_cause_pri <= 3'b011;\n                end else if(cov_assert_if.dcsr_q[2]) begin\n                    debug_cause_pri <= 3'b100;\n                end\n            end\n        end\n    end\n\n    // Track PC in id stage to detect first instruction of debug code\n    always@ (posedge cov_assert_if.clk_i or negedge cov_assert_if.rst_ni) begin\n        if( !cov_assert_if.rst_ni) begin\n            prev_id_pc <= 32'h0;\n            first_debug_ins_flag <= 1'b0;\n            first_debug_ins <= 1'b0;\n        end else begin\n            prev_id_pc <= cov_assert_if.id_stage_pc;\n            first_debug_ins <= 1'b0;\n            if(cov_assert_if.debug_mode_q) begin\n                if(!first_debug_ins_flag) begin\n                    if(is_decoding_v1 & cov_assert_if.id_stage_instr_valid_i) begin\n                        first_debug_ins_flag <= 1'b1;\n                        first_debug_ins <= 1'b1;\n                    end\n                end\n            end else begin\n                first_debug_ins_flag <= 1'b0;\n            end\n        end\n    end\nendmodule : uvmt_cv32e40p_debug_assert\n","lang":"verilog"};
processSrcData(g_data);