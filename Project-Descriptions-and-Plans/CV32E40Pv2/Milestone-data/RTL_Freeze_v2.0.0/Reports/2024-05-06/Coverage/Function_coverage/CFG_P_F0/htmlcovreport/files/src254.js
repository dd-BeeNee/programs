var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_alu.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Matthias Baer - baermatt@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    ALU                                                        //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Arithmetic logic unit of the pipelined processor           //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_alu\n  import cv32e40p_pkg::*;\n(\n    input logic               clk,\n    input logic               rst_n,\n    input logic               enable_i,\n    input alu_opcode_e        operator_i,\n    input logic        [31:0] operand_a_i,\n    input logic        [31:0] operand_b_i,\n    input logic        [31:0] operand_c_i,\n\n    input logic [1:0] vector_mode_i,\n    input logic [4:0] bmask_a_i,\n    input logic [4:0] bmask_b_i,\n    input logic [1:0] imm_vec_ext_i,\n\n    input logic       is_clpx_i,\n    input logic       is_subrot_i,\n    input logic [1:0] clpx_shift_i,\n\n    output logic [31:0] result_o,\n    output logic        comparison_result_o,\n\n    output logic ready_o,\n    input  logic ex_ready_i\n);\n\n  logic [31:0] operand_a_rev;\n  logic [31:0] operand_a_neg;\n  logic [31:0] operand_a_neg_rev;\n\n  assign operand_a_neg = ~operand_a_i;\n\n  // bit reverse operand_a for left shifts and bit counting\n  generate\n    genvar k;\n    for (k = 0; k < 32; k++) begin : gen_operand_a_rev\n      assign operand_a_rev[k] = operand_a_i[31-k];\n    end\n  endgenerate\n\n  // bit reverse operand_a_neg for left shifts and bit counting\n  generate\n    genvar m;\n    for (m = 0; m < 32; m++) begin : gen_operand_a_neg_rev\n      assign operand_a_neg_rev[m] = operand_a_neg[31-m];\n    end\n  endgenerate\n\n  logic [31:0] operand_b_neg;\n\n  assign operand_b_neg = ~operand_b_i;\n\n\n  logic [ 5:0] div_shift;\n  logic        div_valid;\n  logic [31:0] bmask;\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  //   ____            _   _ _   _                      _      _       _     _            //\n  //  |  _ \\ __ _ _ __| |_(_) |_(_) ___  _ __   ___  __| |    / \\   __| | __| | ___ _ __  //\n  //  | |_) / _` | '__| __| | __| |/ _ \\| '_ \\ / _ \\/ _` |   / _ \\ / _` |/ _` |/ _ \\ '__| //\n  //  |  __/ (_| | |  | |_| | |_| | (_) | | | |  __/ (_| |  / ___ \\ (_| | (_| |  __/ |    //\n  //  |_|   \\__,_|_|   \\__|_|\\__|_|\\___/|_| |_|\\___|\\__,_| /_/   \\_\\__,_|\\__,_|\\___|_|    //\n  //                                                                                      //\n  //////////////////////////////////////////////////////////////////////////////////////////\n\n  logic        adder_op_b_negate;\n  logic [31:0] adder_op_a, adder_op_b;\n  logic [35:0] adder_in_a, adder_in_b;\n  logic [31:0] adder_result;\n  logic [36:0] adder_result_expanded;\n\n\n  assign adder_op_b_negate = (operator_i == ALU_SUB) || (operator_i == ALU_SUBR) ||\n                             (operator_i == ALU_SUBU) || (operator_i == ALU_SUBUR) || is_subrot_i;\n\n  // prepare operand a\n  assign adder_op_a = (operator_i == ALU_ABS) ? operand_a_neg : (is_subrot_i ? {\n    operand_b_i[15:0], operand_a_i[31:16]\n  } : operand_a_i);\n\n  // prepare operand b\n  assign adder_op_b = adder_op_b_negate ? (is_subrot_i ? ~{\n    operand_a_i[15:0], operand_b_i[31:16]\n  } : operand_b_neg) : operand_b_i;\n\n  // prepare carry\n  always_comb begin\n    adder_in_a[0]     = 1'b1;\n    adder_in_a[8:1]   = adder_op_a[7:0];\n    adder_in_a[9]     = 1'b1;\n    adder_in_a[17:10] = adder_op_a[15:8];\n    adder_in_a[18]    = 1'b1;\n    adder_in_a[26:19] = adder_op_a[23:16];\n    adder_in_a[27]    = 1'b1;\n    adder_in_a[35:28] = adder_op_a[31:24];\n\n    adder_in_b[0]     = 1'b0;\n    adder_in_b[8:1]   = adder_op_b[7:0];\n    adder_in_b[9]     = 1'b0;\n    adder_in_b[17:10] = adder_op_b[15:8];\n    adder_in_b[18]    = 1'b0;\n    adder_in_b[26:19] = adder_op_b[23:16];\n    adder_in_b[27]    = 1'b0;\n    adder_in_b[35:28] = adder_op_b[31:24];\n\n    if (adder_op_b_negate || (operator_i == ALU_ABS || operator_i == ALU_CLIP)) begin\n      // special case for subtractions and absolute number calculations\n      adder_in_b[0] = 1'b1;\n\n      case (vector_mode_i)\n        VEC_MODE16: begin\n          adder_in_b[18] = 1'b1;\n        end\n\n        VEC_MODE8: begin\n          adder_in_b[9]  = 1'b1;\n          adder_in_b[18] = 1'b1;\n          adder_in_b[27] = 1'b1;\n        end\n      endcase\n\n    end else begin\n      // take care of partitioning the adder for the addition case\n      case (vector_mode_i)\n        VEC_MODE16: begin\n          adder_in_a[18] = 1'b0;\n        end\n\n        VEC_MODE8: begin\n          adder_in_a[9]  = 1'b0;\n          adder_in_a[18] = 1'b0;\n          adder_in_a[27] = 1'b0;\n        end\n      endcase\n    end\n  end\n\n  // actual adder\n  assign adder_result_expanded = $signed(adder_in_a) + $signed(adder_in_b);\n  assign adder_result = {\n    adder_result_expanded[35:28],\n    adder_result_expanded[26:19],\n    adder_result_expanded[17:10],\n    adder_result_expanded[8:1]\n  };\n\n\n  // normalization stage\n  logic [31:0] adder_round_value;\n  logic [31:0] adder_round_result;\n\n  assign adder_round_value  = ((operator_i == ALU_ADDR) || (operator_i == ALU_SUBR) ||\n                               (operator_i == ALU_ADDUR) || (operator_i == ALU_SUBUR)) ?\n                                {\n    1'b0, bmask[31:1]\n  } : '0;\n  assign adder_round_result = adder_result + adder_round_value;\n\n\n  ////////////////////////////////////////\n  //  ____  _   _ ___ _____ _____       //\n  // / ___|| | | |_ _|  ___|_   _|      //\n  // \\___ \\| |_| || || |_    | |        //\n  //  ___) |  _  || ||  _|   | |        //\n  // |____/|_| |_|___|_|     |_|        //\n  //                                    //\n  ////////////////////////////////////////\n\n  logic        shift_left;  // should we shift left\n  logic        shift_use_round;\n  logic        shift_arithmetic;\n\n  logic [31:0] shift_amt_left;  // amount of shift, if to the left\n  logic [31:0] shift_amt;  // amount of shift, to the right\n  logic [31:0] shift_amt_int;  // amount of shift, used for the actual shifters\n  logic [31:0] shift_amt_norm;  // amount of shift, used for normalization\n  logic [31:0] shift_op_a;  // input of the shifter\n  logic [31:0] shift_result;\n  logic [31:0] shift_right_result;\n  logic [31:0] shift_left_result;\n  logic [15:0] clpx_shift_ex;\n\n  // shifter is also used for preparing operand for division\n  assign shift_amt = div_valid ? div_shift : operand_b_i;\n\n  // by reversing the bits of the input, we also have to reverse the order of shift amounts\n  always_comb begin\n    case (vector_mode_i)\n      VEC_MODE16: begin\n        shift_amt_left[15:0]  = shift_amt[31:16];\n        shift_amt_left[31:16] = shift_amt[15:0];\n      end\n\n      VEC_MODE8: begin\n        shift_amt_left[7:0]   = shift_amt[31:24];\n        shift_amt_left[15:8]  = shift_amt[23:16];\n        shift_amt_left[23:16] = shift_amt[15:8];\n        shift_amt_left[31:24] = shift_amt[7:0];\n      end\n\n      default: // VEC_MODE32\n      begin\n        shift_amt_left[31:0] = shift_amt[31:0];\n      end\n    endcase\n  end\n\n  // ALU_FL1 and ALU_CBL are used for the bit counting ops later\n  assign shift_left = (operator_i == ALU_SLL) || (operator_i == ALU_BINS) ||\n                      (operator_i == ALU_FL1) || (operator_i == ALU_CLB)  ||\n                      (operator_i == ALU_DIV) || (operator_i == ALU_DIVU) ||\n                      (operator_i == ALU_REM) || (operator_i == ALU_REMU) ||\n                      (operator_i == ALU_BREV);\n\n  assign shift_use_round = (operator_i == ALU_ADD)   || (operator_i == ALU_SUB)   ||\n                           (operator_i == ALU_ADDR)  || (operator_i == ALU_SUBR)  ||\n                           (operator_i == ALU_ADDU)  || (operator_i == ALU_SUBU)  ||\n                           (operator_i == ALU_ADDUR) || (operator_i == ALU_SUBUR);\n\n  assign shift_arithmetic = (operator_i == ALU_SRA)  || (operator_i == ALU_BEXT) ||\n                            (operator_i == ALU_ADD)  || (operator_i == ALU_SUB)  ||\n                            (operator_i == ALU_ADDR) || (operator_i == ALU_SUBR);\n\n  // choose the bit reversed or the normal input for shift operand a\n  assign shift_op_a    = shift_left ? operand_a_rev :\n                          (shift_use_round ? adder_round_result : operand_a_i);\n  assign shift_amt_int = shift_use_round ? shift_amt_norm :\n                          (shift_left ? shift_amt_left : shift_amt);\n\n  assign shift_amt_norm = is_clpx_i ? {clpx_shift_ex, clpx_shift_ex} : {4{3'b000, bmask_b_i}};\n\n  assign clpx_shift_ex = $unsigned(clpx_shift_i);\n\n  // right shifts, we let the synthesizer optimize this\n  logic [63:0] shift_op_a_32;\n\n  assign shift_op_a_32 = (operator_i == ALU_ROR) ? {\n        shift_op_a, shift_op_a\n      } : $signed(\n          {{32{shift_arithmetic & shift_op_a[31]}}, shift_op_a}\n      );\n\n  always_comb begin\n    case (vector_mode_i)\n      VEC_MODE16: begin\n        shift_right_result[31:16] = $signed(\n            {shift_arithmetic & shift_op_a[31], shift_op_a[31:16]}\n        ) >>> shift_amt_int[19:16];\n        shift_right_result[15:0] = $signed(\n            {shift_arithmetic & shift_op_a[15], shift_op_a[15:0]}\n        ) >>> shift_amt_int[3:0];\n      end\n\n      VEC_MODE8: begin\n        shift_right_result[31:24] = $signed(\n            {shift_arithmetic & shift_op_a[31], shift_op_a[31:24]}\n        ) >>> shift_amt_int[26:24];\n        shift_right_result[23:16] = $signed(\n            {shift_arithmetic & shift_op_a[23], shift_op_a[23:16]}\n        ) >>> shift_amt_int[18:16];\n        shift_right_result[15:8] = $signed(\n            {shift_arithmetic & shift_op_a[15], shift_op_a[15:8]}\n        ) >>> shift_amt_int[10:8];\n        shift_right_result[7:0] = $signed(\n            {shift_arithmetic & shift_op_a[7], shift_op_a[7:0]}\n        ) >>> shift_amt_int[2:0];\n      end\n\n      default: // VEC_MODE32\n      begin\n        shift_right_result = shift_op_a_32 >> shift_amt_int[4:0];\n      end\n    endcase\n    ;  // case (vec_mode_i)\n  end\n\n  // bit reverse the shift_right_result for left shifts\n  genvar j;\n  generate\n    for (j = 0; j < 32; j++) begin : gen_shift_left_result\n      assign shift_left_result[j] = shift_right_result[31-j];\n    end\n  endgenerate\n\n  assign shift_result = shift_left ? shift_left_result : shift_right_result;\n\n\n  //////////////////////////////////////////////////////////////////\n  //   ____ ___  __  __ ____   _    ____  ___ ____   ___  _   _   //\n  //  / ___/ _ \\|  \\/  |  _ \\ / \\  |  _ \\|_ _/ ___| / _ \\| \\ | |  //\n  // | |  | | | | |\\/| | |_) / _ \\ | |_) || |\\___ \\| | | |  \\| |  //\n  // | |__| |_| | |  | |  __/ ___ \\|  _ < | | ___) | |_| | |\\  |  //\n  //  \\____\\___/|_|  |_|_| /_/   \\_\\_| \\_\\___|____/ \\___/|_| \\_|  //\n  //                                                              //\n  //////////////////////////////////////////////////////////////////\n\n  logic [ 3:0] is_equal;\n  logic [ 3:0] is_greater;  // handles both signed and unsigned forms\n\n  // 8-bit vector comparisons, basic building blocks\n  logic [ 3:0] cmp_signed;\n  logic [ 3:0] is_equal_vec;\n  logic [ 3:0] is_greater_vec;\n  logic [31:0] operand_b_eq;\n  logic        is_equal_clip;\n\n\n  //second == comparator for CLIP instructions\n  always_comb begin\n    operand_b_eq = operand_b_neg;\n    if (operator_i == ALU_CLIPU) operand_b_eq = '0;\n    else operand_b_eq = operand_b_neg;\n  end\n  assign is_equal_clip = operand_a_i == operand_b_eq;\n\n  always_comb begin\n    cmp_signed = 4'b0;\n\n    unique case (operator_i)\n      ALU_GTS,\n      ALU_GES,\n      ALU_LTS,\n      ALU_LES,\n      ALU_SLTS,\n      ALU_SLETS,\n      ALU_MIN,\n      ALU_MAX,\n      ALU_ABS,\n      ALU_CLIP,\n      ALU_CLIPU: begin\n        case (vector_mode_i)\n          VEC_MODE8:  cmp_signed[3:0] = 4'b1111;\n          VEC_MODE16: cmp_signed[3:0] = 4'b1010;\n          default:    cmp_signed[3:0] = 4'b1000;\n        endcase\n      end\n\n      default: ;\n    endcase\n  end\n\n  // generate vector equal and greater than signals, cmp_signed decides if the\n  // comparison is done signed or unsigned\n  genvar i;\n  generate\n    for (i = 0; i < 4; i++) begin : gen_is_vec\n      assign is_equal_vec[i] = (operand_a_i[8*i+7:8*i] == operand_b_i[8*i+7:i*8]);\n      assign is_greater_vec[i] = $signed(\n          {operand_a_i[8*i+7] & cmp_signed[i], operand_a_i[8*i+7:8*i]}\n      ) > $signed(\n          {operand_b_i[8*i+7] & cmp_signed[i], operand_b_i[8*i+7:i*8]}\n      );\n    end\n  endgenerate\n\n  // generate the real equal and greater than signals that take the vector\n  // mode into account\n  always_comb begin\n    // 32-bit mode\n    is_equal[3:0] = {4{is_equal_vec[3] & is_equal_vec[2] & is_equal_vec[1] & is_equal_vec[0]}};\n    is_greater[3:0] = {4{is_greater_vec[3] | (is_equal_vec[3] & (is_greater_vec[2]\n                                            | (is_equal_vec[2] & (is_greater_vec[1]\n                                             | (is_equal_vec[1] & (is_greater_vec[0]))))))}};\n\n    case (vector_mode_i)\n      VEC_MODE16: begin\n        is_equal[1:0]   = {2{is_equal_vec[0] & is_equal_vec[1]}};\n        is_equal[3:2]   = {2{is_equal_vec[2] & is_equal_vec[3]}};\n        is_greater[1:0] = {2{is_greater_vec[1] | (is_equal_vec[1] & is_greater_vec[0])}};\n        is_greater[3:2] = {2{is_greater_vec[3] | (is_equal_vec[3] & is_greater_vec[2])}};\n      end\n\n      VEC_MODE8: begin\n        is_equal[3:0]   = is_equal_vec[3:0];\n        is_greater[3:0] = is_greater_vec[3:0];\n      end\n\n      default: ;  // see default assignment\n    endcase\n  end\n\n  // generate comparison result\n  logic [3:0] cmp_result;\n\n  always_comb begin\n    cmp_result = is_equal;\n    unique case (operator_i)\n      ALU_EQ:                                 cmp_result = is_equal;\n      ALU_NE:                                 cmp_result = ~is_equal;\n      ALU_GTS, ALU_GTU:                       cmp_result = is_greater;\n      ALU_GES, ALU_GEU:                       cmp_result = is_greater | is_equal;\n      ALU_LTS, ALU_SLTS, ALU_LTU, ALU_SLTU:   cmp_result = ~(is_greater | is_equal);\n      ALU_SLETS, ALU_SLETU, ALU_LES, ALU_LEU: cmp_result = ~is_greater;\n      default:                                ;\n    endcase\n  end\n\n  assign comparison_result_o = cmp_result[3];\n\n\n  // min/max/abs handling\n  logic [31:0] result_minmax;\n  logic [ 3:0] sel_minmax;\n  logic        do_min;\n  logic [31:0] minmax_b;\n\n  assign minmax_b = (operator_i == ALU_ABS) ? adder_result : operand_b_i;\n\n  assign do_min   = (operator_i == ALU_MIN)  || (operator_i == ALU_MINU) ||\n                    (operator_i == ALU_CLIP) || (operator_i == ALU_CLIPU);\n\n  assign sel_minmax[3:0] = is_greater ^ {4{do_min}};\n\n  assign result_minmax[31:24] = (sel_minmax[3] == 1'b1) ? operand_a_i[31:24] : minmax_b[31:24];\n  assign result_minmax[23:16] = (sel_minmax[2] == 1'b1) ? operand_a_i[23:16] : minmax_b[23:16];\n  assign result_minmax[15:8] = (sel_minmax[1] == 1'b1) ? operand_a_i[15:8] : minmax_b[15:8];\n  assign result_minmax[7:0] = (sel_minmax[0] == 1'b1) ? operand_a_i[7:0] : minmax_b[7:0];\n\n  //////////////////////////////////////////////////\n  // Clip\n  //////////////////////////////////////////////////\n  logic [31:0] clip_result;  // result of clip and clip\n\n  always_comb begin\n    clip_result = result_minmax;\n    if (operator_i == ALU_CLIPU) begin\n      if (operand_a_i[31] || is_equal_clip) begin\n        clip_result = '0;\n      end else begin\n        clip_result = result_minmax;\n      end\n    end else begin\n      //CLIP\n      if (adder_result_expanded[36] || is_equal_clip) begin\n        clip_result = operand_b_neg;\n      end else begin\n        clip_result = result_minmax;\n      end\n    end\n\n  end\n\n  //////////////////////////////////////////////////\n  //  ____  _   _ _   _ _____ _____ _     _____   //\n  // / ___|| | | | | | |  ___|  ___| |   | ____|  //\n  // \\___ \\| |_| | | | | |_  | |_  | |   |  _|    //\n  //  ___) |  _  | |_| |  _| |  _| | |___| |___   //\n  // |____/|_| |_|\\___/|_|   |_|   |_____|_____|  //\n  //                                              //\n  //////////////////////////////////////////////////\n\n  logic [3:0][1:0] shuffle_byte_sel;  // select byte in register: 31:24, 23:16, 15:8, 7:0\n  logic [3:0]      shuffle_reg_sel;  // select register: rD/rS2 or rS1\n  logic [1:0]      shuffle_reg1_sel;  // select register rD or rS2 for next stage\n  logic [1:0]      shuffle_reg0_sel;\n  logic [3:0]      shuffle_through;\n\n  logic [31:0] shuffle_r1, shuffle_r0;\n  logic [31:0] shuffle_r1_in, shuffle_r0_in;\n  logic [31:0] shuffle_result;\n  logic [31:0] pack_result;\n\n\n  always_comb begin\n    shuffle_reg_sel  = '0;\n    shuffle_reg1_sel = 2'b01;\n    shuffle_reg0_sel = 2'b10;\n    shuffle_through  = '1;\n\n    unique case (operator_i)\n      ALU_EXT, ALU_EXTS: begin\n        if (operator_i == ALU_EXTS) shuffle_reg1_sel = 2'b11;\n\n        if (vector_mode_i == VEC_MODE8) begin\n          shuffle_reg_sel[3:1] = 3'b111;\n          shuffle_reg_sel[0]   = 1'b0;\n        end else begin\n          shuffle_reg_sel[3:2] = 2'b11;\n          shuffle_reg_sel[1:0] = 2'b00;\n        end\n      end\n\n      ALU_PCKLO: begin\n        shuffle_reg1_sel = 2'b00;\n\n        if (vector_mode_i == VEC_MODE8) begin\n          shuffle_through = 4'b0011;\n          shuffle_reg_sel = 4'b0001;\n        end else begin\n          shuffle_reg_sel = 4'b0011;\n        end\n      end\n\n      ALU_PCKHI: begin\n        shuffle_reg1_sel = 2'b00;\n\n        if (vector_mode_i == VEC_MODE8) begin\n          shuffle_through = 4'b1100;\n          shuffle_reg_sel = 4'b0100;\n        end else begin\n          shuffle_reg_sel = 4'b0011;\n        end\n      end\n\n      ALU_SHUF2: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_reg_sel[3] = ~operand_b_i[26];\n            shuffle_reg_sel[2] = ~operand_b_i[18];\n            shuffle_reg_sel[1] = ~operand_b_i[10];\n            shuffle_reg_sel[0] = ~operand_b_i[2];\n          end\n\n          VEC_MODE16: begin\n            shuffle_reg_sel[3] = ~operand_b_i[17];\n            shuffle_reg_sel[2] = ~operand_b_i[17];\n            shuffle_reg_sel[1] = ~operand_b_i[1];\n            shuffle_reg_sel[0] = ~operand_b_i[1];\n          end\n          default: ;\n        endcase\n      end\n\n      ALU_INS: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_reg0_sel = 2'b00;\n            unique case (imm_vec_ext_i)\n              2'b00: begin\n                shuffle_reg_sel[3:0] = 4'b1110;\n              end\n              2'b01: begin\n                shuffle_reg_sel[3:0] = 4'b1101;\n              end\n              2'b10: begin\n                shuffle_reg_sel[3:0] = 4'b1011;\n              end\n              2'b11: begin\n                shuffle_reg_sel[3:0] = 4'b0111;\n              end\n            endcase\n          end\n          VEC_MODE16: begin\n            shuffle_reg0_sel   = 2'b01;\n            shuffle_reg_sel[3] = ~imm_vec_ext_i[0];\n            shuffle_reg_sel[2] = ~imm_vec_ext_i[0];\n            shuffle_reg_sel[1] = imm_vec_ext_i[0];\n            shuffle_reg_sel[0] = imm_vec_ext_i[0];\n          end\n          default: ;\n        endcase\n      end\n\n      default: ;\n    endcase\n  end\n\n  always_comb begin\n    shuffle_byte_sel = '0;\n\n    // byte selector\n    unique case (operator_i)\n      ALU_EXTS, ALU_EXT: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_byte_sel[3] = imm_vec_ext_i[1:0];\n            shuffle_byte_sel[2] = imm_vec_ext_i[1:0];\n            shuffle_byte_sel[1] = imm_vec_ext_i[1:0];\n            shuffle_byte_sel[0] = imm_vec_ext_i[1:0];\n          end\n\n          VEC_MODE16: begin\n            shuffle_byte_sel[3] = {imm_vec_ext_i[0], 1'b1};\n            shuffle_byte_sel[2] = {imm_vec_ext_i[0], 1'b1};\n            shuffle_byte_sel[1] = {imm_vec_ext_i[0], 1'b1};\n            shuffle_byte_sel[0] = {imm_vec_ext_i[0], 1'b0};\n          end\n\n          default: ;\n        endcase\n      end\n\n      ALU_PCKLO: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_byte_sel[3] = 2'b00;\n            shuffle_byte_sel[2] = 2'b00;\n            shuffle_byte_sel[1] = 2'b00;\n            shuffle_byte_sel[0] = 2'b00;\n          end\n\n          VEC_MODE16: begin\n            shuffle_byte_sel[3] = 2'b01;\n            shuffle_byte_sel[2] = 2'b00;\n            shuffle_byte_sel[1] = 2'b01;\n            shuffle_byte_sel[0] = 2'b00;\n          end\n\n          default: ;\n        endcase\n      end\n\n      ALU_PCKHI: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_byte_sel[3] = 2'b00;\n            shuffle_byte_sel[2] = 2'b00;\n            shuffle_byte_sel[1] = 2'b00;\n            shuffle_byte_sel[0] = 2'b00;\n          end\n\n          VEC_MODE16: begin\n            shuffle_byte_sel[3] = 2'b11;\n            shuffle_byte_sel[2] = 2'b10;\n            shuffle_byte_sel[1] = 2'b11;\n            shuffle_byte_sel[0] = 2'b10;\n          end\n\n          default: ;\n        endcase\n      end\n\n      ALU_SHUF2, ALU_SHUF: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_byte_sel[3] = operand_b_i[25:24];\n            shuffle_byte_sel[2] = operand_b_i[17:16];\n            shuffle_byte_sel[1] = operand_b_i[9:8];\n            shuffle_byte_sel[0] = operand_b_i[1:0];\n          end\n\n          VEC_MODE16: begin\n            shuffle_byte_sel[3] = {operand_b_i[16], 1'b1};\n            shuffle_byte_sel[2] = {operand_b_i[16], 1'b0};\n            shuffle_byte_sel[1] = {operand_b_i[0], 1'b1};\n            shuffle_byte_sel[0] = {operand_b_i[0], 1'b0};\n          end\n          default: ;\n        endcase\n      end\n\n      ALU_INS: begin\n        shuffle_byte_sel[3] = 2'b11;\n        shuffle_byte_sel[2] = 2'b10;\n        shuffle_byte_sel[1] = 2'b01;\n        shuffle_byte_sel[0] = 2'b00;\n      end\n\n      default: ;\n    endcase\n  end\n\n  assign shuffle_r0_in = shuffle_reg0_sel[1] ?\n                          operand_a_i :\n                          (shuffle_reg0_sel[0] ? {2{operand_a_i[15:0]}} : {4{operand_a_i[7:0]}});\n\n  assign shuffle_r1_in = shuffle_reg1_sel[1] ? {\n    {8{operand_a_i[31]}}, {8{operand_a_i[23]}}, {8{operand_a_i[15]}}, {8{operand_a_i[7]}}\n  } : (shuffle_reg1_sel[0] ? operand_c_i : operand_b_i);\n\n  assign shuffle_r0[31:24] = shuffle_byte_sel[3][1] ?\n                              (shuffle_byte_sel[3][0] ? shuffle_r0_in[31:24] : shuffle_r0_in[23:16]) :\n                              (shuffle_byte_sel[3][0] ? shuffle_r0_in[15: 8] : shuffle_r0_in[ 7: 0]);\n  assign shuffle_r0[23:16] = shuffle_byte_sel[2][1] ?\n                              (shuffle_byte_sel[2][0] ? shuffle_r0_in[31:24] : shuffle_r0_in[23:16]) :\n                              (shuffle_byte_sel[2][0] ? shuffle_r0_in[15: 8] : shuffle_r0_in[ 7: 0]);\n  assign shuffle_r0[15: 8] = shuffle_byte_sel[1][1] ?\n                              (shuffle_byte_sel[1][0] ? shuffle_r0_in[31:24] : shuffle_r0_in[23:16]) :\n                              (shuffle_byte_sel[1][0] ? shuffle_r0_in[15: 8] : shuffle_r0_in[ 7: 0]);\n  assign shuffle_r0[ 7: 0] = shuffle_byte_sel[0][1] ?\n                              (shuffle_byte_sel[0][0] ? shuffle_r0_in[31:24] : shuffle_r0_in[23:16]) :\n                              (shuffle_byte_sel[0][0] ? shuffle_r0_in[15: 8] : shuffle_r0_in[ 7: 0]);\n\n  assign shuffle_r1[31:24] = shuffle_byte_sel[3][1] ?\n                              (shuffle_byte_sel[3][0] ? shuffle_r1_in[31:24] : shuffle_r1_in[23:16]) :\n                              (shuffle_byte_sel[3][0] ? shuffle_r1_in[15: 8] : shuffle_r1_in[ 7: 0]);\n  assign shuffle_r1[23:16] = shuffle_byte_sel[2][1] ?\n                              (shuffle_byte_sel[2][0] ? shuffle_r1_in[31:24] : shuffle_r1_in[23:16]) :\n                              (shuffle_byte_sel[2][0] ? shuffle_r1_in[15: 8] : shuffle_r1_in[ 7: 0]);\n  assign shuffle_r1[15: 8] = shuffle_byte_sel[1][1] ?\n                              (shuffle_byte_sel[1][0] ? shuffle_r1_in[31:24] : shuffle_r1_in[23:16]) :\n                              (shuffle_byte_sel[1][0] ? shuffle_r1_in[15: 8] : shuffle_r1_in[ 7: 0]);\n  assign shuffle_r1[ 7: 0] = shuffle_byte_sel[0][1] ?\n                              (shuffle_byte_sel[0][0] ? shuffle_r1_in[31:24] : shuffle_r1_in[23:16]) :\n                              (shuffle_byte_sel[0][0] ? shuffle_r1_in[15: 8] : shuffle_r1_in[ 7: 0]);\n\n  assign shuffle_result[31:24] = shuffle_reg_sel[3] ? shuffle_r1[31:24] : shuffle_r0[31:24];\n  assign shuffle_result[23:16] = shuffle_reg_sel[2] ? shuffle_r1[23:16] : shuffle_r0[23:16];\n  assign shuffle_result[15:8] = shuffle_reg_sel[1] ? shuffle_r1[15:8] : shuffle_r0[15:8];\n  assign shuffle_result[7:0] = shuffle_reg_sel[0] ? shuffle_r1[7:0] : shuffle_r0[7:0];\n\n  assign pack_result[31:24] = shuffle_through[3] ? shuffle_result[31:24] : operand_c_i[31:24];\n  assign pack_result[23:16] = shuffle_through[2] ? shuffle_result[23:16] : operand_c_i[23:16];\n  assign pack_result[15:8] = shuffle_through[1] ? shuffle_result[15:8] : operand_c_i[15:8];\n  assign pack_result[7:0] = shuffle_through[0] ? shuffle_result[7:0] : operand_c_i[7:0];\n\n\n  /////////////////////////////////////////////////////////////////////\n  //   ____  _ _      ____                  _      ___               //\n  //  | __ )(_) |_   / ___|___  _   _ _ __ | |_   / _ \\ _ __  ___    //\n  //  |  _ \\| | __| | |   / _ \\| | | | '_ \\| __| | | | | '_ \\/ __|   //\n  //  | |_) | | |_  | |__| (_) | |_| | | | | |_  | |_| | |_) \\__ \\_  //\n  //  |____/|_|\\__|  \\____\\___/ \\__,_|_| |_|\\__|  \\___/| .__/|___(_) //\n  //                                                   |_|           //\n  /////////////////////////////////////////////////////////////////////\n\n  logic [31:0] ff_input;  // either op_a_i or its bit reversed version\n  logic [ 5:0] cnt_result;  // population count\n  logic [ 5:0] clb_result;  // count leading bits\n  logic [ 4:0] ff1_result;  // holds the index of the first '1'\n  logic        ff_no_one;  // if no ones are found\n  logic [ 4:0] fl1_result;  // holds the index of the last '1'\n  logic [ 5:0] bitop_result;  // result of all bitop operations muxed together\n\n  cv32e40p_popcnt popcnt_i (\n      .in_i    (operand_a_i),\n      .result_o(cnt_result)\n  );\n\n  always_comb begin\n    ff_input = '0;\n\n    case (operator_i)\n      ALU_FF1: ff_input = operand_a_i;\n\n      ALU_DIVU, ALU_REMU, ALU_FL1: ff_input = operand_a_rev;\n\n      ALU_DIV, ALU_REM, ALU_CLB: begin\n        if (operand_a_i[31]) ff_input = operand_a_neg_rev;\n        else ff_input = operand_a_rev;\n      end\n    endcase\n  end\n\n  cv32e40p_ff_one ff_one_i (\n      .in_i       (ff_input),\n      .first_one_o(ff1_result),\n      .no_ones_o  (ff_no_one)\n  );\n\n  // special case if ff1_res is 0 (no 1 found), then we keep the 0\n  // this is done in the result mux\n  assign fl1_result = 5'd31 - ff1_result;\n  assign clb_result = ff1_result - 5'd1;\n\n  always_comb begin\n    bitop_result = '0;\n    case (operator_i)\n      ALU_FF1: bitop_result = ff_no_one ? 6'd32 : {1'b0, ff1_result};\n      ALU_FL1: bitop_result = ff_no_one ? 6'd32 : {1'b0, fl1_result};\n      ALU_CNT: bitop_result = cnt_result;\n      ALU_CLB: begin\n        if (ff_no_one) begin\n          if (operand_a_i[31]) bitop_result = 6'd31;\n          else bitop_result = '0;\n        end else begin\n          bitop_result = clb_result;\n        end\n      end\n      default: ;\n    endcase\n  end\n\n\n  ////////////////////////////////////////////////\n  //  ____  _ _     __  __             _        //\n  // | __ )(_) |_  |  \\/  | __ _ _ __ (_)_ __   //\n  // |  _ \\| | __| | |\\/| |/ _` | '_ \\| | '_ \\  //\n  // | |_) | | |_  | |  | | (_| | | | | | |_) | //\n  // |____/|_|\\__| |_|  |_|\\__,_|_| |_|_| .__/  //\n  //                                    |_|     //\n  ////////////////////////////////////////////////\n\n  logic extract_is_signed;\n  logic extract_sign;\n  logic [31:0] bmask_first, bmask_inv;\n  logic [31:0] bextins_and;\n  logic [31:0] bextins_result, bclr_result, bset_result;\n\n\n  // construct bit mask for insert/extract/bclr/bset\n  // bmask looks like this 00..0011..1100..00\n  assign bmask_first       = {32'hFFFFFFFE} << bmask_a_i;\n  assign bmask             = (~bmask_first) << bmask_b_i;\n  assign bmask_inv         = ~bmask;\n\n  assign bextins_and       = (operator_i == ALU_BINS) ? operand_c_i : {32{extract_sign}};\n\n  assign extract_is_signed = (operator_i == ALU_BEXT);\n  assign extract_sign      = extract_is_signed & shift_result[bmask_a_i];\n\n  assign bextins_result    = (bmask & shift_result) | (bextins_and & bmask_inv);\n\n  assign bclr_result       = operand_a_i & bmask_inv;\n  assign bset_result       = operand_a_i | bmask;\n\n  /////////////////////////////////////////////////////////////////////////////////\n  //  ____ _____ _______     _____  ________      ________ _____   _____ ______  //\n  // |  _ \\_   _|__   __|   |  __ \\|  ____\\ \\    / /  ____|  __ \\ / ____|  ____| //\n  // | |_) || |    | |______| |__) | |__   \\ \\  / /| |__  | |__) | (___ | |__    //\n  // |  _ < | |    | |______|  _  /|  __|   \\ \\/ / |  __| |  _  / \\___ \\|  __|   //\n  // | |_) || |_   | |      | | \\ \\| |____   \\  /  | |____| | \\ \\ ____) | |____  //\n  // |____/_____|  |_|      |_|  \\_\\______|   \\/   |______|_|  \\_\\_____/|______| //\n  //                                                                             //\n  /////////////////////////////////////////////////////////////////////////////////\n\n  logic [31:0] radix_2_rev;\n  logic [31:0] radix_4_rev;\n  logic [31:0] radix_8_rev;\n  logic [31:0] reverse_result;\n  logic [ 1:0] radix_mux_sel;\n\n  assign radix_mux_sel = bmask_a_i[1:0];\n\n  generate\n    // radix-2 bit reverse\n    for (j = 0; j < 32; j++) begin : gen_radix_2_rev\n      assign radix_2_rev[j] = shift_result[31-j];\n    end\n    // radix-4 bit reverse\n    for (j = 0; j < 16; j++) begin : gen_radix_4_rev\n      assign radix_4_rev[2*j+1:2*j] = shift_result[31-j*2:31-j*2-1];\n    end\n    // radix-8 bit reverse\n    for (j = 0; j < 10; j++) begin : gen_radix_8_rev\n      assign radix_8_rev[3*j+2:3*j] = shift_result[31-j*3:31-j*3-2];\n    end\n    assign radix_8_rev[31:30] = 2'b0;\n  endgenerate\n\n  always_comb begin\n    reverse_result = '0;\n\n    unique case (radix_mux_sel)\n      2'b00: reverse_result = radix_2_rev;\n      2'b01: reverse_result = radix_4_rev;\n      2'b10: reverse_result = radix_8_rev;\n\n      default: reverse_result = radix_2_rev;\n    endcase\n  end\n\n  ////////////////////////////////////////////////////\n  //  ____ _____     __     __  ____  _____ __  __  //\n  // |  _ \\_ _\\ \\   / /    / / |  _ \\| ____|  \\/  | //\n  // | | | | | \\ \\ / /    / /  | |_) |  _| | |\\/| | //\n  // | |_| | |  \\ V /    / /   |  _ <| |___| |  | | //\n  // |____/___|  \\_/    /_/    |_| \\_\\_____|_|  |_| //\n  //                                                //\n  ////////////////////////////////////////////////////\n\n  logic [31:0] result_div;\n  logic        div_ready;\n  logic        div_signed;\n  logic        div_op_a_signed;\n  logic [ 5:0] div_shift_int;\n\n  assign div_signed = operator_i[0];\n\n  assign div_op_a_signed = operand_a_i[31] & div_signed;\n\n  assign div_shift_int = ff_no_one ? 6'd31 : clb_result;\n  assign div_shift = div_shift_int + (div_op_a_signed ? 6'd0 : 6'd1);\n\n  assign div_valid = enable_i & ((operator_i == ALU_DIV) || (operator_i == ALU_DIVU) ||\n                     (operator_i == ALU_REM) || (operator_i == ALU_REMU));\n\n  // inputs A and B are swapped\n  cv32e40p_alu_div alu_div_i (\n      .Clk_CI (clk),\n      .Rst_RBI(rst_n),\n\n      // input IF\n      .OpA_DI      (operand_b_i),\n      .OpB_DI      (shift_left_result),\n      .OpBShift_DI (div_shift),\n      .OpBIsZero_SI((cnt_result == 0)),\n\n      .OpBSign_SI(div_op_a_signed),\n      .OpCode_SI (operator_i[1:0]),\n\n      .Res_DO(result_div),\n\n      // Hand-Shake\n      .InVld_SI (div_valid),\n      .OutRdy_SI(ex_ready_i),\n      .OutVld_SO(div_ready)\n  );\n\n  ////////////////////////////////////////////////////////\n  //   ____                 _ _     __  __              //\n  //  |  _ \\ ___  ___ _   _| | |_  |  \\/  |_   ___  __  //\n  //  | |_) / _ \\/ __| | | | | __| | |\\/| | | | \\ \\/ /  //\n  //  |  _ <  __/\\__ \\ |_| | | |_  | |  | | |_| |>  <   //\n  //  |_| \\_\\___||___/\\__,_|_|\\__| |_|  |_|\\__,_/_/\\_\\  //\n  //                                                    //\n  ////////////////////////////////////////////////////////\n\n  always_comb begin\n    result_o = '0;\n\n    unique case (operator_i)\n      // Standard Operations\n      ALU_AND: result_o = operand_a_i & operand_b_i;\n      ALU_OR:  result_o = operand_a_i | operand_b_i;\n      ALU_XOR: result_o = operand_a_i ^ operand_b_i;\n\n      // Shift Operations\n      ALU_ADD, ALU_ADDR, ALU_ADDU, ALU_ADDUR,\n      ALU_SUB, ALU_SUBR, ALU_SUBU, ALU_SUBUR,\n      ALU_SLL,\n      ALU_SRL, ALU_SRA,\n      ALU_ROR:\n      result_o = shift_result;\n\n      // bit manipulation instructions\n      ALU_BINS, ALU_BEXT, ALU_BEXTU: result_o = bextins_result;\n\n      ALU_BCLR: result_o = bclr_result;\n      ALU_BSET: result_o = bset_result;\n\n      // Bit reverse instruction\n      ALU_BREV: result_o = reverse_result;\n\n      // pack and shuffle operations\n      ALU_SHUF, ALU_SHUF2, ALU_PCKLO, ALU_PCKHI, ALU_EXT, ALU_EXTS, ALU_INS: result_o = pack_result;\n\n      // Min/Max/Ins\n      ALU_MIN, ALU_MINU, ALU_MAX, ALU_MAXU: result_o = result_minmax;\n\n      //Abs/Cplxconj , ABS is used to do 0 - A for Cplxconj\n      ALU_ABS: result_o = is_clpx_i ? {adder_result[31:16], operand_a_i[15:0]} : result_minmax;\n\n      ALU_CLIP, ALU_CLIPU: result_o = clip_result;\n\n      // Comparison Operations\n      ALU_EQ, ALU_NE, ALU_GTU, ALU_GEU, ALU_LTU, ALU_LEU, ALU_GTS, ALU_GES, ALU_LTS, ALU_LES: begin\n        result_o[31:24] = {8{cmp_result[3]}};\n        result_o[23:16] = {8{cmp_result[2]}};\n        result_o[15:8]  = {8{cmp_result[1]}};\n        result_o[7:0]   = {8{cmp_result[0]}};\n      end\n      // Non-vector comparisons\n      ALU_SLTS, ALU_SLTU, ALU_SLETS, ALU_SLETU: result_o = {31'b0, comparison_result_o};\n\n      ALU_FF1, ALU_FL1, ALU_CLB, ALU_CNT: result_o = {26'h0, bitop_result[5:0]};\n\n      // Division Unit Commands\n      ALU_DIV, ALU_DIVU, ALU_REM, ALU_REMU: result_o = result_div;\n\n      default: ;  // default case to suppress unique warning\n    endcase\n  end\n\n  assign ready_o = div_ready;\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);