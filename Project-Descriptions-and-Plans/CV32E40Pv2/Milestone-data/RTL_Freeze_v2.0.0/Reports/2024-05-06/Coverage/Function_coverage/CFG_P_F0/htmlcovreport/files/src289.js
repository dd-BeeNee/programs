var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/src/fpnew_cast_multi.sv","src":"// Copyright 2019 ETH Zurich and University of Bologna.\n//\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// SPDX-License-Identifier: SHL-0.51\n\n// Author: Stefan Mach <smach@iis.ee.ethz.ch>\n\n`include \"common_cells/registers.svh\"\n\nmodule fpnew_cast_multi #(\n  parameter fpnew_pkg::fmt_logic_t   FpFmtConfig  = '1,\n  parameter fpnew_pkg::ifmt_logic_t  IntFmtConfig = '1,\n  // FPU configuration\n  parameter int unsigned             NumPipeRegs = 0,\n  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,\n  parameter type                     TagType     = logic,\n  parameter type                     AuxType     = logic,\n  // Do not change\n  localparam int unsigned WIDTH = fpnew_pkg::maximum(fpnew_pkg::max_fp_width(FpFmtConfig),\n                                                     fpnew_pkg::max_int_width(IntFmtConfig)),\n  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,\n  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs\n) (\n  input  logic                   clk_i,\n  input  logic                   rst_ni,\n  // Input signals\n  input  logic [WIDTH-1:0]       operands_i, // 1 operand\n  input  logic [NUM_FORMATS-1:0] is_boxed_i, // 1 operand\n  input  fpnew_pkg::roundmode_e  rnd_mode_i,\n  input  fpnew_pkg::operation_e  op_i,\n  input  logic                   op_mod_i,\n  input  fpnew_pkg::fp_format_e  src_fmt_i,\n  input  fpnew_pkg::fp_format_e  dst_fmt_i,\n  input  fpnew_pkg::int_format_e int_fmt_i,\n  input  TagType                 tag_i,\n  input  logic                   mask_i,\n  input  AuxType                 aux_i,\n  // Input Handshake\n  input  logic                   in_valid_i,\n  output logic                   in_ready_o,\n  input  logic                   flush_i,\n  // Output signals\n  output logic [WIDTH-1:0]       result_o,\n  output fpnew_pkg::status_t     status_o,\n  output logic                   extension_bit_o,\n  output TagType                 tag_o,\n  output logic                   mask_o,\n  output AuxType                 aux_o,\n  // Output handshake\n  output logic                   out_valid_o,\n  input  logic                   out_ready_i,\n  // Indication of valid data in flight\n  output logic                   busy_o,\n  // External register enable override\n  input  logic [ExtRegEnaWidth-1:0] reg_ena_i\n);\n\n  // ----------\n  // Constants\n  // ----------\n  localparam int unsigned NUM_INT_FORMATS = fpnew_pkg::NUM_INT_FORMATS;\n  localparam int unsigned MAX_INT_WIDTH   = fpnew_pkg::max_int_width(IntFmtConfig);\n\n  localparam fpnew_pkg::fp_encoding_t SUPER_FORMAT = fpnew_pkg::super_format(FpFmtConfig);\n\n  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;\n  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;\n  localparam int unsigned SUPER_BIAS     = 2**(SUPER_EXP_BITS - 1) - 1;\n\n  // The internal mantissa includes normal bit or an entire integer\n  localparam int unsigned INT_MAN_WIDTH = fpnew_pkg::maximum(SUPER_MAN_BITS + 1, MAX_INT_WIDTH);\n  // If needed, there will be a LZC for renormalization\n  localparam int unsigned LZC_RESULT_WIDTH = $clog2(INT_MAN_WIDTH);\n  // The internal exponent must be able to represent the smallest denormal input value as signed\n  // or the number of bits in an integer\n  localparam int unsigned INT_EXP_WIDTH = fpnew_pkg::maximum($clog2(MAX_INT_WIDTH),\n      fpnew_pkg::maximum(SUPER_EXP_BITS, $clog2(SUPER_BIAS + SUPER_MAN_BITS))) + 1;\n  // Pipelines\n  localparam NUM_INP_REGS = PipeConfig == fpnew_pkg::BEFORE\n                            ? NumPipeRegs\n                            : (PipeConfig == fpnew_pkg::DISTRIBUTED\n                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs\n                               : 0); // no regs here otherwise\n  localparam NUM_MID_REGS = PipeConfig == fpnew_pkg::INSIDE\n                          ? NumPipeRegs\n                          : (PipeConfig == fpnew_pkg::DISTRIBUTED\n                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs\n                             : 0); // no regs here otherwise\n  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER\n                            ? NumPipeRegs\n                            : (PipeConfig == fpnew_pkg::DISTRIBUTED\n                               ? (NumPipeRegs / 3) // Last to get distributed regs\n                               : 0); // no regs here otherwise\n\n  // ---------------\n  // Input pipeline\n  // ---------------\n  // Selected pipeline output signals as non-arrays\n  logic [WIDTH-1:0]       operands_q;\n  logic [NUM_FORMATS-1:0] is_boxed_q;\n  logic                   op_mod_q;\n  fpnew_pkg::fp_format_e  src_fmt_q;\n  fpnew_pkg::fp_format_e  dst_fmt_q;\n  fpnew_pkg::int_format_e int_fmt_q;\n\n  // Input pipeline signals, index i holds signal after i register stages\n  logic                   [0:NUM_INP_REGS][WIDTH-1:0]       inp_pipe_operands_q;\n  logic                   [0:NUM_INP_REGS][NUM_FORMATS-1:0] inp_pipe_is_boxed_q;\n  fpnew_pkg::roundmode_e  [0:NUM_INP_REGS]                  inp_pipe_rnd_mode_q;\n  fpnew_pkg::operation_e  [0:NUM_INP_REGS]                  inp_pipe_op_q;\n  logic                   [0:NUM_INP_REGS]                  inp_pipe_op_mod_q;\n  fpnew_pkg::fp_format_e  [0:NUM_INP_REGS]                  inp_pipe_src_fmt_q;\n  fpnew_pkg::fp_format_e  [0:NUM_INP_REGS]                  inp_pipe_dst_fmt_q;\n  fpnew_pkg::int_format_e [0:NUM_INP_REGS]                  inp_pipe_int_fmt_q;\n  TagType                 [0:NUM_INP_REGS]                  inp_pipe_tag_q;\n  logic                   [0:NUM_INP_REGS]                  inp_pipe_mask_q;\n  AuxType                 [0:NUM_INP_REGS]                  inp_pipe_aux_q;\n  logic                   [0:NUM_INP_REGS]                  inp_pipe_valid_q;\n  // Ready signal is combinatorial for all stages\n  logic [0:NUM_INP_REGS] inp_pipe_ready;\n\n  // Input stage: First element of pipeline is taken from inputs\n  assign inp_pipe_operands_q[0] = operands_i;\n  assign inp_pipe_is_boxed_q[0] = is_boxed_i;\n  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;\n  assign inp_pipe_op_q[0]       = op_i;\n  assign inp_pipe_op_mod_q[0]   = op_mod_i;\n  assign inp_pipe_src_fmt_q[0]  = src_fmt_i;\n  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;\n  assign inp_pipe_int_fmt_q[0]  = int_fmt_i;\n  assign inp_pipe_tag_q[0]      = tag_i;\n  assign inp_pipe_mask_q[0]     = mask_i;\n  assign inp_pipe_aux_q[0]      = aux_i;\n  assign inp_pipe_valid_q[0]    = in_valid_i;\n  // Input stage: Propagate pipeline ready signal to updtream circuitry\n  assign in_ready_o = inp_pipe_ready[0];\n  // Generate the register stages\n  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline\n    // Internal register enable for this stage\n    logic reg_ena;\n    // Determine the ready signal of the current stage - advance the pipeline:\n    // 1. if the next stage is ready for our data\n    // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];\n    // Valid: enabled by ready signal, synchronous clear with the flush signal\n    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n    // Enable register if pipleine ready and a valid data item is present\n    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];\n    // Generate the pipeline registers within the stages, use enable-registers\n    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)\n    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)\n    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)\n    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)\n    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)\n    `FFL(inp_pipe_src_fmt_q[i+1],  inp_pipe_src_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))\n    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))\n    `FFL(inp_pipe_int_fmt_q[i+1],  inp_pipe_int_fmt_q[i],  reg_ena, fpnew_pkg::int_format_e'(0))\n    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))\n    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)\n    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))\n  end\n  // Output stage: assign selected pipe outputs to signals for later use\n  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];\n  assign is_boxed_q = inp_pipe_is_boxed_q[NUM_INP_REGS];\n  assign op_mod_q   = inp_pipe_op_mod_q[NUM_INP_REGS];\n  assign src_fmt_q  = inp_pipe_src_fmt_q[NUM_INP_REGS];\n  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];\n  assign int_fmt_q  = inp_pipe_int_fmt_q[NUM_INP_REGS];\n\n  // -----------------\n  // Input processing\n  // -----------------\n  logic src_is_int, dst_is_int; // if 0, it's a float\n\n  assign src_is_int = (inp_pipe_op_q[NUM_INP_REGS] == fpnew_pkg::I2F);\n  assign dst_is_int = (inp_pipe_op_q[NUM_INP_REGS] == fpnew_pkg::F2I);\n\n  logic [INT_MAN_WIDTH-1:0] encoded_mant; // input mantissa with implicit bit\n\n  logic        [NUM_FORMATS-1:0]                    fmt_sign;\n  logic signed [NUM_FORMATS-1:0][INT_EXP_WIDTH-1:0] fmt_exponent;\n  logic        [NUM_FORMATS-1:0][INT_MAN_WIDTH-1:0] fmt_mantissa;\n  logic signed [NUM_FORMATS-1:0][INT_EXP_WIDTH-1:0] fmt_shift_compensation; // for LZC\n\n  fpnew_pkg::fp_info_t [NUM_FORMATS-1:0] info;\n\n  logic [NUM_INT_FORMATS-1:0][INT_MAN_WIDTH-1:0] ifmt_input_val;\n  logic                                          int_sign;\n  logic [INT_MAN_WIDTH-1:0]                      int_value, int_mantissa;\n\n  // FP Input initialization\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_init_inputs\n    // Set up some constants\n    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));\n\n    if (FpFmtConfig[fmt]) begin : active_format\n      // Classify input\n      fpnew_classifier #(\n        .FpFormat    ( fpnew_pkg::fp_format_e'(fmt) ),\n        .NumOperands ( 1                            )\n      ) i_fpnew_classifier (\n        .operands_i ( operands_q[FP_WIDTH-1:0] ),\n        .is_boxed_i ( is_boxed_q[fmt]          ),\n        .info_o     ( info[fmt]                )\n      );\n\n      assign fmt_sign[fmt]     = operands_q[FP_WIDTH-1];\n      assign fmt_exponent[fmt] = signed'({1'b0, operands_q[MAN_BITS+:EXP_BITS]});\n      assign fmt_mantissa[fmt] = {info[fmt].is_normal, operands_q[MAN_BITS-1:0]}; // zero pad\n      // Compensation for the difference in mantissa widths used for leading-zero count\n      assign fmt_shift_compensation[fmt] = signed'(INT_MAN_WIDTH - 1 - MAN_BITS);\n    end else begin : inactive_format\n      assign info[fmt]                   = '{default: fpnew_pkg::DONT_CARE}; // format disabled\n      assign fmt_sign[fmt]               = fpnew_pkg::DONT_CARE;             // format disabled\n      assign fmt_exponent[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled\n      assign fmt_mantissa[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled\n      assign fmt_shift_compensation[fmt] = '{default: fpnew_pkg::DONT_CARE}; // format disabled\n    end\n  end\n\n  // Sign-extend INT input\n  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_sign_extend_int\n    // Set up some constants\n    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));\n\n    if (IntFmtConfig[ifmt]) begin : active_format // only active formats\n      always_comb begin : sign_ext_input\n        // sign-extend value only if it's signed\n        ifmt_input_val[ifmt]                = '{default: operands_q[INT_WIDTH-1] & ~op_mod_q};\n        ifmt_input_val[ifmt][INT_WIDTH-1:0] = operands_q[INT_WIDTH-1:0];\n      end\n    end else begin : inactive_format\n      assign ifmt_input_val[ifmt] = '{default: fpnew_pkg::DONT_CARE}; // format disabled\n    end\n  end\n\n  // Construct input mantissa from integer\n  assign int_value    = ifmt_input_val[int_fmt_q];\n  assign int_sign     = int_value[INT_MAN_WIDTH-1] & ~op_mod_q; // only signed ints are negative\n  assign int_mantissa = int_sign ? unsigned'(-int_value) : int_value; // get magnitude of negative\n\n  // select mantissa with source format\n  assign encoded_mant = src_is_int ? int_mantissa : fmt_mantissa[src_fmt_q];\n\n  // --------------\n  // Normalization\n  // --------------\n  logic signed [INT_EXP_WIDTH-1:0] src_bias;      // src format bias\n  logic signed [INT_EXP_WIDTH-1:0] src_exp;       // src format exponent (biased)\n  logic signed [INT_EXP_WIDTH-1:0] src_subnormal; // src is subnormal\n  logic signed [INT_EXP_WIDTH-1:0] src_offset;    // src offset within mantissa\n\n  assign src_bias      = signed'(fpnew_pkg::bias(src_fmt_q));\n  assign src_exp       = fmt_exponent[src_fmt_q];\n  assign src_subnormal = signed'({1'b0, info[src_fmt_q].is_subnormal});\n  assign src_offset    = fmt_shift_compensation[src_fmt_q];\n\n  logic                            input_sign;   // input sign\n  logic signed [INT_EXP_WIDTH-1:0] input_exp;    // unbiased true exponent\n  logic        [INT_MAN_WIDTH-1:0] input_mant;   // normalized input mantissa\n  logic                            mant_is_zero; // for integer zeroes\n\n  logic signed [INT_EXP_WIDTH-1:0] fp_input_exp;\n  logic signed [INT_EXP_WIDTH-1:0] int_input_exp;\n\n  // Input mantissa needs to be normalized\n  logic [LZC_RESULT_WIDTH-1:0] renorm_shamt;     // renormalization shift amount\n  logic [LZC_RESULT_WIDTH:0]   renorm_shamt_sgn; // signed form for calculations\n\n  // Leading-zero counter is needed for renormalization\n  lzc #(\n    .WIDTH ( INT_MAN_WIDTH ),\n    .MODE  ( 1             ) // MODE = 1 counts leading zeroes\n  ) i_lzc (\n    .in_i    ( encoded_mant ),\n    .cnt_o   ( renorm_shamt ),\n    .empty_o ( mant_is_zero )\n  );\n  assign renorm_shamt_sgn = signed'({1'b0, renorm_shamt});\n\n  // Get the sign from the proper source\n  assign input_sign = src_is_int ? int_sign : fmt_sign[src_fmt_q];\n  // Realign input mantissa, append zeroes if destination is wider\n  assign input_mant = encoded_mant << renorm_shamt;\n  // Unbias exponent and compensate for shift\n  assign fp_input_exp  = signed'(src_exp + src_subnormal - src_bias -\n                                 renorm_shamt_sgn + src_offset); // compensate for shift\n  assign int_input_exp = signed'(INT_MAN_WIDTH - 1 - renorm_shamt_sgn);\n\n  assign input_exp     = src_is_int ? int_input_exp : fp_input_exp;\n\n  logic signed [INT_EXP_WIDTH-1:0] destination_exp;  // re-biased exponent for destination\n\n  // Rebias the exponent\n  assign destination_exp = input_exp + signed'(fpnew_pkg::bias(dst_fmt_q));\n\n  // ---------------\n  // Internal pipeline\n  // ---------------\n  // Pipeline output signals as non-arrays\n  logic                            input_sign_q;\n  logic signed [INT_EXP_WIDTH-1:0] input_exp_q;\n  logic [INT_MAN_WIDTH-1:0]        input_mant_q;\n  logic signed [INT_EXP_WIDTH-1:0] destination_exp_q;\n  logic                            src_is_int_q;\n  logic                            dst_is_int_q;\n  fpnew_pkg::fp_info_t             info_q;\n  logic                            mant_is_zero_q;\n  logic                            op_mod_q2;\n  fpnew_pkg::roundmode_e           rnd_mode_q;\n  fpnew_pkg::fp_format_e           src_fmt_q2;\n  fpnew_pkg::fp_format_e           dst_fmt_q2;\n  fpnew_pkg::int_format_e          int_fmt_q2;\n  // Internal pipeline signals, index i holds signal after i register stages\n\n\n  logic                   [0:NUM_MID_REGS]                    mid_pipe_input_sign_q;\n  logic signed            [0:NUM_MID_REGS][INT_EXP_WIDTH-1:0] mid_pipe_input_exp_q;\n  logic                   [0:NUM_MID_REGS][INT_MAN_WIDTH-1:0] mid_pipe_input_mant_q;\n  logic signed            [0:NUM_MID_REGS][INT_EXP_WIDTH-1:0] mid_pipe_dest_exp_q;\n  logic                   [0:NUM_MID_REGS]                    mid_pipe_src_is_int_q;\n  logic                   [0:NUM_MID_REGS]                    mid_pipe_dst_is_int_q;\n  fpnew_pkg::fp_info_t    [0:NUM_MID_REGS]                    mid_pipe_info_q;\n  logic                   [0:NUM_MID_REGS]                    mid_pipe_mant_zero_q;\n  logic                   [0:NUM_MID_REGS]                    mid_pipe_op_mod_q;\n  fpnew_pkg::roundmode_e  [0:NUM_MID_REGS]                    mid_pipe_rnd_mode_q;\n  fpnew_pkg::fp_format_e  [0:NUM_MID_REGS]                    mid_pipe_src_fmt_q;\n  fpnew_pkg::fp_format_e  [0:NUM_MID_REGS]                    mid_pipe_dst_fmt_q;\n  fpnew_pkg::int_format_e [0:NUM_MID_REGS]                    mid_pipe_int_fmt_q;\n  TagType                 [0:NUM_MID_REGS]                    mid_pipe_tag_q;\n  logic                   [0:NUM_MID_REGS]                    mid_pipe_mask_q;\n  AuxType                 [0:NUM_MID_REGS]                    mid_pipe_aux_q;\n  logic                   [0:NUM_MID_REGS]                    mid_pipe_valid_q;\n  // Ready signal is combinatorial for all stages\n  logic [0:NUM_MID_REGS] mid_pipe_ready;\n\n  // Input stage: First element of pipeline is taken from upstream logic\n  assign mid_pipe_input_sign_q[0] = input_sign;\n  assign mid_pipe_input_exp_q[0]  = input_exp;\n  assign mid_pipe_input_mant_q[0] = input_mant;\n  assign mid_pipe_dest_exp_q[0]   = destination_exp;\n  assign mid_pipe_src_is_int_q[0] = src_is_int;\n  assign mid_pipe_dst_is_int_q[0] = dst_is_int;\n  assign mid_pipe_info_q[0]       = info[src_fmt_q];\n  assign mid_pipe_mant_zero_q[0]  = mant_is_zero;\n  assign mid_pipe_op_mod_q[0]     = op_mod_q;\n  assign mid_pipe_rnd_mode_q[0]   = inp_pipe_rnd_mode_q[NUM_INP_REGS];\n  assign mid_pipe_src_fmt_q[0]    = src_fmt_q;\n  assign mid_pipe_dst_fmt_q[0]    = dst_fmt_q;\n  assign mid_pipe_int_fmt_q[0]    = int_fmt_q;\n  assign mid_pipe_tag_q[0]        = inp_pipe_tag_q[NUM_INP_REGS];\n  assign mid_pipe_mask_q[0]       = inp_pipe_mask_q[NUM_INP_REGS];\n  assign mid_pipe_aux_q[0]        = inp_pipe_aux_q[NUM_INP_REGS];\n  assign mid_pipe_valid_q[0]      = inp_pipe_valid_q[NUM_INP_REGS];\n  // Input stage: Propagate pipeline ready signal to input pipe\n  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];\n\n  // Generate the register stages\n  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline\n    // Internal register enable for this stage\n    logic reg_ena;\n    // Determine the ready signal of the current stage - advance the pipeline:\n    // 1. if the next stage is ready for our data\n    // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];\n    // Valid: enabled by ready signal, synchronous clear with the flush signal\n    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n    // Enable register if pipleine ready and a valid data item is present\n    assign reg_ena = (mid_pipe_ready[i] & mid_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];\n    // Generate the pipeline registers within the stages, use enable-registers\n    `FFL(mid_pipe_input_sign_q[i+1], mid_pipe_input_sign_q[i], reg_ena, '0)\n    `FFL(mid_pipe_input_exp_q[i+1],  mid_pipe_input_exp_q[i],  reg_ena, '0)\n    `FFL(mid_pipe_input_mant_q[i+1], mid_pipe_input_mant_q[i], reg_ena, '0)\n    `FFL(mid_pipe_dest_exp_q[i+1],   mid_pipe_dest_exp_q[i],   reg_ena, '0)\n    `FFL(mid_pipe_src_is_int_q[i+1], mid_pipe_src_is_int_q[i], reg_ena, '0)\n    `FFL(mid_pipe_dst_is_int_q[i+1], mid_pipe_dst_is_int_q[i], reg_ena, '0)\n    `FFL(mid_pipe_info_q[i+1],       mid_pipe_info_q[i],       reg_ena, '0)\n    `FFL(mid_pipe_mant_zero_q[i+1],  mid_pipe_mant_zero_q[i],  reg_ena, '0)\n    `FFL(mid_pipe_op_mod_q[i+1],     mid_pipe_op_mod_q[i],     reg_ena, '0)\n    `FFL(mid_pipe_rnd_mode_q[i+1],   mid_pipe_rnd_mode_q[i],   reg_ena, fpnew_pkg::RNE)\n    `FFL(mid_pipe_src_fmt_q[i+1],    mid_pipe_src_fmt_q[i],    reg_ena, fpnew_pkg::fp_format_e'(0))\n    `FFL(mid_pipe_dst_fmt_q[i+1],    mid_pipe_dst_fmt_q[i],    reg_ena, fpnew_pkg::fp_format_e'(0))\n    `FFL(mid_pipe_int_fmt_q[i+1],    mid_pipe_int_fmt_q[i],    reg_ena, fpnew_pkg::int_format_e'(0))\n    `FFL(mid_pipe_tag_q[i+1],        mid_pipe_tag_q[i],        reg_ena, TagType'('0))\n    `FFL(mid_pipe_mask_q[i+1],       mid_pipe_mask_q[i],       reg_ena, '0)\n    `FFL(mid_pipe_aux_q[i+1],        mid_pipe_aux_q[i],        reg_ena, AuxType'('0))\n  end\n  // Output stage: assign selected pipe outputs to signals for later use\n  assign input_sign_q      = mid_pipe_input_sign_q[NUM_MID_REGS];\n  assign input_exp_q       = mid_pipe_input_exp_q[NUM_MID_REGS];\n  assign input_mant_q      = mid_pipe_input_mant_q[NUM_MID_REGS];\n  assign destination_exp_q = mid_pipe_dest_exp_q[NUM_MID_REGS];\n  assign src_is_int_q      = mid_pipe_src_is_int_q[NUM_MID_REGS];\n  assign dst_is_int_q      = mid_pipe_dst_is_int_q[NUM_MID_REGS];\n  assign info_q            = mid_pipe_info_q[NUM_MID_REGS];\n  assign mant_is_zero_q    = mid_pipe_mant_zero_q[NUM_MID_REGS];\n  assign op_mod_q2         = mid_pipe_op_mod_q[NUM_MID_REGS];\n  assign rnd_mode_q        = mid_pipe_rnd_mode_q[NUM_MID_REGS];\n  assign src_fmt_q2        = mid_pipe_src_fmt_q[NUM_MID_REGS];\n  assign dst_fmt_q2        = mid_pipe_dst_fmt_q[NUM_MID_REGS];\n  assign int_fmt_q2        = mid_pipe_int_fmt_q[NUM_MID_REGS];\n\n  // --------\n  // Casting\n  // --------\n  logic [INT_EXP_WIDTH-1:0] final_exp;        // after eventual adjustments\n\n  logic [2*INT_MAN_WIDTH:0]  preshift_mant;    // mantissa before final shift\n  logic [2*INT_MAN_WIDTH:0]  destination_mant; // mantissa from shifter, with rnd bit\n  logic [SUPER_MAN_BITS-1:0] final_mant;       // mantissa after adjustments\n  logic [MAX_INT_WIDTH-1:0]  final_int;        // integer shifted in position\n\n  logic [$clog2(INT_MAN_WIDTH+1)-1:0] denorm_shamt; // shift amount for denormalization\n\n  logic [1:0] fp_round_sticky_bits, int_round_sticky_bits, round_sticky_bits;\n  logic       of_before_round, uf_before_round;\n\n\n  // Perform adjustments to mantissa and exponent\n  always_comb begin : cast_value\n    // Default assignment\n    final_exp       = unsigned'(destination_exp_q); // take exponent as is, only look at lower bits\n    preshift_mant   = '0;  // initialize mantissa container with zeroes\n    denorm_shamt    = SUPER_MAN_BITS - fpnew_pkg::man_bits(dst_fmt_q2); // right of mantissa\n    of_before_round = 1'b0;\n    uf_before_round = 1'b0;\n\n    // Place mantissa to the left of the shifter\n    preshift_mant = input_mant_q << (INT_MAN_WIDTH + 1);\n\n    // Handle INT casts\n    if (dst_is_int_q) begin\n      // By default right shift mantissa to be an integer\n      denorm_shamt = unsigned'(MAX_INT_WIDTH - 1 - input_exp_q);\n      // overflow: when converting to unsigned the range is larger by one\n      if ((input_exp_q >= signed'(fpnew_pkg::int_width(int_fmt_q2) - 1 + op_mod_q2))    // Exponent larger than max int range,\n          && !(!op_mod_q2                                                               // unless cast to signed int\n               && input_sign_q                                                          // and input value is larges negative int value\n               && (input_exp_q == signed'(fpnew_pkg::int_width(int_fmt_q2) - 1))\n               && (input_mant_q == {1'b1, {INT_MAN_WIDTH-1{1'b0}}}))) begin\n        denorm_shamt    = '0; // prevent shifting\n        of_before_round = 1'b1;\n      // underflow\n      end else if (input_exp_q < -1) begin\n        denorm_shamt    = MAX_INT_WIDTH + 1; // all bits go to the sticky\n        uf_before_round = 1'b1;\n      end\n    // Handle FP over-/underflows\n    end else begin\n      // Overflow or infinities (for proper rounding)\n      if ((destination_exp_q >= signed'(2**fpnew_pkg::exp_bits(dst_fmt_q2))-1) ||\n          (~src_is_int_q && info_q.is_inf)) begin\n        final_exp       = unsigned'(2**fpnew_pkg::exp_bits(dst_fmt_q2)-2); // largest normal value\n        preshift_mant   = '1;                           // largest normal value and RS bits set\n        of_before_round = 1'b1;\n      // Denormalize underflowing values\n      end else if (destination_exp_q < 1 &&\n                   destination_exp_q >= -signed'(fpnew_pkg::man_bits(dst_fmt_q2))) begin\n        final_exp       = '0; // denormal result\n        denorm_shamt    = unsigned'(denorm_shamt + 1 - destination_exp_q); // adjust right shifting\n        uf_before_round = 1'b1;\n      // Limit the shift to retain sticky bits\n      end else if (destination_exp_q < -signed'(fpnew_pkg::man_bits(dst_fmt_q2))) begin\n        final_exp       = '0; // denormal result\n        denorm_shamt    = unsigned'(denorm_shamt + 2 + fpnew_pkg::man_bits(dst_fmt_q2)); // to sticky\n        uf_before_round = 1'b1;\n      end\n    end\n  end\n\n  localparam NUM_FP_STICKY  = 2 * INT_MAN_WIDTH - SUPER_MAN_BITS - 1; // removed mantissa, 1. and R\n  localparam NUM_INT_STICKY = 2 * INT_MAN_WIDTH - MAX_INT_WIDTH; // removed int and R\n\n  // Mantissa adjustment shift\n  assign destination_mant = preshift_mant >> denorm_shamt;\n  // Extract final mantissa and round bit, discard the normal bit (for FP)\n  assign {final_mant, fp_round_sticky_bits[1]} =\n      destination_mant[2*INT_MAN_WIDTH-1-:SUPER_MAN_BITS+1];\n  assign {final_int, int_round_sticky_bits[1]} = destination_mant[2*INT_MAN_WIDTH-:MAX_INT_WIDTH+1];\n  // Collapse sticky bits\n  assign fp_round_sticky_bits[0]  = (| {destination_mant[NUM_FP_STICKY-1:0]});\n  assign int_round_sticky_bits[0] = (| {destination_mant[NUM_INT_STICKY-1:0]});\n\n  // select RS bits for destination operation\n  assign round_sticky_bits = dst_is_int_q ? int_round_sticky_bits : fp_round_sticky_bits;\n\n  // ----------------------------\n  // Rounding and classification\n  // ----------------------------\n  logic [WIDTH-1:0] pre_round_abs;  // absolute value of result before rnd\n  logic             of_after_round; // overflow\n  logic             uf_after_round; // underflow\n\n  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_pre_round_abs; // per format\n  logic [NUM_FORMATS-1:0]            fmt_of_after_round;\n  logic [NUM_FORMATS-1:0]            fmt_uf_after_round;\n\n  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_pre_round_abs; // per format\n  logic [NUM_INT_FORMATS-1:0]            ifmt_of_after_round;\n\n  logic             rounded_sign;\n  logic [WIDTH-1:0] rounded_abs; // absolute value of result after rounding\n  logic             result_true_zero;\n\n  logic [WIDTH-1:0] rounded_int_res; // after possible inversion\n  logic             rounded_int_res_zero; // after rounding\n\n\n  // Pack exponent and mantissa into proper rounding form\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble\n    // Set up some constants\n    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));\n\n    if (FpFmtConfig[fmt]) begin : active_format\n      always_comb begin : assemble_result\n        fmt_pre_round_abs[fmt] = {final_exp[EXP_BITS-1:0], final_mant[MAN_BITS-1:0]}; // 0-extend\n      end\n    end else begin : inactive_format\n      assign fmt_pre_round_abs[fmt] = '{default: fpnew_pkg::DONT_CARE};\n    end\n  end\n\n  // Sign-extend integer result\n  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_res_sign_ext\n    // Set up some constants\n    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));\n\n    if (IntFmtConfig[ifmt]) begin : active_format\n      always_comb begin : assemble_result\n        // sign-extend reusult\n        ifmt_pre_round_abs[ifmt]                = '{default: final_int[INT_WIDTH-1]};\n        ifmt_pre_round_abs[ifmt][INT_WIDTH-1:0] = final_int[INT_WIDTH-1:0];\n      end\n    end else begin : inactive_format\n      assign ifmt_pre_round_abs[ifmt] = '{default: fpnew_pkg::DONT_CARE};\n    end\n  end\n\n  // Select output with destination format and operation\n  assign pre_round_abs = dst_is_int_q ? ifmt_pre_round_abs[int_fmt_q2] : fmt_pre_round_abs[dst_fmt_q2];\n\n  fpnew_rounding #(\n    .AbsWidth ( WIDTH )\n  ) i_fpnew_rounding (\n    .abs_value_i             ( pre_round_abs     ),\n    .sign_i                  ( input_sign_q      ), // source format\n    .round_sticky_bits_i     ( round_sticky_bits ),\n    .rnd_mode_i              ( rnd_mode_q        ),\n    .effective_subtraction_i ( 1'b0              ), // no operation happened\n    .abs_rounded_o           ( rounded_abs       ),\n    .sign_o                  ( rounded_sign      ),\n    .exact_zero_o            ( result_true_zero  )\n  );\n\n  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_result;\n\n  // Detect overflows and inject sign\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject\n    // Set up some constants\n    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));\n\n    if (FpFmtConfig[fmt]) begin : active_format\n      always_comb begin : post_process\n        // detect of / uf\n        fmt_uf_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0; // denormal\n        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.\n\n        // Assemble regular result, nan box short ones. Int zeroes need to be detected`\n        fmt_result[fmt]               = '1;\n        fmt_result[fmt][FP_WIDTH-1:0] = src_is_int_q & mant_is_zero_q\n                                        ? '0\n                                        : {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};\n      end\n    end else begin : inactive_format\n      assign fmt_uf_after_round[fmt] = fpnew_pkg::DONT_CARE;\n      assign fmt_of_after_round[fmt] = fpnew_pkg::DONT_CARE;\n      assign fmt_result[fmt]         = '{default: fpnew_pkg::DONT_CARE};\n    end\n  end\n\n  // Negative integer result needs to be brought into two's complement\n  assign rounded_int_res      = rounded_sign ? unsigned'(-rounded_abs) : rounded_abs;\n  assign rounded_int_res_zero = (rounded_int_res == '0);\n\n  // Detect integer overflows after rounding (only positives)\n  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_overflow\n    // Set up some constants\n    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));\n\n    if (IntFmtConfig[ifmt]) begin : active_format\n      always_comb begin : detect_overflow\n        ifmt_of_after_round[ifmt] = 1'b0;\n        // Int result can overflow if we're at the max exponent\n        if (!rounded_sign && input_exp_q == signed'(INT_WIDTH - 2 + op_mod_q2)) begin\n          // Check whether the rounded MSB differs from unrounded MSB\n          ifmt_of_after_round[ifmt] = ~rounded_int_res[INT_WIDTH-2+op_mod_q2];\n        end\n      end\n    end else begin : inactive_format\n      assign ifmt_of_after_round[ifmt] = fpnew_pkg::DONT_CARE;\n    end\n  end\n\n  // Classification after rounding select by destination format\n  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];\n  assign of_after_round = dst_is_int_q ? ifmt_of_after_round[int_fmt_q2] : fmt_of_after_round[dst_fmt_q2];\n\n  // -------------------------\n  // FP Special case handling\n  // -------------------------\n  logic [WIDTH-1:0]   fp_special_result;\n  fpnew_pkg::status_t fp_special_status;\n  logic               fp_result_is_special;\n\n  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_special_result;\n\n  // Special result construction\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results\n    // Set up some constants\n    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));\n    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));\n\n    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;\n    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);\n\n    if (FpFmtConfig[fmt]) begin : active_format\n      always_comb begin : special_results\n        logic [FP_WIDTH-1:0] special_res;\n        special_res = info_q.is_zero\n                      ? input_sign_q << FP_WIDTH-1 // signed zero\n                      : {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN\n\n        // Initialize special result with ones (NaN-box)\n        fmt_special_result[fmt]               = '1;\n        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;\n      end\n    end else begin : inactive_format\n      assign fmt_special_result[fmt] = '{default: fpnew_pkg::DONT_CARE};\n    end\n  end\n\n  // Detect special case from source format, I2F casts don't produce a special result\n  assign fp_result_is_special = ~src_is_int_q & (info_q.is_zero |\n                                                 info_q.is_nan |\n                                                 ~info_q.is_boxed);\n\n  // Signalling input NaNs raise invalid flag, otherwise no flags set\n  assign fp_special_status = '{NV: info_q.is_signalling, default: 1'b0};\n\n  // Assemble result according to destination format\n  assign fp_special_result = fmt_special_result[dst_fmt_q2]; // destination format\n\n  // --------------------------\n  // INT Special case handling\n  // --------------------------\n  logic [WIDTH-1:0]   int_special_result;\n  fpnew_pkg::status_t int_special_status;\n  logic               int_result_is_special;\n\n  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_special_result;\n\n  // Special result construction\n  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_special_results_int\n    // Set up some constants\n    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));\n\n    if (IntFmtConfig[ifmt]) begin : active_format\n      always_comb begin : special_results\n        automatic logic [INT_WIDTH-1:0] special_res;\n\n        // Default is overflow to positive max, which is 2**INT_WIDTH-1 or 2**(INT_WIDTH-1)-1\n        special_res[INT_WIDTH-2:0] = '1;       // alone yields 2**(INT_WIDTH-1)-1\n        special_res[INT_WIDTH-1]   = op_mod_q2; // for unsigned casts yields 2**INT_WIDTH-1\n\n        // Negative special case (except for nans) tie to -max or 0\n        if (input_sign_q && !info_q.is_nan)\n          special_res = ~special_res;\n\n        // Initialize special result with sign-extension\n        ifmt_special_result[ifmt]                = '{default: special_res[INT_WIDTH-1]};\n        ifmt_special_result[ifmt][INT_WIDTH-1:0] = special_res;\n      end\n    end else begin : inactive_format\n      assign ifmt_special_result[ifmt] = '{default: fpnew_pkg::DONT_CARE};\n    end\n  end\n\n  // Detect special case from source format (inf, nan, overflow, nan-boxing or negative unsigned)\n  assign int_result_is_special = info_q.is_nan | info_q.is_inf |\n                                 of_before_round | of_after_round | ~info_q.is_boxed |\n                                 (input_sign_q & op_mod_q2 & ~rounded_int_res_zero);\n\n  // All integer special cases are invalid\n  assign int_special_status = '{NV: 1'b1, default: 1'b0};\n\n  // Assemble result according to destination format\n  assign int_special_result = ifmt_special_result[int_fmt_q2]; // destination format\n\n  // -----------------\n  // Result selection\n  // -----------------\n  fpnew_pkg::status_t int_regular_status, fp_regular_status;\n\n  logic [WIDTH-1:0]   fp_result, int_result;\n  fpnew_pkg::status_t fp_status, int_status;\n\n  assign fp_regular_status.NV = src_is_int_q & (of_before_round | of_after_round); // overflow is invalid for I2F casts\n  assign fp_regular_status.DZ = 1'b0; // no divisions\n  assign fp_regular_status.OF = ~src_is_int_q & (~info_q.is_inf & (of_before_round | of_after_round)); // inf casts no OF\n  assign fp_regular_status.UF = uf_after_round & fp_regular_status.NX;\n  assign fp_regular_status.NX = src_is_int_q ? (| fp_round_sticky_bits) // overflow is invalid in i2f\n            : (| fp_round_sticky_bits) | (~info_q.is_inf & (of_before_round | of_after_round));\n  assign int_regular_status = '{NX: (| int_round_sticky_bits), default: 1'b0};\n\n  assign fp_result  = fp_result_is_special  ? fp_special_result  : fmt_result[dst_fmt_q2];\n  assign fp_status  = fp_result_is_special  ? fp_special_status  : fp_regular_status;\n  assign int_result = int_result_is_special ? int_special_result : rounded_int_res;\n  assign int_status = int_result_is_special ? int_special_status : int_regular_status;\n\n  // Final results for output pipeline\n  logic [WIDTH-1:0]   result_d;\n  fpnew_pkg::status_t status_d;\n  logic               extension_bit;\n\n  // Select output depending on special case detection\n  assign result_d = dst_is_int_q ? int_result : fp_result;\n  assign status_d = dst_is_int_q ? int_status : fp_status;\n\n  // MSB of int result decides extension, otherwise NaN box\n  assign extension_bit = dst_is_int_q ? int_result[WIDTH-1] : 1'b1;\n\n  // ----------------\n  // Output Pipeline\n  // ----------------\n  // Output pipeline signals, index i holds signal after i register stages\n  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;\n  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;\n  logic               [0:NUM_OUT_REGS]            out_pipe_ext_bit_q;\n  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;\n  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;\n  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;\n  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;\n  // Ready signal is combinatorial for all stages\n  logic [0:NUM_OUT_REGS] out_pipe_ready;\n\n  // Input stage: First element of pipeline is taken from inputs\n  assign out_pipe_result_q[0]  = result_d;\n  assign out_pipe_status_q[0]  = status_d;\n  assign out_pipe_ext_bit_q[0] = extension_bit;\n  assign out_pipe_tag_q[0]     = mid_pipe_tag_q[NUM_MID_REGS];\n  assign out_pipe_mask_q[0]    = mid_pipe_mask_q[NUM_MID_REGS];\n  assign out_pipe_aux_q[0]     = mid_pipe_aux_q[NUM_MID_REGS];\n  assign out_pipe_valid_q[0]   = mid_pipe_valid_q[NUM_MID_REGS];\n  // Input stage: Propagate pipeline ready signal to inside pipe\n  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];\n  // Generate the register stages\n  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline\n    // Internal register enable for this stage\n    logic reg_ena;\n    // Determine the ready signal of the current stage - advance the pipeline:\n    // 1. if the next stage is ready for our data\n    // 2. if the next stage only holds a bubble (not valid) -> we can pop it\n    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];\n    // Valid: enabled by ready signal, synchronous clear with the flush signal\n    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)\n    // Enable register if pipleine ready and a valid data item is present\n    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + NUM_MID_REGS + i];\n    // Generate the pipeline registers within the stages, use enable-registers\n    `FFL(out_pipe_result_q[i+1],  out_pipe_result_q[i],  reg_ena, '0)\n    `FFL(out_pipe_status_q[i+1],  out_pipe_status_q[i],  reg_ena, '0)\n    `FFL(out_pipe_ext_bit_q[i+1], out_pipe_ext_bit_q[i], reg_ena, '0)\n    `FFL(out_pipe_tag_q[i+1],     out_pipe_tag_q[i],     reg_ena, TagType'('0))\n    `FFL(out_pipe_mask_q[i+1],    out_pipe_mask_q[i],    reg_ena, '0)\n    `FFL(out_pipe_aux_q[i+1],     out_pipe_aux_q[i],     reg_ena, AuxType'('0))\n  end\n  // Output stage: Ready travels backwards from output side, driven by downstream circuitry\n  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;\n  // Output stage: assign module outputs\n  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];\n  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];\n  assign extension_bit_o = out_pipe_ext_bit_q[NUM_OUT_REGS];\n  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];\n  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];\n  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];\n  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];\n  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});\nendmodule\n","lang":"verilog"};
processSrcData(g_data);