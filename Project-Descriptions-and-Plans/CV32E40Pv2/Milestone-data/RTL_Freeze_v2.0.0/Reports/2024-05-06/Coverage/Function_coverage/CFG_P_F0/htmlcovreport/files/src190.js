var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/env/uvme/cov/uvme_cv32e40p_fp_instr_covg.sv","src":"///////////////////////////////////////////////////////////////////////////////\n// Copyright 2023 OpenHW Group\n// Copyright 2023 Dolphin Design\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://solderpad.org/licenses/\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n//\n///////////////////////////////////////////////////////////////////////////////\n\nclass uvme_cv32e40p_fp_instr_covg extends uvm_component;\n    /*\n    * Class members\n    */\n    uvme_cv32e40p_cfg_c    cfg;\n    uvme_cv32e40p_cntxt_c  cntxt;\n\n    `uvm_component_utils_begin(uvme_cv32e40p_fp_instr_covg)\n      `uvm_field_object(cfg  , UVM_DEFAULT)\n      `uvm_field_object(cntxt, UVM_DEFAULT)\n    `uvm_component_utils_end\n\n    extern function new(string name = \"cv32e40p_fp_instr_covg\", uvm_component parent = null);\n    extern function void build_phase(uvm_phase phase);\n    extern task run_phase(uvm_phase phase);\n    extern task sample_clk_i();\n\n    `include \"uvme_cv32e40p_cov_model_macros.sv\"\n\n    `define FPU_MULTICYCLE_WINDOW_ILLEGAL_CASES \\\n     illegal_bins clk_2_19_group_NON_DIVSQRT  = ( (!binsof(cp_curr_fpu_apu_op) intersect {APU_OP_FDIV, APU_OP_FSQRT}) && (!binsof(cp_f_multicycle_clk_window) intersect {1}) ) \\\n                                                   with ( (cp_f_multicycle_clk_window != 0) & (fpu_latency == 0) ); \\\n     illegal_bins clk_3_19_group_NON_DIVSQRT  = ( (!binsof(cp_curr_fpu_apu_op) intersect {APU_OP_FDIV, APU_OP_FSQRT}) && (!binsof(cp_f_multicycle_clk_window) intersect {1, 2}) ) \\\n                                                   with ( (cp_f_multicycle_clk_window != 0) & (fpu_latency == 1) ); \\\n     illegal_bins clk_4_19_group_NON_DIVSQRT  = ( (!binsof(cp_curr_fpu_apu_op) intersect {APU_OP_FDIV, APU_OP_FSQRT}) && (!binsof(cp_f_multicycle_clk_window) intersect {1, 2, 3}) ) \\\n                                                   with ( (cp_f_multicycle_clk_window != 0) & (fpu_latency == 2) );\n\n    `define FPU_ZERO_LATENCY_ILLEGAL_BUSY \\\n     illegal_bins apu_busy_curr_apu_op_not_div_sqrt = ( !binsof(cp_curr_fpu_apu_op_multicycle) intersect {APU_OP_FDIV, APU_OP_FSQRT} ) \\\n                                                      with ( ((cp_curr_fpu_apu_op_multicycle + 1) * (fpu_latency == 0)) != 0 );\n\n    `define IGNORE_BINS_NON_FD_F_INSTR \\\n     ignore_bins non_fd_f_inst = binsof(cp_curr_fpu_apu_op) intersect {`APU_INSTR_WITH_NO_FD};\n\n    `define IGNORE_BINS_ZERO_LAT_FPU_OP \\\n     ignore_bins zero_lat_inst = ( !binsof(cp_curr_fpu_apu_op) intersect {APU_OP_FDIV, APU_OP_FSQRT} ) \\\n                                 with ( ((cp_curr_fpu_apu_op + 1) * (fpu_latency == 0)) != 0 );\n\n    `define IGNORE_BINS_CONTENTION_IN_LSU_WITH_APU \\\n     ignore_bins in_contention_lsu_wr = ( binsof(cp_apu_contention) intersect {1} ) \\\n                                        with ( ((cp_curr_fpu_apu_op + 1) * (fpu_latency == 1)) != 0 );\n\n    `define IGNORE_BINS_NON_FS1_F_INSTR \\\n     ignore_bins non_fs3_f_inst = !binsof(cp_id_stage_f_inst) intersect {`RV32F_INSTR_WITH_FS1};\n\n    `define IGNORE_BINS_NON_FS2_F_INSTR \\\n     ignore_bins non_fs3_f_inst = !binsof(cp_id_stage_f_inst) intersect {`RV32F_INSTR_WITH_FS2};\n\n    `define IGNORE_BINS_NON_FS3_F_INSTR \\\n     ignore_bins non_fs3_f_inst = !binsof(cp_id_stage_f_inst) intersect {`RV32F_INSTR_WITH_FS3};\n\n    `define IGNORE_BINS_NON_RD_F_INSTR \\\n     ignore_bins non_rd_f_inst = !binsof(cp_curr_fpu_apu_op) intersect {`APU_INSTR_WITH_NO_FD};\n\n    `define IGNORE_BINS_PREV_NON_FPU_OPCODE_WO_RD \\\n     ignore_bins prev_non_fpu_wo_rd = !binsof(cp_prev_is_non_fpu_opcode) intersect {`RV32_OPCODE_LIST1_WITH_RD};\n\n    `define IGNORE_BINS_CUR_FPU_OPCODE_WO_RS1 \\\n     ignore_bins cur_fpu_wo_rs1 = !binsof(cp_cur_is_fpu_instr) intersect {`RV32F_INSTR_WITH_RS1};\n\n    `define IGNORE_BINS_NON_RS1_F_INSTR_IN_ID \\\n     ignore_bins non_rs_id_stage_f_inst = !binsof(cp_id_stage_f_inst) intersect {`RV32F_INSTR_WITH_RS1};\n\n    `define IGNORE_BINS_NON_RS1_CV32E40P_INSTR \\\n     ignore_bins non_rs1_rv32_instr = binsof(cp_id_stage_non_rv32fc_inst) intersect {TB_OPCODE_LUI,TB_OPCODE_AUIPC,TB_OPCODE_JAL};\n\n    `define IGNORE_BINS_NON_RS2_CV32E40P_INSTR \\\n     ignore_bins non_rs2_rv32_instr = binsof(cp_id_stage_non_rv32fc_inst) intersect {`RV32_OPCODE_WITH_NO_RS2};\n\n    `define IGNORE_BINS_NON_STALLED_CONTENTION_WR_STATE \\\n     ignore_bins non_stalled_contention_wr_state = binsof(cp_contention_state) intersect {0,1};\n\n    `define IGNORE_BINS_NON_FD_F_INSTR_AT_CONTENTION \\\n     ignore_bins non_fd_f_inst = binsof(cp_last_fpu_apu_op_at_contention) intersect {`APU_INSTR_WITH_NO_FD};\n\n    `define IGNORE_BINS_CONTENTION_AT_LSU_REGFILE_WR \\\n     ignore_bins contention_at_lsu_wr = binsof(cp_apu_contention) intersect {1};\n\n    `define IGNORE_BINS_NON_RD_F_INSTR_AT_CONTENTION \\\n     ignore_bins non_rd_f_inst = !binsof(cp_last_fpu_apu_op_at_contention) intersect {`APU_INSTR_WITH_NO_FD};\n\n    `define IGNORE_BINS_NO_CONTENTION \\\n     ignore_bins no_contention = binsof(cp_apu_contention) intersect {1};\n\n    `define IGNORE_BINS_NO_CONTENTION_LSU \\\n     ignore_bins no_contention_lsu_wr = binsof(cp_apu_contention) intersect {0};\n\n    /*\n    * Covergroups\n    */\n\n    covergroup cg_f_multicycle(int fpu_latency);\n        `per_instance_fcov\n        // option.at_least = 10; // this affect ccp as well and some ccp have large cross numbers\n\n        cp_id_stage_f_inst : coverpoint `COVIF_CB.id_stage_instr_rdata_i iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n            `RV32F_INSTR_BINS\n            option.weight = 5;\n        }\n\n        cp_id_stage_apu_op_ex_o : coverpoint `COVIF_CB.id_stage_apu_op_ex_o iff (`COVIF_CB.id_stage_apu_en_ex_o == 1) {\n            `FPU_OP_BINS\n            option.weight = 5;\n        }\n\n        // from bhv_logic_1\n        cp_f_multicycle_clk_window : coverpoint cntxt.cov_vif.if_clk_cycle_window iff ((`COVIF_CB.is_mulh_ex == 0) &&\n                                                                                       (`COVIF_CB.is_misaligned_data_req_ex == 0) &&\n                                                                                       (`COVIF_CB.is_post_inc_ld_st_inst_ex == 0) &&\n                                                                                       (`COVIF_CB.ex_apu_valid_memorised == 0)) {\n            bins clk1 = {1};\n            bins clk2 = {2};\n            bins clk3 = {3};\n            bins clk4 = {4};\n            bins clk5 = {5};\n            bins clk6 = {6};\n            bins clk7 = {7};\n            bins clk8 = {8};\n            bins clk9 = {9};\n            bins clk10 = {10};\n            bins clk11 = {11};\n            bins clk12 = {12};\n            bins clk13 = {13};\n            bins clk14 = {14};\n            bins clk15 = {15};\n            bins clk16 = {16};\n            bins clk17 = {17};\n            bins clk18 = {18};\n            bins clk19 = {19};\n            ignore_bins ignore_idle = {0};\n            illegal_bins clk_more_than_19 = {[20:31]};\n        }\n\n        cp_id_stage_inst_valid : coverpoint `COVIF_CB.id_stage_instr_valid_i {\n            bins id_stage_instr_valid = {1};\n        }\n\n        cp_id_stage_apu_en_ex_o : coverpoint `COVIF_CB.id_stage_apu_en_ex_o {\n            bins id_stage_apu_en_ex_1 = {1};\n            bins id_stage_apu_en_ex_0_to_1 = (0 => 1);\n        }\n\n        cp_apu_req_valid : coverpoint `COVIF_CB.apu_req {\n            bins apu_req_valid = {1'b1};\n        }\n\n        cp_apu_grant_valid : coverpoint `COVIF_CB.apu_gnt {\n            bins apu_gnt_valid = {1'b1};\n        }\n\n        cp_apu_busy : coverpoint `COVIF_CB.apu_busy {\n            bins apu_busy_high = {1'b1};\n        }\n\n        // from bhv_logic_1\n        cp_curr_fpu_apu_op : coverpoint cntxt.cov_vif.o_curr_fpu_apu_op_if {\n            `FPU_OP_BINS\n            option.weight = 5;\n        }\n\n        // from bhv_logic_1\n        cp_curr_fpu_apu_op_at_apu_req : coverpoint cntxt.cov_vif.o_curr_fpu_apu_op_if iff ( (`COVIF_CB.apu_req == 1) &&\n                                                                                            (`COVIF_CB.apu_gnt == 1) )\n        {\n            `FPU_OP_BINS\n            option.weight = 5;\n        }\n\n        // from bhv_logic_1\n        cp_curr_fpu_apu_op_multicycle : coverpoint cntxt.cov_vif.o_curr_fpu_apu_op_if iff (`COVIF_CB.apu_busy == 1)\n        {\n            `FPU_OP_BINS\n            ignore_bins cfg_0cyclat_insns = {`RV32F_OP_WITHOUT_FDIV_FSQRT} with ((item >= 0) && (fpu_latency == 0));\n            option.weight = 5;\n        }\n\n        cp_fpu_lat_0_and_2_ex_regfile_alu_wr_no_stall : coverpoint ((`COVIF_CB.is_mulh_ex == 0) &&\n                                                                    (`COVIF_CB.is_misaligned_data_req_ex == 0) &&\n                                                                    (`COVIF_CB.is_post_inc_ld_st_inst_ex == 0) &&\n                                                                    (`COVIF_CB.ex_apu_valid_memorised == 0)) {\n\n            bins no_alu_wr_stall = {1};\n        }\n\n        // cross coverage for F-inst in ID-stage with preceeding F-multicycle instr\n        cr_f_inst_at_id_stage_inp_with_fpu_multicycle_req : cross cp_id_stage_f_inst,\n                                                                  cp_curr_fpu_apu_op_at_apu_req {\n            option.weight = 5;\n        }\n\n        // cross coverage for F-inst in ID-stage with preceeding F-multicycle\n        // case with apu_busy or APU needing more than 1 clock cycle \n        cr_f_inst_at_id_stage_inp_while_fpu_busy : cross cp_id_stage_f_inst,\n                                                         cp_curr_fpu_apu_op_multicycle {\n            option.weight = 5;\n            // For FPU config with Latency=0 , apu_busy is expected to be set only for FDIV and FSQRT case\n            `FPU_ZERO_LATENCY_ILLEGAL_BUSY\n        }\n\n        // cross coverage for F-inst arriving at ID-stage input at various stages of APU latency\n        // clk-cycles of the ongoing/preceeding F-multicycle instr\n        cr_f_inst_at_id_stage_inp_with_cyc_window_of_ongoing_fpu_calc : cross cp_id_stage_f_inst,\n                                                                              cp_f_multicycle_clk_window,\n                                                                              cp_curr_fpu_apu_op,\n                                                                              cp_fpu_lat_0_and_2_ex_regfile_alu_wr_no_stall {\n            option.weight = 5;\n            `FPU_MULTICYCLE_WINDOW_ILLEGAL_CASES\n        }\n\n        // cross coverage for F-inst at ID-stage output with preceeding F-multicycle instr\n        // Note: Added 2 separate similar cross coverages ID stage because of different\n        // arrival times of next instruction w.r.t APU Req\n        //cr_f_inst_at_id_stage_out_with_fpu_multicycle_req : cross cp_id_stage_apu_op_ex_o,\n        //                                                          cp_curr_fpu_apu_op_at_apu_req\n        //{option.weight = 5;}\n\n        // cross coverage for F-inst at ID-stage output with preceeding F-multicycle\n        // case with apu_busy or APU needing more than 1 clock cycle \n        // Note: Added 2 separate similar cross coverages ID stage because of different\n        // arrival times of next instruction w.r.t APU Req\n        cr_f_inst_at_id_stage_out_while_fpu_busy : cross cp_id_stage_apu_op_ex_o,\n                                                         cp_curr_fpu_apu_op_multicycle {\n            option.weight = 5;\n            `FPU_ZERO_LATENCY_ILLEGAL_BUSY\n        }\n\n        // cross coverage for F-inst arriving at ID-stage output at various stages of APU latency\n        // clk-cycles of the ongoing/preceeding F-multicycle instr\n        // Note: Added 2 separate similar cross coverages ID stage because of different\n        // arrival times of next instruction w.r.t APU Req\n        cr_f_inst_at_id_stage_out_with_cyc_window_of_ongoing_fpu_calc : cross cp_id_stage_apu_op_ex_o,\n                                                                              cp_f_multicycle_clk_window,\n                                                                              cp_curr_fpu_apu_op,\n                                                                              cp_fpu_lat_0_and_2_ex_regfile_alu_wr_no_stall {\n\n            option.weight = 5;\n            `FPU_MULTICYCLE_WINDOW_ILLEGAL_CASES\n            ignore_bins nolatency = binsof(cp_f_multicycle_clk_window.clk1); // for latency == 1 (a.k.a no latency), cp_id_stage_apu_op_ex_o == cp_curr_fpu_apu_op\n        }\n\n    endgroup : cg_f_multicycle\n\n\n    covergroup cg_f_inst_reg(int fpu_latency);\n        `per_instance_fcov\n\n        cp_apu_req_valid : coverpoint `COVIF_CB.apu_req {\n            bins apu_req_valid = {1'b1};\n        }\n\n        cp_apu_grant_valid : coverpoint `COVIF_CB.apu_gnt {\n            bins apu_gnt_valid = {1'b1};\n        }\n\n        cp_apu_busy : coverpoint `COVIF_CB.apu_busy {\n            bins apu_busy_high = {1'b1};\n        }\n\n        cp_apu_rvalid : coverpoint `COVIF_CB.apu_rvalid_i {\n            bins apu_rvalid = {1};\n        }\n\n        cp_apu_contention : coverpoint `COVIF_CB.apu_perf_wb_o {\n            bins no_contention = {0};\n            bins has_contention = {1};\n        }\n\n        // from bhv_logic_1\n        cp_curr_fpu_apu_op : coverpoint cntxt.cov_vif.o_curr_fpu_apu_op_if {\n            `FPU_OP_BINS\n            option.weight = 5;\n        }\n\n        // from bhv_logic_1a\n        // f-ext instr only uses rs1 for xreg\n        cp_cur_fp_rs1_match_prev_nonfp_rd : coverpoint (cntxt.cov_vif.current_instr_rdata[19:15] == cntxt.cov_vif.previous_instr_rdata[11:7])\n          iff (cntxt.cov_vif.current_instr_rdata       inside {`RV32F_INSTR_WITH_RS1} && \n               cntxt.cov_vif.previous_instr_rdata[6:0] inside {`RV32_OPCODE_LIST1_WITH_RD} &&\n               cntxt.cov_vif.current_instr_rdata != cntxt.cov_vif.previous_instr_rdata) {\n          bins cur_rs1_match_prev_rd = {1};\n        }\n        cp_cur_is_fpu_instr : coverpoint cntxt.cov_vif.current_instr_rdata {\n          `RV32F_INSTR_BINS\n        }\n        cp_prev_is_non_fpu_opcode : coverpoint cntxt.cov_vif.previous_instr_rdata[6:0] {\n          `CV32E40P_INSTR_OPCODE_BIT_6_0_BINS__NO_RV32C_FC_F\n        }\n        cp_prev_is_non_fpu_rd : coverpoint cntxt.cov_vif.previous_instr_rdata[11:7] {\n          bins rd[] = {[0:31]};\n        }\n\n        // from bhv_logic_2\n        cp_last_fpu_apu_op_at_contention : coverpoint cntxt.cov_vif.o_last_fpu_apu_op_if {\n            bins curr_apu_op_fmadd        =    {APU_OP_FMADD}     with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fnmsub       =    {APU_OP_FNMSUB}    with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fadd         =    {APU_OP_FADD}      with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fmul         =    {APU_OP_FMUL}      with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fdiv         =    {APU_OP_FDIV}      ;\n            bins curr_apu_op_fsqrt        =    {APU_OP_FSQRT}     ;\n            bins curr_apu_op_fsgnj        =    {APU_OP_FSGNJ}     with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fminmax      =    {APU_OP_FMINMAX}   with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fcmp         =    {APU_OP_FCMP}      with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fclassify    =    {APU_OP_FCLASSIFY} with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_f2i          =    {APU_OP_F2I}       with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_i2f          =    {APU_OP_I2F}       with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fmsub        =    {APU_OP_FMSUB}     with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fnmadd       =    {APU_OP_FNMADD}    with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fsub         =    {APU_OP_FSUB}      with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_fsgnj_se     =    {APU_OP_FSGNJ_SE}  with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_f2i_u        =    {APU_OP_F2I_U}     with ((item >= 0) && (fpu_latency != 0));\n            bins curr_apu_op_i2f_u        =    {APU_OP_I2F_U}     with ((item >= 0) && (fpu_latency != 0));\n            option.weight = 5;\n        }\n\n        // TODO: need to add another cover point for F-inst at ID-EX boundary ?\n        cp_id_stage_f_inst : coverpoint `COVIF_CB.id_stage_instr_rdata_i\n                                        iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            `RV32F_INSTR_BINS\n            option.weight = 5;\n        }\n\n        // TODO: to add rv32c coverage\n        cp_id_stage_non_rv32fc_inst : coverpoint `COVIF_CB.id_stage_instr_rdata_i[6:0]\n                                                 iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            `CV32E40P_INSTR_OPCODE_BIT_6_0_BINS__NO_RV32C_FC\n            option.weight = 5;\n        }\n\n        cp_id_f_inst_fs1 : coverpoint `COVIF_CB.id_stage_instr_rdata_i[19:15]\n                                      iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            bins fs1[] = {[0:31]};\n        }\n\n        cp_id_f_inst_fs2 : coverpoint `COVIF_CB.id_stage_instr_rdata_i[24:20]\n                                      iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            bins fs2[] = {[0:31]};\n        }\n\n        // from bhv_logic_3\n        cp_curr_fpu_inst_fd : coverpoint cntxt.cov_vif.curr_fpu_fd {\n            bins fd[] = {[0:31]};\n        }\n\n        // from bhv_logic_3\n        cp_curr_fpu_inst_fd_for_0_lat_apu_result : coverpoint cntxt.cov_vif.curr_fpu_fd\n                                                              iff ( (`COVIF_CB.apu_req == 1) &&\n                                                                    (`COVIF_CB.apu_gnt == 1) &&\n                                                                    (`COVIF_CB.apu_rvalid_i == 1) ) {\n\n            bins fd[] = {[0:31]};\n        }\n\n        // from bhv_logic_3\n        cp_curr_fpu_inst_fd_for_multicyc_lat_apu_result : coverpoint cntxt.cov_vif.curr_fpu_fd\n                                                                     iff ( (`COVIF_CB.apu_busy == 1) &&\n                                                                           (`COVIF_CB.apu_rvalid_i == 1) ) {\n\n            bins fd[] = {[0:31]};\n        }\n\n        // from bhv_logic_3\n        cp_curr_fpu_inst_rd : coverpoint cntxt.cov_vif.curr_fpu_rd {\n            bins rd[] = {[0:31]};\n        }\n\n        // from bhv_logic_3\n        cp_curr_fpu_inst_rd_for_0_lat_apu_result : coverpoint cntxt.cov_vif.curr_fpu_rd\n                                                              iff ( (`COVIF_CB.apu_req == 1) &&\n                                                                    (`COVIF_CB.apu_gnt == 1) &&\n                                                                    (`COVIF_CB.apu_rvalid_i == 1) ) {\n\n            bins rd[] = {[0:31]} with (fpu_latency == 0);\n        }\n\n        // from bhv_logic_3\n        cp_curr_fpu_inst_rd_for_multicyc_lat_apu_result : coverpoint cntxt.cov_vif.curr_fpu_rd\n                                                                     iff ( (`COVIF_CB.apu_busy == 1) &&\n                                                                           (`COVIF_CB.apu_rvalid_i == 1) ) {\n\n            bins rd[] = {[0:31]};\n        }\n\n        cp_apu_alu_contention_wr_rd : coverpoint cntxt.cov_vif.curr_rd_at_ex_regfile_wr_contention {\n            bins rd[] = {[0:31]}                        with ( ((item + 1) * (fpu_latency != 1)) != 0 );\n            illegal_bins rd_addr_32_63 = {[32:63]}      with ( ((item + 1) * (fpu_latency != 1)) != 0 );\n        }\n\n        // from bhv_logic_3\n        cp_lsu_apu_contention_wr_rd : coverpoint cntxt.cov_vif.curr_rd_at_wb_regfile_wr_contention {\n            bins rd[] = {[0:31]}                        with ( ((item + 1) * (fpu_latency == 1)) != 0 );\n            bins fd[] = {[32:63]}                       with ( ((item + 1) * (fpu_latency == 1)) != 0 ); // flw uses ls path for load to freq\n        }\n\n        // from bhv_logic_2 (revised)\n        // [optional] this cp is optional as contention has no relation with rd/fd\n        cp_prev_rd_waddr_contention : coverpoint cntxt.cov_vif.prev_rd_waddr_contention {\n            bins rd[] = {[1:31]};\n            bins fd[] = {[32:63]};\n            ignore_bins zero = {0};\n        }\n\n        // from bhv_logic_2\n        cp_contention_state : coverpoint cntxt.cov_vif.contention_state {\n            bins no_contention = {0};\n            bins contention_1st_cyc_done = {1};\n            bins contention_2nd_cyc_done = {2};\n            ignore_bins state3 = {3};\n        }\n\n        cp_b2b_contention : coverpoint cntxt.cov_vif.b2b_contention {\n            bins b2b_contention_true = {1};\n            option.weight = 5;\n        }\n\n        // from bhv_logic_3\n        // next fp_insn fs1 is fd of current fp_insn\n        cp_fd_fs1_eq : coverpoint (`COVIF_CB.id_stage_instr_rdata_i[19:15] == cntxt.cov_vif.curr_fpu_fd)\n                                  iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            bins fd_fs1_equal = {1};\n        }\n\n        // from bhv_logic_3\n        // next fp_insn fs2 is fd of current fp_insn\n        cp_fd_fs2_eq : coverpoint (`COVIF_CB.id_stage_instr_rdata_i[24:20] == cntxt.cov_vif.curr_fpu_fd)\n                                  iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            bins fd_fs2_equal = {1};\n        }\n\n        // from bhv_logic_3\n        // next fp_insn fs3 is fd of current fp_insn\n        cp_fd_fs3_eq : coverpoint (`COVIF_CB.id_stage_instr_rdata_i[31:27] == cntxt.cov_vif.curr_fpu_fd)\n                                  iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            bins fd_fs3_equal = {1};\n        }\n\n        // from bhv_logic_3\n        // next insn rs1 is rd of current fp_insn\n        cp_rd_rs1_eq : coverpoint (`COVIF_CB.id_stage_instr_rdata_i[19:15] == cntxt.cov_vif.curr_fpu_rd)\n                                  iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            bins rd_rs1_equal = {1};\n        }\n\n        // from bhv_logic_3\n        // next insn rs2 is rd of current fp_insn\n        cp_rd_rs2_eq : coverpoint (`COVIF_CB.id_stage_instr_rdata_i[24:20] == cntxt.cov_vif.curr_fpu_rd)\n                                  iff (`COVIF_CB.id_stage_instr_valid_i == 1) {\n\n            bins rd_rs1_equal = {1};\n        }\n\n        //*********************************************************************************************************\n        //     Cross Cov description for reg-to-reg dependency cases in instr sequence with F-multicycle instr\n        //*********************************************************************************************************\n        // This Cross Coverage captures the cases where latest APU execution's RD addr is same as\n        // rs1/rs2/rs3 of the next instruction in pipeline.\n        // Design is expected to stall EX in such scenarios until the previous instruction retires.\n        // The test scenarios are captured for correct RTL behavior, expecting EX stall in such cases.\n        // And for any conflicting design behaviour with EX proceeding without stalls, tests rely on Ref model\n        // to flag the resulting errors.\n        \n        //*********************************************************************************************************\n        // CASES WITH/WITHOUT CONTENTION AT THE TIME OF APU RESULT WRITE TO REGFILE\n        // WHERE APU WRITE WILL WIN (APU LATENCY CONFIG = 0,1,2)\n        //*********************************************************************************************************\n\n        // cross coverage for F-instr following F-instr with fd to fs1 dependency\n        cr_fd_fs1_eq_nonzero_lat : cross cp_fd_fs1_eq,\n                                         cp_id_stage_f_inst,\n                                         cp_curr_fpu_inst_fd_for_multicyc_lat_apu_result,\n                                         cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            `IGNORE_BINS_NON_FS1_F_INSTR            // ignore insn that no fs1\n            `IGNORE_BINS_NON_FD_F_INSTR             // ignore insn APU_OP_FCMP, APU_OP_FCLASSIFY, APU_OP_F2I, APU_OP_F2I_U\n            `IGNORE_BINS_ZERO_LAT_FPU_OP            // only apply in 0cyclat - ignore insn except div and sqrt\n        }\n\n        // cross coverage for F-instr following F-instr with fd to fs2 dependency\n        cr_fd_fs2_eq_nonzero_lat : cross cp_fd_fs2_eq,\n                                         cp_id_stage_f_inst,\n                                         cp_curr_fpu_inst_fd_for_multicyc_lat_apu_result,\n                                         cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            `IGNORE_BINS_NON_FS2_F_INSTR            // ignore insn that no fs2\n            `IGNORE_BINS_NON_FD_F_INSTR\n            `IGNORE_BINS_ZERO_LAT_FPU_OP\n        }\n\n        // cross coverage for F-instr following F-instr with fd to fs3 dependency\n        cr_fd_fs3_eq_nonzero_lat : cross cp_fd_fs3_eq,\n                                         cp_id_stage_f_inst,\n                                         cp_curr_fpu_inst_fd_for_multicyc_lat_apu_result,\n                                         cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            `IGNORE_BINS_NON_FS3_F_INSTR            // ignore insn that no fs3\n            `IGNORE_BINS_NON_FD_F_INSTR\n            `IGNORE_BINS_ZERO_LAT_FPU_OP\n        }\n\n        // cross coverage for F-instr following F-instr with rd to rs1 dependency\n        cr_rd_rs1_eq_nonzero_lat  :  cross cp_rd_rs1_eq,\n                                           cp_id_stage_f_inst,\n                                           cp_curr_fpu_inst_rd_for_multicyc_lat_apu_result,\n                                           cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            `IGNORE_BINS_ZERO_LAT_FPU_OP            // only apply in 0cyclat - ignore insn except div and sqrt\n            `IGNORE_BINS_NON_RD_F_INSTR             // ignore insn except APU_OP_FCMP, APU_OP_FCLASSIFY, APU_OP_F2I, APU_OP_F2I_U in ex_state\n            `IGNORE_BINS_NON_RS1_F_INSTR_IN_ID      // ignore insn except TB_INS_FLW, TB_INS_FSW, TB_INS_FMVSX, TB_INS_FCVTSW, TB_INS_FCVTSWU in dec_state\n        }\n\n        // cross coverage for Non F-instr following F-instr with rd to rs1 dependency\n        cr_rv32f_rd_non_rv32f_rs1_eq_nonzero_lat : cross cp_rd_rs1_eq,\n                                                         cp_id_stage_non_rv32fc_inst,\n                                                         cp_curr_fpu_inst_rd_for_multicyc_lat_apu_result,\n                                                         cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            `IGNORE_BINS_ZERO_LAT_FPU_OP\n            `IGNORE_BINS_NON_RD_F_INSTR\n            `IGNORE_BINS_NON_RS1_CV32E40P_INSTR\n        }\n\n        // cross coverage for Non F-instr following F-instr with rd to rs2 dependency\n        cr_rv32f_rd_non_rv32f_rs2_eq_nonzero_lat : cross cp_rd_rs2_eq,\n                                                         cp_id_stage_non_rv32fc_inst,\n                                                         cp_curr_fpu_inst_rd_for_multicyc_lat_apu_result,\n                                                         cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            `IGNORE_BINS_ZERO_LAT_FPU_OP\n            `IGNORE_BINS_NON_RD_F_INSTR\n            `IGNORE_BINS_NON_RS2_CV32E40P_INSTR\n        }\n\n        // cross coverage for F-instr following Non F-instr with rd to rs1 dependency\n        // e.g prev.non_fp(rd) == cur.fp(rs1)\n        cr_non_rv32f_rd_rv32f_rs1                : cross cp_cur_fp_rs1_match_prev_nonfp_rd,\n                                                         cp_cur_is_fpu_instr,\n                                                         cp_prev_is_non_fpu_opcode,\n                                                         cp_prev_is_non_fpu_rd {\n\n            option.weight = 5;\n            `IGNORE_BINS_PREV_NON_FPU_OPCODE_WO_RD\n            `IGNORE_BINS_CUR_FPU_OPCODE_WO_RS1\n        }\n\n        // cross coverage for contention case 2nd cycle with ALU regfile write\n        cr_waddr_rd_apu_alu_ex_contention : cross cp_apu_alu_contention_wr_rd,\n                                                  cp_contention_state,\n                                                  cp_apu_contention {\n\n            bins main_cr_bin              = cr_waddr_rd_apu_alu_ex_contention with ((cp_contention_state < 3) && (fpu_latency != 1));\n            ignore_bins skip_if_other_cfg = cr_waddr_rd_apu_alu_ex_contention with ((cp_contention_state < 3) && (fpu_latency == 1));\n\n            `IGNORE_BINS_NON_STALLED_CONTENTION_WR_STATE\n            `IGNORE_BINS_NO_CONTENTION\n        }\n\n        //*********************************************************************************************************\n        // CASES WITH/WITHOUT CONTENTION AT APU RESULT WRITE TO REGFILE. APU_LATENCY=0 PRIOIRTY APU WRITE WINS\n        //*********************************************************************************************************\n\n        // cross coverage for F-instr following F-instr with fd to fs1 dependency - 0 Latency\n        cr_fd_fs1_eq_no_lat  :  cross cp_fd_fs1_eq,\n                                      cp_id_stage_f_inst,\n                                      cp_curr_fpu_inst_fd_for_0_lat_apu_result,\n                                      cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_fd_fs1_eq_no_lat with ((cp_fd_fs1_eq == 1) && (fpu_latency == 0));\n            ignore_bins skip_if_other_cfg = cr_fd_fs1_eq_no_lat with ((cp_fd_fs1_eq == 1) && (fpu_latency != 0));\n            `IGNORE_BINS_NON_FD_F_INSTR\n            `IGNORE_BINS_NON_FS1_F_INSTR\n        }\n\n        // cross coverage for F-instr following F-instr with fd to fs2 dependency - 0 Latency\n        cr_fd_fs2_eq_no_lat  :  cross cp_fd_fs2_eq,\n                                      cp_id_stage_f_inst,\n                                      cp_curr_fpu_inst_fd_for_0_lat_apu_result,\n                                      cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_fd_fs2_eq_no_lat with ((cp_fd_fs2_eq == 1) && (fpu_latency == 0));\n            ignore_bins skip_if_other_cfg = cr_fd_fs2_eq_no_lat with ((cp_fd_fs2_eq == 1) && (fpu_latency != 0));\n            `IGNORE_BINS_NON_FD_F_INSTR\n            `IGNORE_BINS_NON_FS2_F_INSTR\n        }\n\n        // cross coverage for F-instr following F-instr with fd to fs3 dependency - 0 Latency\n        cr_fd_fs3_eq_no_lat  :  cross cp_fd_fs3_eq,\n                                      cp_id_stage_f_inst,\n                                      cp_curr_fpu_inst_fd_for_0_lat_apu_result,\n                                      cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_fd_fs3_eq_no_lat with ((cp_fd_fs3_eq == 1) && (fpu_latency == 0));\n            ignore_bins skip_if_other_cfg = cr_fd_fs3_eq_no_lat with ((cp_fd_fs3_eq == 1) && (fpu_latency != 0));\n            `IGNORE_BINS_NON_FD_F_INSTR\n            `IGNORE_BINS_NON_FS3_F_INSTR\n        }\n\n        // cross coverage for F-instr following F-instr with rd to rs1 dependency - 0 latency\n        // example: insn[0].rd == insn[1].rs1 (both are fp_insn)\n        cr_rd_rs1_eq_no_lat  :  cross cp_rd_rs1_eq,\n                                      cp_id_stage_f_inst,\n                                      cp_curr_fpu_inst_rd_for_0_lat_apu_result,\n                                      cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_rd_rs1_eq_no_lat with ((cp_rd_rs1_eq == 1) && (fpu_latency == 0));\n            ignore_bins skip_if_other_cfg = cr_rd_rs1_eq_no_lat with ((cp_rd_rs1_eq == 1) && (fpu_latency != 0));\n            `IGNORE_BINS_NON_RD_F_INSTR\n            `IGNORE_BINS_NON_RS1_F_INSTR_IN_ID\n        }\n\n        // cross coverage for Non F-instr following F-instr with rd to rs1 dependency - 0 Latency\n        cr_rv32f_rd_non_rv32fc_rs1_eq_no_lat  :  cross cp_rd_rs1_eq,\n                                                       cp_id_stage_non_rv32fc_inst,\n                                                       cp_curr_fpu_inst_rd_for_0_lat_apu_result,\n                                                       cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_rv32f_rd_non_rv32fc_rs1_eq_no_lat with ((cp_rd_rs1_eq == 1) && (fpu_latency == 0));\n            ignore_bins skip_if_other_cfg = cr_rv32f_rd_non_rv32fc_rs1_eq_no_lat with ((cp_rd_rs1_eq == 1) && (fpu_latency != 0));\n            `IGNORE_BINS_NON_RD_F_INSTR\n            `IGNORE_BINS_NON_RS1_CV32E40P_INSTR\n        }\n        // cross coverage for Non F-instr following F-instr with rd to rs2 dependency - 0 Latency\n        cr_rv32f_rd_non_rv32fc_rs2_eq_no_lat  :  cross cp_rd_rs2_eq,\n                                                       cp_id_stage_non_rv32fc_inst,\n                                                       cp_curr_fpu_inst_rd_for_0_lat_apu_result,\n                                                       cp_curr_fpu_apu_op {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_rv32f_rd_non_rv32fc_rs2_eq_no_lat with ((cp_rd_rs2_eq == 1) && (fpu_latency == 0));\n            ignore_bins skip_if_other_cfg = cr_rv32f_rd_non_rv32fc_rs2_eq_no_lat with ((cp_rd_rs2_eq == 1) && (fpu_latency != 0));\n            `IGNORE_BINS_NON_RD_F_INSTR\n            `IGNORE_BINS_NON_RS2_CV32E40P_INSTR\n        }\n\n        //*********************************************************************************************************\n        // CONTENTION DURING APU RESULT WRITE TO REGFILE WHERE APU RESULT WRITE STALLS. APU LATENCY = 1\n        //*********************************************************************************************************\n\n        // cp_apu_contention = 1 cases\n        // cp_contention_state = 1 indicates that there was contention in WB at LSU-APU regfile wr mux\n\n        // cross coverage for F-instr following F-instr with fd to fs1 dependency\n        // case with APU latency = 1 and contention with LSU\n        cr_fd_fs1_eq_nonzero_lat_with_contention : cross cp_fd_fs1_eq,\n                                                         cp_id_stage_f_inst,\n                                                         cp_curr_fpu_inst_fd,\n                                                         cp_last_fpu_apu_op_at_contention,\n                                                         cp_contention_state,\n                                                         cp_apu_contention {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_fd_fs1_eq_nonzero_lat_with_contention with ((cp_fd_fs1_eq == 1) && (fpu_latency == 1));\n            ignore_bins skip_if_other_cfg = cr_fd_fs1_eq_nonzero_lat_with_contention with ((cp_fd_fs1_eq == 1) && (fpu_latency != 1));\n            `IGNORE_BINS_NON_FS1_F_INSTR\n            `IGNORE_BINS_NON_STALLED_CONTENTION_WR_STATE\n            `IGNORE_BINS_NON_FD_F_INSTR_AT_CONTENTION\n            `IGNORE_BINS_CONTENTION_AT_LSU_REGFILE_WR\n        }\n\n        // cross coverage for F-instr following F-instr with fd to fs2 dependency\n        // case with APU latency = 1 and contention with LSU\n        cr_fd_fs2_eq_nonzero_lat_with_contention : cross cp_fd_fs2_eq,\n                                                         cp_id_stage_f_inst,\n                                                         cp_curr_fpu_inst_fd,\n                                                         cp_last_fpu_apu_op_at_contention,\n                                                         cp_contention_state,\n                                                         cp_apu_contention {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_fd_fs2_eq_nonzero_lat_with_contention with ((cp_fd_fs2_eq == 1) && (fpu_latency == 1));\n            ignore_bins skip_if_other_cfg = cr_fd_fs2_eq_nonzero_lat_with_contention with ((cp_fd_fs2_eq == 1) && (fpu_latency != 1));\n            `IGNORE_BINS_NON_FS2_F_INSTR\n            `IGNORE_BINS_NON_STALLED_CONTENTION_WR_STATE\n            `IGNORE_BINS_NON_FD_F_INSTR_AT_CONTENTION\n            `IGNORE_BINS_CONTENTION_AT_LSU_REGFILE_WR\n        }\n\n        // cross coverage for F-instr following F-instr with fd to fs3 dependency\n        // case with APU latency = 1 and contention with LSU\n        cr_fd_fs3_eq_nonzero_lat_with_contention : cross cp_fd_fs3_eq,\n                                                         cp_id_stage_f_inst,\n                                                         cp_curr_fpu_inst_fd,\n                                                         cp_last_fpu_apu_op_at_contention,\n                                                         cp_contention_state,\n                                                         cp_apu_contention {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_fd_fs3_eq_nonzero_lat_with_contention with ((cp_fd_fs3_eq == 1) && (fpu_latency == 1));\n            ignore_bins skip_if_other_cfg = cr_fd_fs3_eq_nonzero_lat_with_contention with ((cp_fd_fs3_eq == 1) && (fpu_latency != 1));\n            `IGNORE_BINS_NON_FS3_F_INSTR\n            `IGNORE_BINS_NON_STALLED_CONTENTION_WR_STATE\n            `IGNORE_BINS_NON_FD_F_INSTR_AT_CONTENTION\n            `IGNORE_BINS_CONTENTION_AT_LSU_REGFILE_WR\n        }\n\n        // cross coverage for F-instr following F-instr with rd to rs1 dependency - 1 latency\n        // case with APU latency = 1 and contention with LSU\n        cr_rd_rs1_eq_nonzero_lat_with_contention : cross cp_rd_rs1_eq,\n                                                         cp_id_stage_f_inst,\n                                                         cp_curr_fpu_inst_rd,\n                                                         cp_last_fpu_apu_op_at_contention,\n                                                         cp_contention_state,\n                                                         cp_apu_contention {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_rd_rs1_eq_nonzero_lat_with_contention with ((cp_rd_rs1_eq == 1) && (fpu_latency == 1));\n            ignore_bins skip_if_other_cfg = cr_rd_rs1_eq_nonzero_lat_with_contention with ((cp_rd_rs1_eq == 1) && (fpu_latency != 1));\n            `IGNORE_BINS_NON_FS1_F_INSTR\n            `IGNORE_BINS_NON_STALLED_CONTENTION_WR_STATE\n            `IGNORE_BINS_CONTENTION_AT_LSU_REGFILE_WR\n            `IGNORE_BINS_NON_RD_F_INSTR_AT_CONTENTION\n        }\n\n        // cross coverage for Non F-instr following F-instr with rd to rs1 dependency\n        // case with APU latency = 1 and contention with LSU\n        cr_rv32f_rd_non_rv32fc_rs1_eq_nonzero_lat_with_contention : cross cp_rd_rs1_eq,\n                                                                          cp_id_stage_non_rv32fc_inst,\n                                                                          cp_curr_fpu_inst_rd,\n                                                                          cp_last_fpu_apu_op_at_contention,\n                                                                          cp_contention_state,\n                                                                          cp_apu_contention {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_rv32f_rd_non_rv32fc_rs1_eq_nonzero_lat_with_contention with ((cp_rd_rs1_eq == 1) && (fpu_latency == 1));\n            ignore_bins skip_if_other_cfg = cr_rv32f_rd_non_rv32fc_rs1_eq_nonzero_lat_with_contention with ((cp_rd_rs1_eq == 1) && (fpu_latency != 1));\n            `IGNORE_BINS_NON_RS1_CV32E40P_INSTR\n            `IGNORE_BINS_NON_STALLED_CONTENTION_WR_STATE\n            `IGNORE_BINS_CONTENTION_AT_LSU_REGFILE_WR\n            `IGNORE_BINS_NON_RD_F_INSTR_AT_CONTENTION\n        }\n\n        // cross coverage for Non F-instr following F-instr with rd to rs2 dependency\n        // case with APU latency = 1 and contention with LSU\n        cr_rv32f_rd_non_rv32fc_rs2_eq_nonzero_lat_with_contention : cross cp_rd_rs2_eq,\n                                                                          cp_id_stage_non_rv32fc_inst,\n                                                                          cp_curr_fpu_inst_rd,\n                                                                          cp_last_fpu_apu_op_at_contention,\n                                                                          cp_contention_state,\n                                                                          cp_apu_contention {\n\n            option.weight = 5;\n            bins main_cr_bin              = cr_rv32f_rd_non_rv32fc_rs2_eq_nonzero_lat_with_contention with ((cp_rd_rs2_eq == 1) && (fpu_latency == 1));\n            ignore_bins skip_if_other_cfg = cr_rv32f_rd_non_rv32fc_rs2_eq_nonzero_lat_with_contention with ((cp_rd_rs2_eq == 1) && (fpu_latency != 1));\n            `IGNORE_BINS_NON_RS2_CV32E40P_INSTR\n            `IGNORE_BINS_NON_STALLED_CONTENTION_WR_STATE\n            `IGNORE_BINS_CONTENTION_AT_LSU_REGFILE_WR\n            `IGNORE_BINS_NON_RD_F_INSTR_AT_CONTENTION\n        }\n\n        // TODO: does it require checking rd to rs1/rs2 equal in this case?\n        // cross coverage for contention case 1st cycle with LSU regfile write win\n        cr_waddr_rd_lsu_apu_wb_contention : cross cp_apu_busy,\n                                                  cp_apu_rvalid,\n                                                  cp_lsu_apu_contention_wr_rd,\n                                                  cp_apu_contention {\n\n            bins main_cr_bin              = cr_waddr_rd_lsu_apu_wb_contention with ((cp_apu_rvalid == 1) && (fpu_latency == 1));\n            ignore_bins skip_if_other_cfg = cr_waddr_rd_lsu_apu_wb_contention with ((cp_apu_rvalid == 1) && (fpu_latency != 1));\n            `IGNORE_BINS_NO_CONTENTION_LSU\n        }\n\n    endgroup : cg_f_inst_reg\n\nendclass : uvme_cv32e40p_fp_instr_covg\n\nfunction uvme_cv32e40p_fp_instr_covg::new(string name = \"cv32e40p_fp_instr_covg\", uvm_component parent = null);\n    super.new(name, parent);\n    void'(uvm_config_db#(uvme_cv32e40p_cfg_c)::get(this, \"\", \"cfg\", cfg));\n    if (cfg == null) begin\n      `uvm_fatal(\"cv32e40p_fp_instr_covg\", \"Configuration handle is null\")\n    end\n\n    cg_f_multicycle = new(.fpu_latency(cfg.fpu_latency));\n    cg_f_inst_reg = new(.fpu_latency(cfg.fpu_latency));\n\nendfunction : new\n\nfunction void uvme_cv32e40p_fp_instr_covg::build_phase(uvm_phase phase);\n    super.build_phase(phase);\n\n    void'(uvm_config_db#(uvme_cv32e40p_cntxt_c)::get(this, \"\", \"cntxt\", cntxt));\n    if (cntxt == null) begin\n        `uvm_fatal(\"cv32e40p_fp_instr_covg\", \"No cntxt object passed to model\");\n    end\nendfunction : build_phase\n\ntask uvme_cv32e40p_fp_instr_covg::run_phase(uvm_phase phase);\n    super.run_phase(phase);\n    `uvm_info(\"cv32e40p_fp_instr_covg\", \"The RV32_F coverage model is running\", UVM_LOW);\n    fork\n        sample_clk_i();\n    join_none\nendtask : run_phase\n\n\ntask uvme_cv32e40p_fp_instr_covg::sample_clk_i();\n    while (1) begin\n        @(`COVIF_CB);\n        if ((`COVIF_CB.debug_req_i == 0) && (`COVIF_CB.debug_mode_q == 0) &&\n            (`COVIF_CB.trigger_match_i == 0) && (cntxt.debug_cov_vif.mon_cb.dcsr_q[2] == 0)) begin // Only sample in M-mode without debug entry cases\n            cg_f_multicycle.sample();\n            cg_f_inst_reg.sample();\n        end\n    end\nendtask  : sample_clk_i\n","lang":"verilog"};
processSrcData(g_data);