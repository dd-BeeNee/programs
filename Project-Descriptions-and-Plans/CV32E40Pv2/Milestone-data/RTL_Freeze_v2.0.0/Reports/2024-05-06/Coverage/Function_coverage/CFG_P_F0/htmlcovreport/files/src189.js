var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/env/uvme/cov/uvme_debug_covg.sv","src":"///////////////////////////////////////////////////////////////////////////////\n// Copyright 2020 OpenHW Group\n// Copyright 2020 BTA Design Services\n// Copyright 2020 Silicon Labs, Inc.\n// Copyright 2023 Dolphin Design\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://solderpad.org/licenses/\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n//\n///////////////////////////////////////////////////////////////////////////////\n\n\nclass uvme_debug_covg extends uvm_component;\n\n    /*\n    * Class members\n    */\n    uvme_cv32e40p_cntxt_c  cntxt;\n\n\n    `uvm_component_utils(uvme_debug_covg);\n\n    extern function new(string name = \"debug_covg\", uvm_component parent = null);\n    extern function void build_phase(uvm_phase phase);\n    extern task run_phase(uvm_phase phase);\n\n    extern task sample_clk_i();\n    extern task sample_debug_req_i();\n\n    /*\n    * Covergroups\n    */\n\n  covergroup cg_debug_mode_ext ;\n          `per_instance_fcov\n          state: coverpoint cntxt.debug_cov_vif.mon_cb.ctrl_fsm_cs{\n              ignore_bins ignore_pulp_states = {cv32e40p_pkg::ELW_EXE, cv32e40p_pkg::IRQ_FLUSH_ELW, cv32e40p_pkg::DECODE_HWLOOP};\n          }\n  endgroup : cg_debug_mode_ext\n\n  // Waive duplicate code since embedded covergroups are used\n  //@DVT_LINTER_WAIVER_START \"SR20211012_1\" disable SVTB.33.1.0\n\n  // Cover that we execute ebreak with dcsr.ebreakm==1\n  covergroup cg_ebreak_execute_with_ebreakm;\n          `per_instance_fcov\n          ex: coverpoint cntxt.debug_cov_vif.mon_cb.is_ebreak {\n                  bins active = {1};\n          }\n          ebreakm_set: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[15] {\n                  bins active = {1};\n          }\n          dm : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n                  bins active = {1};\n          }\n          ebreak_with_ebreakm: cross ex, ebreakm_set;\n          ebreak_in_debug : cross ex, dm;\n  endgroup\n\n  // Cover that we execute c.ebreak with dcsr.ebreakm==1\n  covergroup cg_cebreak_execute_with_ebreakm;\n          `per_instance_fcov\n          ex: coverpoint cntxt.debug_cov_vif.mon_cb.is_cebreak {\n                  bins active = {1};\n          }\n          ebreakm_set: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[15] {\n                  bins active = {1};\n          }\n          dm : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n                  bins active = {1};\n          }\n          cebreak_with_ebreakm: cross ex, ebreakm_set;\n          cebreak_in_debug : cross ex, dm;\n  endgroup\n\n  // Cover that we execute ebreak with dcsr.ebreakm==0\n  covergroup cg_ebreak_execute_without_ebreakm;\n          `per_instance_fcov\n          ex: coverpoint cntxt.debug_cov_vif.mon_cb.is_ebreak {\n                  bins active = {1};\n          }\n          ebreakm_clear: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[15] {\n                  bins active = {0};\n          }\n          step: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[2] {\n                  bins active = {1};\n          }\n          nostep: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[2] {\n                  bins active = {0};\n          }\n          ebreak_regular_nodebug: cross ex, ebreakm_clear, nostep;\n          ebreak_step_nodebug : cross ex, ebreakm_clear, step;\n  endgroup\n\n  // Cover that we execute c.ebreak with dcsr.ebreakm==0\n  covergroup cg_cebreak_execute_without_ebreakm;\n          `per_instance_fcov\n          ex: coverpoint cntxt.debug_cov_vif.mon_cb.is_cebreak {\n                  bins active = {1};\n          }\n          ebreakm_clear: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[15] {\n                  bins active = {0};\n          }\n          step: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[2] {\n                  bins active = {1};\n          }\n          nostep: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[2] {\n                  bins active = {0};\n          }\n          cebreak_regular_nodebug: cross ex, ebreakm_clear, nostep;\n          cebreak_step_nodebug : cross ex, ebreakm_clear, step;\n  endgroup\n  //@DVT_LINTER_WAIVER_END \"SR20211012_1\"\n\n    // Cover that we hit a trigger match\n    covergroup cg_trigger_match;\n        `per_instance_fcov\n        en : coverpoint cntxt.debug_cov_vif.mon_cb.tdata1[2] {\n            bins active = {1};\n        }\n        match: coverpoint cntxt.debug_cov_vif.mon_cb.trigger_match_i {\n            bins hit = {1};\n        }\n        ok_match: cross en, match;\n    endgroup\n\n    // cover that we hit pc==tdata2  without having enabled trigger in m/d-mode\n    // cover hit in d-mode with trigger enabled (no action)\n    covergroup cg_trigger_match_disabled;\n        `per_instance_fcov\n        dis : coverpoint cntxt.debug_cov_vif.mon_cb.tdata1[2] {\n            bins hit = {0};\n        }\n        en : coverpoint cntxt.debug_cov_vif.mon_cb.tdata1[2] {\n            bins hit = {1};\n        }\n        match: coverpoint cntxt.debug_cov_vif.mon_cb.addr_match {\n           bins hit = {1};\n        }\n        mmode : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n           bins m = {0};\n        }\n        dmode : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n           bins m = {1};\n        }\n        m_match_without_en : cross dis, match, mmode;\n        d_match_without_en : cross dis, match, dmode;\n        d_match_with_en    : cross en, match, dmode;\n    endgroup\n\n    // Cover that we hit an exception during debug mode\n    covergroup cg_debug_mode_exception;\n        `per_instance_fcov\n        dm : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins hit  = {1};\n        }\n        ill : coverpoint cntxt.debug_cov_vif.mon_cb.illegal_insn_q {\n            bins hit = {1};\n        }\n        ex_in_debug : cross dm, ill;\n    endgroup\n\n    // Cover that we hit an ecall during debug mode\n    covergroup cg_debug_mode_ecall;\n        `per_instance_fcov\n        dm : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins hit  = {1};\n        }\n        ill : coverpoint cntxt.debug_cov_vif.mon_cb.ecall_insn_i {\n            bins hit = {1};\n        }\n        ex_in_debug : cross dm, ill;\n    endgroup\n\n    // Cover that we get interrupts while in debug mode\n    covergroup cg_irq_in_debug;\n        `per_instance_fcov\n        dm : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins hit  = {1};\n        }\n        irq : coverpoint |cntxt.debug_cov_vif.mon_cb.irq_i {\n            bins hit = {1};\n        }\n        ex_in_debug : cross dm, irq;\n    endgroup\n\n    // Cover that hit a WFI insn in debug mode\n    covergroup cg_wfi_in_debug;\n        `per_instance_fcov\n        iswfi : coverpoint cntxt.debug_cov_vif.mon_cb.is_wfi {\n                bins hit  = {1};\n        }\n        dm : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins hit = {1};\n        }\n        dm_wfi : cross iswfi, dm;\n    endgroup\n\n    // Cover that we get a debug_req while in wfi\n    covergroup cg_wfi_debug_req;\n        `per_instance_fcov\n        inwfi : coverpoint cntxt.debug_cov_vif.mon_cb.in_wfi {\n                bins hit  = {1};\n        }\n        dreq: coverpoint cntxt.debug_cov_vif.mon_cb.debug_req_i {\n            bins hit = {1};\n        }\n        dm_wfi : cross inwfi, dreq;\n    endgroup\n\n    // Cover that we perform single stepping\n    covergroup cg_single_step;\n        `per_instance_fcov\n        step : coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[2] {\n                bins en  = {1};\n        }\n        mmode: coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins hit = {0};\n        }\n        trigger : coverpoint cntxt.debug_cov_vif.mon_cb.trigger_match_i {\n            bins hit = {1};\n        }\n        wfi : coverpoint cntxt.debug_cov_vif.mon_cb.is_wfi {\n            bins hit = {1};\n        }\n        ill : coverpoint cntxt.debug_cov_vif.mon_cb.illegal_insn_i {\n            bins hit = {1};\n        }\n        pc_will_trig : coverpoint cntxt.debug_cov_vif.mon_cb.dpc_will_hit {\n            bins hit = {1};\n        }\n        stepie : coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[11];\n        mmode_step : cross step, mmode;\n        mmode_step_trigger_match : cross step, mmode, trigger;\n        mmode_step_wfi : cross step, mmode, wfi;\n        mmode_step_stepie : cross step, mmode, stepie;\n        mmode_step_illegal : cross step, mmode, ill;\n        mmode_step_next_pc_will_match : cross step, mmode, pc_will_trig;\n    endgroup\n\n    // Cover dret is executed in machine mode\n    covergroup cg_mmode_dret;\n        `per_instance_fcov\n        mmode : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q;\n        dret_ins : coverpoint cntxt.debug_cov_vif.mon_cb.is_dret {\n            bins hit = {1};\n        }\n        dret_ex : cross mmode, dret_ins;\n    endgroup\n\n    // Cover debug_req and irq asserted on same cycle\n    covergroup cg_irq_dreq;\n        `per_instance_fcov\n        dreq : coverpoint cntxt.debug_cov_vif.mon_cb.debug_req_i {\n                bins trans_active  = (1'b0 => 1'b1);\n        }\n        irq  : coverpoint |cntxt.debug_cov_vif.mon_cb.irq_i {\n                bins trans_active = (1'b0 => 1'b1);\n        }\n        trigger : coverpoint cntxt.debug_cov_vif.mon_cb.trigger_match_i {\n            bins hit = {1};\n        }\n        ill : coverpoint cntxt.debug_cov_vif.mon_cb.illegal_insn_i {\n            bins hit = {1};\n        }\n        ebreak : coverpoint cntxt.debug_cov_vif.mon_cb.is_ebreak {\n            bins active= {1'b1};\n        }\n        cebreak : coverpoint cntxt.debug_cov_vif.mon_cb.is_cebreak {\n            bins active= {1'b1};\n        }\n        branch : coverpoint cntxt.debug_cov_vif.mon_cb.branch_in_decode {\n            bins active= {1'b1};\n        }\n        mulhsu : coverpoint cntxt.debug_cov_vif.mon_cb.is_mulhsu {\n            bins active= {1'b1};\n        }\n        dreq_and_ill : cross dreq, ill;\n        irq_and_dreq : cross dreq, irq;\n        irq_dreq_trig_ill : cross dreq, irq, trigger, ill; // irq + haltreq + trigger (illegal)\n        irq_dreq_trig_cebreak : cross dreq, irq, trigger, cebreak; // irq + haltreq + trigger (cbreak)\n        irq_dreq_trig_ebreak : cross dreq, irq, trigger, ebreak; // irq + haltreq + trigger (ebreak)\n        irq_dreq_trig_branch : cross dreq, irq, trigger, branch; // irq + haltreq + trigger (branch)\n        irq_dreq_trig_multicycle : cross dreq, irq, trigger, mulhsu; // irq + haltreq + trigger (mc)\n    endgroup\n\n    // Cover access to dcsr, dpc and dscratch0/1 in D-mode\n    covergroup cg_debug_regs_d_mode;\n        `per_instance_fcov\n        mode : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins M = {1};\n        }\n\n        access : coverpoint cntxt.debug_cov_vif.mon_cb.csr_access {\n            bins hit = {1};\n        }\n        op : coverpoint cntxt.debug_cov_vif.mon_cb.csr_op {\n            bins read = {'h0};\n            bins write = {'h1};\n        }\n        addr  : coverpoint cntxt.debug_cov_vif.mon_cb.id_stage_instr_rdata_i[31:20] { // csr addr not updated if illegal access\n            bins dcsr = {'h7B0};\n            bins dpc = {'h7B1};\n            bins dscratch0 = {'h7B2};\n            bins dscratch1 = {'h7B3};\n        }\n        dregs_access : cross mode, access, op, addr;\n    endgroup\n\n    // Cover access to dcsr, dpc and dscratch0/1 in M-mode\n    covergroup cg_debug_regs_m_mode;\n        `per_instance_fcov\n        mode : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins M = {0};\n        }\n\n        access : coverpoint cntxt.debug_cov_vif.mon_cb.csr_access {\n            bins hit = {1};\n        }\n        op : coverpoint cntxt.debug_cov_vif.mon_cb.csr_op_dec {\n            bins read = {1'h0};\n            bins write = {1'h1};\n        }\n        addr  : coverpoint cntxt.debug_cov_vif.mon_cb.id_stage_instr_rdata_i[31:20] { // csr addr not updated if illegal access\n            bins dcsr = {'h7B0};\n            bins dpc = {'h7B1};\n            bins dscratch0 = {'h7B2};\n            bins dscratch1 = {'h7B3};\n        }\n        dregs_access : cross mode, access, op, addr;\n    endgroup\n    // Cover access to trigger registers\n    // Do we need to cover all READ/WRITE/SET/CLEAR from m-mode?\n    covergroup cg_trigger_regs;\n        `per_instance_fcov\n        mode : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q; // Only M and D supported\n        access : coverpoint cntxt.debug_cov_vif.mon_cb.csr_access {\n            bins hit = {1};\n        }\n        op : coverpoint cntxt.debug_cov_vif.mon_cb.csr_op {\n            bins read = {'h0};\n            bins write = {'h1};\n        }\n        addr  : coverpoint cntxt.debug_cov_vif.mon_cb.id_stage_instr_rdata_i[31:20]{ // csr addr not updated if illegal access\n            bins tsel = {'h7A0};\n            bins tdata1 = {'h7A1};\n            bins tdata2 = {'h7A2};\n            bins tdata3 = {'h7A3};\n            bins tinfo  = {'h7A4};\n        }\n        tregs_access : cross mode, access, op, addr;\n    endgroup\n\n    // Cover that we run with counters mcycle and minstret enabled\n    covergroup cg_counters_enabled;\n        `per_instance_fcov\n        mcycle_en : coverpoint cntxt.debug_cov_vif.mon_cb.mcountinhibit_q[0];\n        minstret_en : coverpoint cntxt.debug_cov_vif.mon_cb.mcountinhibit_q[2];\n    endgroup\n\n    // Cover that we get a debug_req_i while in RESET state\n    covergroup cg_debug_at_reset;\n        `per_instance_fcov\n        state : coverpoint cntxt.debug_cov_vif.mon_cb.ctrl_fsm_cs {\n            bins reset= {cv32e40p_pkg::RESET};\n        }\n         dbg : coverpoint cntxt.debug_cov_vif.mon_cb.debug_req_i {\n            bins active= {1'b1};\n        }\n        dbg_at_reset : cross state, dbg;\n    endgroup\n\n    // Cover that we execute fence and fence.i in debug mode\n    covergroup cg_fence_in_debug;\n        `per_instance_fcov\n        mode : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins debug= {1'b1};\n        }\n        fence : coverpoint cntxt.debug_cov_vif.mon_cb.fence_i {\n            bins active= {1'b1};\n        }\n        fence_in_debug : cross mode, fence;\n    endgroup\n\n    // Cover that we get all combinations of debug causes\n    covergroup cg_debug_causes;\n        `per_instance_fcov\n        tmatch : coverpoint cntxt.debug_cov_vif.mon_cb.trigger_match_i {\n            bins match= {1'b1};\n        }\n        tnomatch : coverpoint cntxt.debug_cov_vif.mon_cb.trigger_match_i {\n            bins nomatch= {1'b0};\n        }\n         ebreak : coverpoint cntxt.debug_cov_vif.mon_cb.is_ebreak {\n            bins active= {1'b1};\n        }\n         cebreak : coverpoint cntxt.debug_cov_vif.mon_cb.is_cebreak {\n            bins active= {1'b1};\n        }\n         dbg_req : coverpoint cntxt.debug_cov_vif.mon_cb.debug_req_i {\n            bins active= {1'b1};\n        }\n         step : coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[2] & !cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins active= {1'b1};\n        }\n        trig_vs_ebreak : cross tmatch, ebreak;\n        trig_vs_cebreak : cross tmatch, cebreak;\n        trig_vs_dbg_req : cross tmatch, dbg_req;\n        trig_vs_step : cross tmatch, step;\n        // Excluding trigger match to check 'lower' priority causes\n        ebreak_vs_req : cross ebreak, dbg_req, tnomatch;\n        cebreak_vs_req : cross cebreak, dbg_req, tnomatch;\n        ebreak_vs_step : cross ebreak, step;\n        cebreak_cs_step : cross cebreak, step;\n        dbg_req_vs_step : cross dbg_req, step;\n    endgroup\n\n    covergroup cg_debug_with_rv32f_inst;\n        `per_instance_fcov\n\n        cp_dbg_req : coverpoint cntxt.debug_cov_vif.mon_cb.debug_req_i & !cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins dbg_req_active = {1'b1};\n            bins dbg_req_0_to_1 = (0 => 1);\n        }\n\n        cp_step : coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[2] & !cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins dbg_step_mode_set = {1'b1};\n            bins dbg_step_mode_not_set = {1'b0};\n        }\n\n        cp_ebreak: coverpoint cntxt.debug_cov_vif.mon_cb.is_ebreak {\n                bins ebreak_ex = {1};\n        }\n\n        cp_cebreak : coverpoint cntxt.debug_cov_vif.mon_cb.is_cebreak {\n            bins cebreak_ex= {1'b1};\n        }\n\n        cp_ebreakm_set: coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[15] {\n                bins ebreakm_is_set = {1};\n        }\n\n        cp_trigger_match : coverpoint cntxt.debug_cov_vif.mon_cb.trigger_match_i {\n            bins not_match = {0};\n            bins match = {1};\n        }\n\n        cp_trigger_en : coverpoint cntxt.debug_cov_vif.mon_cb.tdata1[2] {\n            bins trig_en = {1};\n        }\n\n        cp_dm : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n                bins in_debug_mode = {1};\n        }\n\n        cp_irq  : coverpoint (cntxt.debug_cov_vif.mon_cb.irq_i & cntxt.debug_cov_vif.mon_cb.mie_q) {\n                wildcard bins irq_31_trans_0_to_1    =   ( {1'b0,31'b?}                 =>  {1'b1,31'b?} );\n                wildcard bins irq_30_trans_0_to_1    =   ( {1'b0,1'b0,30'b?}            =>  {1'b0,1'b1,30'b?} );\n                wildcard bins irq_29_trans_0_to_1    =   ( {2'b0,1'b0,29'b?}            =>  {2'b0,1'b1,29'b?} );\n                wildcard bins irq_28_trans_0_to_1    =   ( {3'b0,1'b0,28'b?}            =>  {3'b0,1'b1,28'b?} );\n                wildcard bins irq_27_trans_0_to_1    =   ( {4'b0,1'b0,27'b?}            =>  {4'b0,1'b1,27'b?} );\n                wildcard bins irq_26_trans_0_to_1    =   ( {5'b0,1'b0,26'b?}            =>  {5'b0,1'b1,26'b?} );\n                wildcard bins irq_25_trans_0_to_1    =   ( {6'b0,1'b0,25'b?}            =>  {6'b0,1'b1,25'b?} );\n                wildcard bins irq_24_trans_0_to_1    =   ( {7'b0,1'b0,24'b?}            =>  {7'b0,1'b1,24'b?} );\n                wildcard bins irq_23_trans_0_to_1    =   ( {8'b0,1'b0,23'b?}            =>  {8'b0,1'b1,23'b?} );\n                wildcard bins irq_22_trans_0_to_1    =   ( {9'b0,1'b0,22'b?}            =>  {9'b0,1'b1,22'b?} );\n                wildcard bins irq_21_trans_0_to_1    =   ( {10'b0,1'b0,21'b?}           =>  {10'b0,1'b1,21'b?} );\n                wildcard bins irq_20_trans_0_to_1    =   ( {11'b0,1'b0,20'b?}           =>  {11'b0,1'b1,20'b?} );\n                wildcard bins irq_19_trans_0_to_1    =   ( {12'b0,1'b0,19'b?}           =>  {12'b0,1'b1,19'b?} );\n                wildcard bins irq_18_trans_0_to_1    =   ( {13'b0,1'b0,18'b?}           =>  {13'b0,1'b1,18'b?} );\n                wildcard bins irq_17_trans_0_to_1    =   ( {14'b0,1'b0,17'b?}           =>  {14'b0,1'b1,17'b?} );\n                wildcard bins irq_16_trans_0_to_1    =   ( {15'b0,1'b0,16'b?}           =>  {15'b0,1'b1,16'b?} );\n                wildcard bins irq_11_trans_0_to_1    =   ( {20'b0,1'b0,11'b?}           =>  {20'b0,1'b1,11'b?} );\n                wildcard bins irq_3_trans_0_to_1     =   ( {24'b0,1'b0,3'b?,1'b0,3'b?}  =>  {24'b0,1'b?,3'b?,1'b1,3'b?} );\n                wildcard bins irq_7_trans_0_to_1     =   ( {24'b0,1'b0,3'b?,1'b0,3'b?}  =>  {24'b0,1'b1,3'b?,1'b0,3'b?} );\n        }\n\n        cp_ill : coverpoint cntxt.debug_cov_vif.mon_cb.illegal_insn_i {\n            bins ill_inst_hit = {1};\n        }\n\n        cp_rv32f_inst : coverpoint cntxt.debug_cov_vif.mon_cb.id_stage_instr_rdata_i iff (cntxt.debug_cov_vif.mon_cb.id_stage_instr_valid_i == 1) {\n            `RV32F_INSTR_BINS\n        }\n\n        cp_apu_req_valid : coverpoint cntxt.debug_cov_vif.mon_cb.apu_req {\n            bins apu_req_valid = {1'b1};\n        }\n\n        cp_apu_grant_valid : coverpoint cntxt.debug_cov_vif.mon_cb.apu_gnt {\n            bins apu_gnt_valid[] = {1'b1};\n        }\n\n        cp_apu_busy : coverpoint cntxt.debug_cov_vif.mon_cb.apu_busy {\n            bins apu_busy[] = {1'b0, 1'b1};\n            bins apu_busy_0_to_1 = (0 => 1);\n            bins apu_busy_1_to_0 = (1 => 0);\n        }\n\n        // cross rv32f instr execution at debug req only - no trigger\n        cr_dbg_x_rv32f : cross cp_dbg_req, cp_rv32f_inst, cp_trigger_match {\n            ignore_bins no_trigger_match = binsof(cp_trigger_match) intersect {1};\n        }\n\n        // cross debug single stepping for each rv32f instr - no trigger\n        cr_step_x_rv32f : cross cp_step, cp_rv32f_inst, cp_trigger_match {\n            ignore_bins single_step_disable = binsof(cp_step) intersect {0};\n            ignore_bins no_trigger_match = binsof(cp_trigger_match) intersect {1};\n        }\n\n        // cross debug entry with trigger addr match at rv32f inst\n        cr_trigger_with_rv32f : cross cp_trigger_match, cp_trigger_en, cp_rv32f_inst;\n\n        cr_rv32f_in_dbg_mode : cross cp_dm, cp_rv32f_inst;\n\n        // debug mode entry with debug_halt_req during multi cycle fp inst\n        cr_dbg_while_multi_cyc_f_A : cross cp_apu_req_valid, cp_apu_grant_valid, cp_dbg_req;\n        cr_dbg_while_multi_cyc_f_B : cross cp_apu_busy, cp_dbg_req;\n\n        // debug_halt_req with irq during multi cycle fp inst\n        cr_dbg_irq_while_multi_cyc_f_A : cross cp_apu_req_valid, cp_apu_grant_valid, cp_dbg_req, cp_irq {\n          bins irq_grp_upper16_multi_cyc_f_A = binsof(cp_dbg_req.dbg_req_active) && binsof(cp_apu_grant_valid) && (\n                                 binsof(cp_irq.irq_31_trans_0_to_1) || binsof(cp_irq.irq_30_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_29_trans_0_to_1) || binsof(cp_irq.irq_28_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_27_trans_0_to_1) || binsof(cp_irq.irq_26_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_25_trans_0_to_1) || binsof(cp_irq.irq_24_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_23_trans_0_to_1) || binsof(cp_irq.irq_22_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_21_trans_0_to_1) || binsof(cp_irq.irq_20_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_19_trans_0_to_1) || binsof(cp_irq.irq_18_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_17_trans_0_to_1) || binsof(cp_irq.irq_16_trans_0_to_1));\n          bins irq_grp_lower16_multi_cyc_f_A = binsof(cp_dbg_req.dbg_req_active) && binsof(cp_apu_grant_valid) && (\n                                 binsof(cp_irq.irq_11_trans_0_to_1) || \n                                 binsof(cp_irq.irq_3_trans_0_to_1)  ||\n                                 binsof(cp_irq.irq_7_trans_0_to_1));\n          ignore_bins dbg_req_others = binsof(cp_dbg_req.dbg_req_0_to_1);\n        }\n        cr_dbg_irq_while_multi_cyc_f_B : cross cp_apu_busy, cp_dbg_req, cp_irq {\n          bins irq_grp_upper16_multi_cyc_f_B = binsof(cp_dbg_req.dbg_req_active) && (binsof(cp_apu_busy.apu_busy) intersect {1}) && (\n                                 binsof(cp_irq.irq_31_trans_0_to_1) || binsof(cp_irq.irq_30_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_29_trans_0_to_1) || binsof(cp_irq.irq_28_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_27_trans_0_to_1) || binsof(cp_irq.irq_26_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_25_trans_0_to_1) || binsof(cp_irq.irq_24_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_23_trans_0_to_1) || binsof(cp_irq.irq_22_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_21_trans_0_to_1) || binsof(cp_irq.irq_20_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_19_trans_0_to_1) || binsof(cp_irq.irq_18_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_17_trans_0_to_1) || binsof(cp_irq.irq_16_trans_0_to_1));\n          bins irq_grp_lower16_multi_cyc_f_B = binsof(cp_dbg_req.dbg_req_active) && (binsof(cp_apu_busy.apu_busy) intersect {1}) && (\n                                 binsof(cp_irq.irq_11_trans_0_to_1) || \n                                 binsof(cp_irq.irq_3_trans_0_to_1) ||\n                                 binsof(cp_irq.irq_7_trans_0_to_1));\n          ignore_bins dbg_apu_busy_others = (binsof(cp_apu_busy.apu_busy) intersect {0}) || binsof(cp_apu_busy.apu_busy_0_to_1) || binsof(cp_apu_busy.apu_busy_1_to_0);\n          ignore_bins dbg_req_others = binsof(cp_dbg_req.dbg_req_0_to_1);\n        }\n\n        // debug_halt_req with illegal instr during multi cycle fp inst\n        cr_dbg_ill_while_multi_cyc_f_A : cross cp_apu_req_valid, cp_apu_grant_valid, cp_dbg_req, cp_ill;\n        cr_dbg_ill_while_multi_cyc_f_B : cross cp_apu_busy, cp_dbg_req, cp_ill;\n\n        // debug mode entry with ebreak during multi cycle fp inst\n        cr_ebreak_while_multi_cyc_f_A : cross cp_apu_req_valid, cp_apu_grant_valid, cp_ebreak, cp_ebreakm_set;\n        cr_ebreak_while_multi_cyc_f_B : cross cp_apu_busy, cp_ebreak, cp_ebreakm_set;\n\n        // debug mode entry with cebreak during multi cycle fp inst\n        cr_cebreak_while_multi_cyc_f_A : cross cp_apu_req_valid, cp_apu_grant_valid, cp_cebreak, cp_ebreakm_set;\n        cr_cebreak_while_multi_cyc_f_B : cross cp_apu_busy, cp_cebreak, cp_ebreakm_set;\n\n        // debug mode entry with trigger during multi cycle fp inst\n        cr_dbg_trig_while_multi_cyc_f_A : cross cp_apu_req_valid, cp_apu_grant_valid, cp_trigger_match, cp_trigger_en;\n        cr_dbg_trig_while_multi_cyc_f_B : cross cp_apu_busy, cp_trigger_match, cp_trigger_en;\n\n    endgroup\n\n    covergroup cg_debug_with_xpulp_inst;\n        `per_instance_fcov\n\n        cp_dbg_req : coverpoint cntxt.debug_cov_vif.mon_cb.debug_req_i & !cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins dbg_req_active = {1'b1};\n            bins dbg_req_0_to_1 = (0 => 1);\n        }\n\n        cp_step : coverpoint cntxt.debug_cov_vif.mon_cb.dcsr_q[2] & !cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n            bins dbg_step_mode_set = {1'b1};\n            bins dbg_step_mode_not_set = {1'b0};\n        }\n\n        cp_trigger_match : coverpoint cntxt.debug_cov_vif.mon_cb.trigger_match_i {\n            bins not_match = {0};\n            bins match = {1};\n        }\n\n        cp_trigger_en : coverpoint cntxt.debug_cov_vif.mon_cb.tdata1[2] {\n            bins trig_en = {1};\n        }\n\n        cp_dm : coverpoint cntxt.debug_cov_vif.mon_cb.debug_mode_q {\n                bins in_debug_mode = {1};\n        }\n\n        cp_xpulp_instr : coverpoint cntxt.debug_cov_vif.mon_cb.id_stage_instr_rdata_i iff (cntxt.debug_cov_vif.mon_cb.id_stage_instr_valid_i == 1) {\n            `RV32X_PULP_INSTR_BINS\n        }\n\n        // cross xpulp instr while in debug mode\n        cr_xpulp_instructions_in_dbg_mode : cross cp_dm, cp_xpulp_instr;\n\n        // cross xpulp instr execution at debug req only - no trigger\n        cr_dbg_req_at_xpulp_instr : cross cp_dbg_req, cp_xpulp_instr, cp_trigger_match {\n            ignore_bins no_trigger_match = binsof(cp_trigger_match) intersect {1};\n        }\n\n        // cross debug single stepping for each xpulp instr - no trigger\n        cr_dbg_single_step_xpulp_instr : cross cp_step, cp_xpulp_instr, cp_trigger_match {\n            ignore_bins single_step_disable = binsof(cp_step) intersect {0};\n            ignore_bins no_trigger_match = binsof(cp_trigger_match) intersect {1};\n        }\n\n        // cross debug entry with trigger addr match at xpulp inst\n        cr_trigger_with_xpulp_instr : cross cp_trigger_match, cp_trigger_en, cp_xpulp_instr;\n\n    endgroup\n\nendclass : uvme_debug_covg\n\nfunction uvme_debug_covg::new(string name = \"debug_covg\", uvm_component parent = null);\n    super.new(name, parent);\n\n    cg_debug_mode_ext = new();\n    cg_ebreak_execute_with_ebreakm = new();\n    cg_cebreak_execute_with_ebreakm = new();\n    cg_ebreak_execute_without_ebreakm = new();\n    cg_cebreak_execute_without_ebreakm = new();\n    cg_trigger_match = new();\n    cg_trigger_match_disabled = new();\n    cg_debug_mode_exception = new();\n    cg_debug_mode_ecall = new();\n    cg_irq_in_debug = new();\n    cg_wfi_in_debug = new();\n    cg_wfi_debug_req = new();\n    cg_single_step = new();\n    cg_mmode_dret = new();\n    cg_irq_dreq = new();\n    cg_debug_regs_d_mode = new();\n    cg_debug_regs_m_mode = new();\n    cg_trigger_regs = new();\n    cg_counters_enabled = new();\n    cg_debug_at_reset = new();\n    cg_fence_in_debug = new();\n    cg_debug_causes = new();\n    cg_debug_with_rv32f_inst = new();\n    cg_debug_with_xpulp_inst = new();\nendfunction : new\n\nfunction void uvme_debug_covg::build_phase(uvm_phase phase);\n    super.build_phase(phase);\n\n    void'(uvm_config_db#(uvme_cv32e40p_cntxt_c)::get(this, \"\", \"cntxt\", cntxt));\n    if (cntxt == null) begin\n        `uvm_fatal(\"DEBUGCOVG\", \"No cntxt object passed to model\");\n    end\nendfunction : build_phase\n\ntask uvme_debug_covg::run_phase(uvm_phase phase);\n    super.run_phase(phase);\n\n    `uvm_info(\"DEBUGCOVG\", \"The debug coverage model is running\", UVM_LOW);\n\n    fork\n        sample_debug_req_i();\n        sample_clk_i();\n    join_none\nendtask : run_phase\n\ntask uvme_debug_covg::sample_debug_req_i();\n  while(1) begin\n    @(posedge cntxt.debug_cov_vif.mon_cb.debug_req_i);\n\n    cg_debug_mode_ext.sample();\n  end\nendtask : sample_debug_req_i\n\ntask uvme_debug_covg::sample_clk_i();\n  while (1) begin\n    @(cntxt.debug_cov_vif.mon_cb);\n\n    cg_ebreak_execute_with_ebreakm.sample();\n    cg_cebreak_execute_with_ebreakm.sample();\n    cg_ebreak_execute_without_ebreakm.sample();\n    cg_cebreak_execute_without_ebreakm.sample();\n    cg_trigger_match.sample();\n    cg_trigger_match_disabled.sample();\n    cg_debug_mode_exception.sample();\n    cg_debug_mode_ecall.sample();\n    cg_irq_in_debug.sample();\n    cg_wfi_in_debug.sample();\n    cg_wfi_debug_req.sample();\n    cg_single_step.sample();\n    cg_mmode_dret.sample();\n    cg_irq_dreq.sample();\n    cg_debug_regs_d_mode.sample();\n    cg_debug_regs_m_mode.sample();\n    cg_trigger_regs.sample();\n    cg_counters_enabled.sample();\n    cg_debug_at_reset.sample();\n    cg_fence_in_debug.sample();\n    cg_debug_causes.sample();\n    cg_debug_with_rv32f_inst.sample();\n    cg_debug_with_xpulp_inst.sample();\n  end\nendtask  : sample_clk_i\n","lang":"verilog"};
processSrcData(g_data);