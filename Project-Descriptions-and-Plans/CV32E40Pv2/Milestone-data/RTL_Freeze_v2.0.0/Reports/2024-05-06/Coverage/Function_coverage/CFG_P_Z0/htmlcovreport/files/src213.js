var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/tb/uvmt/../../tests/uvmt/compliance-tests/uvmt_cv32e40p_firmware_test.sv","src":"//\n// Copyright 2020 OpenHW Group\n// Copyright 2020 Datum Technology Corporation\n// Copyright 2020 Silicon Labs, Inc.\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://solderpad.org/licenses/\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1\n\n\n`ifndef __UVMT_CV32E40P_FIRMWARE_TEST_SV__\n`define __UVMT_CV32E40P_FIRMWARE_TEST_SV__\n\n\n/**\n *  CV32E40PE40P \"firmware\" test.\n *  This class relies on a pre-existing \"firmware\" file written in C and/or\n *  RISC-V assembly code.  This class will invoke the riscv-gcc-toolchain to\n *  translate the firmware into a \"hexfile\" that is read into the CV32E40PE40P\n *  instruction memory in the testbench module.\n *\n *  This class doesn't care what the firmware does, it mearly compiles it.\n *\n */\nclass uvmt_cv32e40p_firmware_test_c extends uvmt_cv32e40p_base_test_c;\n\n   bit disable_all_trn_logs;\n\n   constraint env_cfg_cons {\n      env_cfg.enabled         == 1;\n      env_cfg.is_active       == UVM_ACTIVE;\n      if (disable_all_trn_logs) {\n       env_cfg.trn_log_enabled                       == 0;\n       env_cfg.clknrst_cfg.trn_log_enabled           == 0;\n       env_cfg.interrupt_cfg.trn_log_enabled         == 0;\n       env_cfg.debug_cfg.trn_log_enabled             == 0;\n       env_cfg.obi_memory_instr_cfg.trn_log_enabled  == 0;\n       env_cfg.obi_memory_data_cfg.trn_log_enabled   == 0;\n       env_cfg.rvfi_cfg.trn_log_enabled              == 0;\n      } else {\n       env_cfg.trn_log_enabled == 1;\n      }\n   }\n   `uvm_component_utils_begin(uvmt_cv32e40p_firmware_test_c)\n   `uvm_object_utils_end\n\n   constraint test_type_cons {\n     test_cfg.tpt == PREEXISTING_SELFCHECKING;\n   }\n\n   /**\n    */\n   extern function new(string name=\"uvmt_cv32e40p_firmware_test\", uvm_component parent=null);\n\n   /**\n    * Runs reset_vseq.\n    */\n   extern virtual task reset_phase(uvm_phase phase);\n\n   /**\n    * Loads the test program (the \"firmware\") into memory.\n    */\n   extern virtual task configure_phase(uvm_phase phase);\n\n   /**\n    *  Enable program execution, wait for completion.\n    */\n   extern virtual task run_phase(uvm_phase phase);\n\n   /**\n   * Start random debug sequencer\n   */\n    extern virtual task random_debug();\n\n    extern virtual task reset_debug();\n\n    extern virtual task bootset_debug();\n   /**\n    *  Start the interrupt sequencer to apply random interrupts during test\n    */\n   extern virtual task irq_noise();\n\nendclass : uvmt_cv32e40p_firmware_test_c\n\n\nfunction uvmt_cv32e40p_firmware_test_c::new(string name=\"uvmt_cv32e40p_firmware_test\", uvm_component parent=null);\n\n   super.new(name, parent);\n   if ($test$plusargs(\"gen_reduced_rand_dbg_req\")) begin\n    uvme_cv32e40p_random_debug_c::type_id::set_type_override(uvme_cv32e40p_reduced_rand_debug_req_c::get_type());\n   end\n   disable_all_trn_logs = 0;\n   if ($test$plusargs(\"disable_all_trn_logs\")) begin\n    disable_all_trn_logs = 1;\n   end\n   `uvm_info(\"TEST\", \"This is the FIRMWARE TEST\", UVM_NONE)\n\nendfunction : new\n\n\ntask uvmt_cv32e40p_firmware_test_c::reset_phase(uvm_phase phase);\n   super.reset_phase(phase);\n\nendtask : reset_phase\n\n\ntask uvmt_cv32e40p_firmware_test_c::configure_phase(uvm_phase phase);\n\n   super.configure_phase(phase);\n\nendtask : configure_phase\n\n\ntask uvmt_cv32e40p_firmware_test_c::run_phase(uvm_phase phase);\n\n   // start_clk() and watchdog_timer() are called in the base_test\n   super.run_phase(phase);\n\n   if ($test$plusargs(\"gen_random_debug\") || $test$plusargs(\"gen_reduced_rand_dbg_req\")) begin\n    fork\n      random_debug();\n    join_none\n   end\n\n   if ($test$plusargs(\"gen_irq_noise\")) begin\n    fork\n      irq_noise();\n    join_none\n   end\n\n   if ($test$plusargs(\"reset_debug\")) begin\n    fork\n      reset_debug();\n    join_none\n   end\n   if ($test$plusargs(\"debug_boot_set\")) begin\n    fork\n      bootset_debug();\n    join_none\n   end\n\n   phase.raise_objection(this);\n   @(posedge env_cntxt.clknrst_cntxt.vif.reset_n);\n   repeat (33) @(posedge env_cntxt.clknrst_cntxt.vif.clk);\n   `uvm_info(\"TEST\", \"Started RUN\", UVM_NONE)\n   // The firmware is expected to write exit status and pass/fail indication to the Virtual Peripheral\n   wait (\n          (vp_status_vif.exit_valid    == 1'b1) ||\n          (vp_status_vif.tests_failed  == 1'b1) ||\n          (vp_status_vif.tests_passed  == 1'b1)\n        );\n   repeat (100) @(posedge env_cntxt.clknrst_cntxt.vif.clk);\n   //TODO: exit_value will not be valid - need to add a latch in the vp_status_vif\n   `uvm_info(\"TEST\", $sformatf(\"Finished RUN: exit status is %0h\", vp_status_vif.exit_value), UVM_NONE)\n   phase.drop_objection(this);\n\nendtask : run_phase\n\ntask uvmt_cv32e40p_firmware_test_c::reset_debug();\n    uvme_cv32e40p_random_debug_reset_c debug_vseq;\n    debug_vseq = uvme_cv32e40p_random_debug_reset_c::type_id::create(\"random_debug_reset_vseqr\", vsequencer);\n    `uvm_info(\"TEST\", \"Applying debug_req_i at reset\", UVM_NONE);\n    @(negedge env_cntxt.clknrst_cntxt.vif.reset_n);\n\n    if (!debug_vseq.randomize()) begin\n        `uvm_fatal(\"TEST\", \"Cannot randomize the debug sequence!\")\n    end\n    debug_vseq.start(vsequencer);\n\nendtask\n\ntask uvmt_cv32e40p_firmware_test_c::bootset_debug();\n    uvme_cv32e40p_random_debug_bootset_c debug_vseq;\n    debug_vseq = uvme_cv32e40p_random_debug_bootset_c::type_id::create(\"random_debug_bootset_vseqr\", vsequencer);\n    `uvm_info(\"TEST\", \"Applying single cycle debug_req after reset\", UVM_NONE);\n    @(negedge env_cntxt.clknrst_cntxt.vif.reset_n);\n\n    // Delay debug_req_i by up to 35 cycles.Should hit BOOT_SET\n    if (!test_randvars.randomize() with { random_int inside {[1:35]}; }) begin\n        `uvm_fatal(\"TEST\", \"Cannot randomize test_randvars for debug_req_delay!\")\n    end\n    repeat(test_randvars.random_int) @(posedge env_cntxt.clknrst_cntxt.vif.clk);\n\n    if (!debug_vseq.randomize()) begin\n        `uvm_fatal(\"TEST\", \"Cannot randomize the debug sequence!\")\n    end\n    debug_vseq.start(vsequencer);\n\nendtask\n\ntask uvmt_cv32e40p_firmware_test_c::random_debug();\n    `uvm_info(\"TEST\", \"Starting random debug in thread UVM test\", UVM_NONE)\n\n    while (1) begin\n        uvme_cv32e40p_random_debug_c debug_vseq;\n        repeat (100) @(env_cntxt.debug_cntxt.vif.mon_cb);\n        debug_vseq = uvme_cv32e40p_random_debug_c::type_id::create(\"random_debug_vseqr\", vsequencer);\n        if (!debug_vseq.randomize()) begin\n           `uvm_fatal(\"TEST\", \"Cannot randomize the debug sequence!\")\n        end\n        debug_vseq.start(vsequencer);\n        break;\n    end\nendtask : random_debug\n\ntask uvmt_cv32e40p_firmware_test_c::irq_noise();\n  `uvm_info(\"TEST\", \"Starting IRQ Noise thread in UVM test\", UVM_NONE);\n  while (1) begin\n    uvme_cv32e40p_interrupt_noise_c interrupt_noise_vseq;\n\n    interrupt_noise_vseq = uvme_cv32e40p_interrupt_noise_c::type_id::create(\"interrupt_noise_vseqr\", vsequencer);\n    assert(interrupt_noise_vseq.randomize() with {\n      reserved_irq_mask == 32'h0;\n    });\n    interrupt_noise_vseq.start(vsequencer);\n    break;\n  end\nendtask : irq_noise\n\n`endif // __UVMT_CV32E40P_FIRMWARE_TEST_SV__\n","lang":"verilog"};
processSrcData(g_data);