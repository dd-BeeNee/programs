var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_id_stage.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Renzo Andri - andrire@student.ethz.ch                      //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Instruction Decode Stage                                   //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Decode stage of the core. It decodes the instructions      //\n//                 and hosts the register file.                               //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_id_stage\n  import cv32e40p_pkg::*;\n  import cv32e40p_apu_core_pkg::*;\n#(\n    parameter COREV_PULP =  1,  // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding cv.elw)\n    parameter COREV_CLUSTER = 0,\n    parameter N_HWLP = 2,\n    parameter N_HWLP_BITS = $clog2(N_HWLP),\n    parameter PULP_SECURE = 0,\n    parameter USE_PMP = 0,\n    parameter A_EXTENSION = 0,\n    parameter APU = 0,\n    parameter FPU = 0,\n    parameter FPU_ADDMUL_LAT = 0,\n    parameter FPU_OTHERS_LAT = 0,\n    parameter ZFINX = 0,\n    parameter APU_NARGS_CPU = 3,\n    parameter APU_WOP_CPU = 6,\n    parameter APU_NDSFLAGS_CPU = 15,\n    parameter APU_NUSFLAGS_CPU = 5,\n    parameter DEBUG_TRIGGER_EN = 1\n) (\n    input logic clk,  // Gated clock\n    input logic clk_ungated_i,  // Ungated clock\n    input logic rst_n,\n\n    input logic scan_cg_en_i,\n\n    input  logic fetch_enable_i,\n    output logic ctrl_busy_o,\n    output logic is_decoding_o,\n\n    // Interface to IF stage\n    input  logic        instr_valid_i,\n    input  logic [31:0] instr_rdata_i,  // comes from pipeline of IF stage\n    output logic        instr_req_o,\n    input  logic        is_compressed_i,\n    input  logic        illegal_c_insn_i,\n\n    // Jumps and branches\n    output logic        branch_in_ex_o,\n    input  logic        branch_decision_i,\n    output logic [31:0] jump_target_o,\n    output logic [ 1:0] ctrl_transfer_insn_in_dec_o,\n\n    // IF and ID stage signals\n    output logic       clear_instr_valid_o,\n    output logic       pc_set_o,\n    output logic [3:0] pc_mux_o,\n    output logic [2:0] exc_pc_mux_o,\n    output logic [1:0] trap_addr_mux_o,\n\n\n    input logic is_fetch_failed_i,\n\n    input logic [31:0] pc_id_i,\n\n    // Stalls\n    output logic halt_if_o,  // controller requests a halt of the IF stage\n\n    output logic id_ready_o,  // ID stage is ready for the next instruction\n    input  logic ex_ready_i,  // EX stage is ready for the next instruction\n    input  logic wb_ready_i,  // WB stage is ready for the next instruction\n\n    output logic id_valid_o,  // ID stage is done\n    input  logic ex_valid_i,  // EX stage is done\n\n    // Pipeline ID/EX\n    output logic [31:0] pc_ex_o,\n\n    output logic [31:0] alu_operand_a_ex_o,\n    output logic [31:0] alu_operand_b_ex_o,\n    output logic [31:0] alu_operand_c_ex_o,\n    output logic [ 4:0] bmask_a_ex_o,\n    output logic [ 4:0] bmask_b_ex_o,\n    output logic [ 1:0] imm_vec_ext_ex_o,\n    output logic [ 1:0] alu_vec_mode_ex_o,\n\n    output logic [5:0] regfile_waddr_ex_o,\n    output logic       regfile_we_ex_o,\n\n    output logic [5:0] regfile_alu_waddr_ex_o,\n    output logic       regfile_alu_we_ex_o,\n\n    // ALU\n    output logic              alu_en_ex_o,\n    output alu_opcode_e       alu_operator_ex_o,\n    output logic              alu_is_clpx_ex_o,\n    output logic              alu_is_subrot_ex_o,\n    output logic        [1:0] alu_clpx_shift_ex_o,\n\n    // MUL\n    output mul_opcode_e        mult_operator_ex_o,\n    output logic        [31:0] mult_operand_a_ex_o,\n    output logic        [31:0] mult_operand_b_ex_o,\n    output logic        [31:0] mult_operand_c_ex_o,\n    output logic               mult_en_ex_o,\n    output logic               mult_sel_subword_ex_o,\n    output logic        [ 1:0] mult_signed_mode_ex_o,\n    output logic        [ 4:0] mult_imm_ex_o,\n\n    output logic [31:0] mult_dot_op_a_ex_o,\n    output logic [31:0] mult_dot_op_b_ex_o,\n    output logic [31:0] mult_dot_op_c_ex_o,\n    output logic [ 1:0] mult_dot_signed_ex_o,\n    output logic        mult_is_clpx_ex_o,\n    output logic [ 1:0] mult_clpx_shift_ex_o,\n    output logic        mult_clpx_img_ex_o,\n\n    // APU\n    output logic                              apu_en_ex_o,\n    output logic [     APU_WOP_CPU-1:0]       apu_op_ex_o,\n    output logic [                 1:0]       apu_lat_ex_o,\n    output logic [   APU_NARGS_CPU-1:0][31:0] apu_operands_ex_o,\n    output logic [APU_NDSFLAGS_CPU-1:0]       apu_flags_ex_o,\n    output logic [                 5:0]       apu_waddr_ex_o,\n\n    output logic [2:0][5:0] apu_read_regs_o,\n    output logic [2:0]      apu_read_regs_valid_o,\n    input  logic            apu_read_dep_i,\n    input  logic            apu_read_dep_for_jalr_i,\n    output logic [1:0][5:0] apu_write_regs_o,\n    output logic [1:0]      apu_write_regs_valid_o,\n    input  logic            apu_write_dep_i,\n    output logic            apu_perf_dep_o,\n    input  logic            apu_busy_i,\n\n    input logic            fs_off_i,\n    input logic [C_RM-1:0] frm_i,\n\n    // CSR ID/EX\n    output logic              csr_access_ex_o,\n    output csr_opcode_e       csr_op_ex_o,\n    input  PrivLvl_t          current_priv_lvl_i,\n    output logic              csr_irq_sec_o,\n    output logic        [5:0] csr_cause_o,\n    output logic              csr_save_if_o,\n    output logic              csr_save_id_o,\n    output logic              csr_save_ex_o,\n    output logic              csr_restore_mret_id_o,\n    output logic              csr_restore_uret_id_o,\n    output logic              csr_restore_dret_id_o,\n    output logic              csr_save_cause_o,\n\n    // hwloop signals\n    output logic [N_HWLP-1:0][31:0] hwlp_start_o,\n    output logic [N_HWLP-1:0][31:0] hwlp_end_o,\n    output logic [N_HWLP-1:0][31:0] hwlp_cnt_o,\n    output logic                    hwlp_jump_o,\n    output logic [      31:0]       hwlp_target_o,\n\n    // Interface to load store unit\n    output logic       data_req_ex_o,\n    output logic       data_we_ex_o,\n    output logic [1:0] data_type_ex_o,\n    output logic [1:0] data_sign_ext_ex_o,\n    output logic [1:0] data_reg_offset_ex_o,\n    output logic       data_load_event_ex_o,\n\n    output logic data_misaligned_ex_o,\n\n    output logic prepost_useincr_ex_o,\n    input  logic data_misaligned_i,\n    input  logic data_err_i,\n    output logic data_err_ack_o,\n\n    output logic [5:0] atop_ex_o,\n\n    // Interrupt signals\n    input  logic [31:0] irq_i,\n    input  logic        irq_sec_i,\n    input  logic [31:0] mie_bypass_i,  // MIE CSR (bypass)\n    output logic [31:0] mip_o,  // MIP CSR\n    input  logic        m_irq_enable_i,\n    input  logic        u_irq_enable_i,\n    output logic        irq_ack_o,\n    output logic [ 4:0] irq_id_o,\n    output logic [ 4:0] exc_cause_o,\n\n    // Debug Signal\n    output logic       debug_mode_o,\n    output logic [2:0] debug_cause_o,\n    output logic       debug_csr_save_o,\n    input  logic       debug_req_i,\n    input  logic       debug_single_step_i,\n    input  logic       debug_ebreakm_i,\n    input  logic       debug_ebreaku_i,\n    input  logic       trigger_match_i,\n    output logic       debug_p_elw_no_sleep_o,\n    output logic       debug_havereset_o,\n    output logic       debug_running_o,\n    output logic       debug_halted_o,\n\n    // Wakeup Signal\n    output logic wake_from_sleep_o,\n\n    // Forward Signals\n    input logic [5:0] regfile_waddr_wb_i,\n    input logic regfile_we_wb_i,\n    input logic regfile_we_wb_power_i,\n    input  logic [31:0] regfile_wdata_wb_i, // From wb_stage: selects data from data memory, ex_stage result and sp rdata\n\n    input logic [ 5:0] regfile_alu_waddr_fw_i,\n    input logic        regfile_alu_we_fw_i,\n    input logic        regfile_alu_we_fw_power_i,\n    input logic [31:0] regfile_alu_wdata_fw_i,\n\n    // from ALU\n    input  logic        mult_multicycle_i,    // when we need multiple cycles in the multiplier and use op c as storage\n\n    // Performance Counters\n    output logic mhpmevent_minstret_o,\n    output logic mhpmevent_load_o,\n    output logic mhpmevent_store_o,\n    output logic mhpmevent_jump_o,\n    output logic mhpmevent_branch_o,\n    output logic mhpmevent_branch_taken_o,\n    output logic mhpmevent_compressed_o,\n    output logic mhpmevent_jr_stall_o,\n    output logic mhpmevent_imiss_o,\n    output logic mhpmevent_ld_stall_o,\n    output logic mhpmevent_pipe_stall_o,\n\n    input logic        perf_imiss_i,\n    input logic [31:0] mcounteren_i\n);\n\n  // Source/Destination register instruction index\n  localparam REG_S1_MSB = 19;\n  localparam REG_S1_LSB = 15;\n\n  localparam REG_S2_MSB = 24;\n  localparam REG_S2_LSB = 20;\n\n  localparam REG_S4_MSB = 31;\n  localparam REG_S4_LSB = 27;\n\n  localparam REG_D_MSB = 11;\n  localparam REG_D_LSB = 7;\n\n  logic [31:0] instr;\n\n\n  // Decoder/Controller ID stage internal signals\n  logic        deassert_we;\n\n  logic        illegal_insn_dec;\n  logic        ebrk_insn_dec;\n  logic        mret_insn_dec;\n  logic        uret_insn_dec;\n\n  logic        dret_insn_dec;\n\n  logic        ecall_insn_dec;\n  logic        wfi_insn_dec;\n\n  logic        fencei_insn_dec;\n\n  logic        rega_used_dec;\n  logic        regb_used_dec;\n  logic        regc_used_dec;\n\n  logic        branch_taken_ex;\n  logic [ 1:0] ctrl_transfer_insn_in_id;\n  logic [ 1:0] ctrl_transfer_insn_in_dec;\n\n  logic        misaligned_stall;\n  logic        jr_stall;\n  logic        load_stall;\n  logic        csr_apu_stall;\n  logic        hwlp_mask;\n  logic        halt_id;\n  logic        halt_if;\n\n  logic        debug_wfi_no_sleep;\n\n  // Immediate decoding and sign extension\n  logic [31:0] imm_i_type;\n  logic [31:0] imm_iz_type;\n  logic [31:0] imm_s_type;\n  logic [31:0] imm_sb_type;\n  logic [31:0] imm_u_type;\n  logic [31:0] imm_uj_type;\n  logic [31:0] imm_z_type;\n  logic [31:0] imm_s2_type;\n  logic [31:0] imm_bi_type;\n  logic [31:0] imm_s3_type;\n  logic [31:0] imm_vs_type;\n  logic [31:0] imm_vu_type;\n  logic [31:0] imm_shuffleb_type;\n  logic [31:0] imm_shuffleh_type;\n  logic [31:0] imm_shuffle_type;\n  logic [31:0] imm_clip_type;\n\n  logic [31:0] imm_a;  // contains the immediate for operand b\n  logic [31:0] imm_b;  // contains the immediate for operand b\n\n  logic [31:0] jump_target;  // calculated jump target (-> EX -> IF)\n\n  // Signals running between controller and int_controller\n  logic        irq_req_ctrl;\n  logic        irq_sec_ctrl;\n  logic        irq_wu_ctrl;\n  logic [ 4:0] irq_id_ctrl;\n\n  // Register file interface\n  logic [ 5:0] regfile_addr_ra_id;\n  logic [ 5:0] regfile_addr_rb_id;\n  logic [ 5:0] regfile_addr_rc_id;\n\n  logic        regfile_fp_a;\n  logic        regfile_fp_b;\n  logic        regfile_fp_c;\n  logic        regfile_fp_d;\n\n  logic [ 5:0] regfile_waddr_id;\n  logic [ 5:0] regfile_alu_waddr_id;\n  logic regfile_alu_we_id, regfile_alu_we_dec_id;\n\n  logic [31:0] regfile_data_ra_id;\n  logic [31:0] regfile_data_rb_id;\n  logic [31:0] regfile_data_rc_id;\n\n  // ALU Control\n  logic alu_en;\n  alu_opcode_e alu_operator;\n  logic [2:0] alu_op_a_mux_sel;\n  logic [2:0] alu_op_b_mux_sel;\n  logic [1:0] alu_op_c_mux_sel;\n  logic [1:0] regc_mux;\n\n  logic [0:0] imm_a_mux_sel;\n  logic [3:0] imm_b_mux_sel;\n  logic [1:0] ctrl_transfer_target_mux_sel;\n\n  // Multiplier Control\n  mul_opcode_e mult_operator;  // multiplication operation selection\n  logic mult_en;  // multiplication is used instead of ALU\n  logic mult_int_en;  // use integer multiplier\n  logic mult_sel_subword;  // Select a subword when doing multiplications\n  logic [1:0]  mult_signed_mode; // Signed mode multiplication at the output of the controller, and before the pipe registers\n  logic mult_dot_en;  // use dot product\n  logic [1:0] mult_dot_signed;  // Signed mode dot products (can be mixed types)\n\n  // FPU signals\n  logic [cv32e40p_fpu_pkg::FP_FORMAT_BITS-1:0] fpu_src_fmt;\n  logic [cv32e40p_fpu_pkg::FP_FORMAT_BITS-1:0] fpu_dst_fmt;\n  logic [cv32e40p_fpu_pkg::INT_FORMAT_BITS-1:0] fpu_int_fmt;\n\n  // APU signals\n  logic apu_en;\n  logic [APU_WOP_CPU-1:0] apu_op;\n  logic [1:0] apu_lat;\n  logic [APU_NARGS_CPU-1:0][31:0] apu_operands;\n  logic [APU_NDSFLAGS_CPU-1:0] apu_flags;\n  logic [5:0] apu_waddr;\n\n  logic [2:0][5:0] apu_read_regs;\n  logic [2:0] apu_read_regs_valid;\n  logic [1:0][5:0] apu_write_regs;\n  logic [1:0] apu_write_regs_valid;\n\n  logic apu_stall;\n  logic [2:0] fp_rnd_mode;\n\n  // Register Write Control\n  logic regfile_we_id;\n  logic regfile_alu_waddr_mux_sel;\n\n  // Data Memory Control\n  logic data_we_id;\n  logic [1:0] data_type_id;\n  logic [1:0] data_sign_ext_id;\n  logic [1:0] data_reg_offset_id;\n  logic data_req_id;\n  logic data_load_event_id;\n\n  // Atomic memory instruction\n  logic [5:0] atop_id;\n\n  // hwloop signals\n  logic [N_HWLP_BITS-1:0] hwlp_regid;\n  logic [2:0] hwlp_we, hwlp_we_masked;\n  logic        [       1:0] hwlp_target_mux_sel;\n  logic        [       1:0] hwlp_start_mux_sel;\n  logic                     hwlp_cnt_mux_sel;\n\n  logic        [      31:0] hwlp_start;\n  logic        [      31:0] hwlp_end;\n  logic        [      31:0] hwlp_cnt;\n  logic        [N_HWLP-1:0] hwlp_dec_cnt;\n  logic                     hwlp_valid;\n\n  // CSR control\n  logic                     csr_access;\n  csr_opcode_e              csr_op;\n  logic                     csr_status;\n\n  logic                     prepost_useincr;\n\n  // Forwarding\n  logic        [       1:0] operand_a_fw_mux_sel;\n  logic        [       1:0] operand_b_fw_mux_sel;\n  logic        [       1:0] operand_c_fw_mux_sel;\n  logic        [      31:0] operand_a_fw_id;\n  logic        [      31:0] operand_b_fw_id;\n  logic        [      31:0] operand_c_fw_id;\n\n  logic [31:0] operand_b, operand_b_vec;\n  logic [31:0] operand_c, operand_c_vec;\n\n  logic [31:0] alu_operand_a;\n  logic [31:0] alu_operand_b;\n  logic [31:0] alu_operand_c;\n\n  // Immediates for ID\n  logic [ 0:0] bmask_a_mux;\n  logic [ 1:0] bmask_b_mux;\n  logic        alu_bmask_a_mux_sel;\n  logic        alu_bmask_b_mux_sel;\n  logic [ 0:0] mult_imm_mux;\n\n  logic [ 4:0] bmask_a_id_imm;\n  logic [ 4:0] bmask_b_id_imm;\n  logic [ 4:0] bmask_a_id;\n  logic [ 4:0] bmask_b_id;\n  logic [ 1:0] imm_vec_ext_id;\n  logic [ 4:0] mult_imm_id;\n\n  logic        alu_vec;\n  logic [ 1:0] alu_vec_mode;\n  logic        scalar_replication;\n  logic        scalar_replication_c;\n\n  // Forwarding detection signals\n  logic        reg_d_ex_is_reg_a_id;\n  logic        reg_d_ex_is_reg_b_id;\n  logic        reg_d_ex_is_reg_c_id;\n  logic        reg_d_wb_is_reg_a_id;\n  logic        reg_d_wb_is_reg_b_id;\n  logic        reg_d_wb_is_reg_c_id;\n  logic        reg_d_alu_is_reg_a_id;\n  logic        reg_d_alu_is_reg_b_id;\n  logic        reg_d_alu_is_reg_c_id;\n\n  logic is_clpx, is_subrot;\n\n  logic mret_dec;\n  logic uret_dec;\n  logic dret_dec;\n\n  // Performance counters\n  logic id_valid_q;\n  logic minstret;\n  logic perf_pipeline_stall;\n\n  assign instr = instr_rdata_i;\n\n\n  // immediate extraction and sign extension\n  assign imm_i_type = {{20{instr[31]}}, instr[31:20]};\n  assign imm_iz_type = {20'b0, instr[31:20]};\n  assign imm_s_type = {{20{instr[31]}}, instr[31:25], instr[11:7]};\n  assign imm_sb_type = {{19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0};\n  assign imm_u_type = {instr[31:12], 12'b0};\n  assign imm_uj_type = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n\n  // immediate for CSR manipulatin (zero extended)\n  assign imm_z_type = {27'b0, instr[REG_S1_MSB:REG_S1_LSB]};\n\n  assign imm_s2_type = {27'b0, instr[24:20]};\n  assign imm_bi_type = {{27{instr[24]}}, instr[24:20]};\n  assign imm_s3_type = {27'b0, instr[29:25]};\n  assign imm_vs_type = {{26{instr[24]}}, instr[24:20], instr[25]};\n  assign imm_vu_type = {26'b0, instr[24:20], instr[25]};\n\n  // same format as rS2 for shuffle needs, expands immediate\n  assign imm_shuffleb_type = {\n    6'b0, instr[28:27], 6'b0, instr[24:23], 6'b0, instr[22:21], 6'b0, instr[20], instr[25]\n  };\n  assign imm_shuffleh_type = {15'h0, instr[20], 15'h0, instr[25]};\n\n  // clipping immediate, uses a small barrel shifter to pre-process the\n  // immediate and an adder to subtract 1\n  // The end result is a mask that has 1's set in the lower part\n  assign imm_clip_type = (32'h1 << instr[24:20]) - 1;\n\n  //---------------------------------------------------------------------------\n  // source register selection regfile_fp_x=1 <=> CV32E40P_REG_x is a FP-register\n  //---------------------------------------------------------------------------\n  assign regfile_addr_ra_id = {regfile_fp_a, instr[REG_S1_MSB:REG_S1_LSB]};\n  assign regfile_addr_rb_id = {regfile_fp_b, instr[REG_S2_MSB:REG_S2_LSB]};\n\n  // register C mux\n  always_comb begin\n    unique case (regc_mux)\n      REGC_ZERO: regfile_addr_rc_id = '0;\n      REGC_RD:   regfile_addr_rc_id = {regfile_fp_c, instr[REG_D_MSB:REG_D_LSB]};\n      REGC_S1:   regfile_addr_rc_id = {regfile_fp_c, instr[REG_S1_MSB:REG_S1_LSB]};\n      REGC_S4:   regfile_addr_rc_id = {regfile_fp_c, instr[REG_S4_MSB:REG_S4_LSB]};\n    endcase\n  end\n\n  //---------------------------------------------------------------------------\n  // destination registers regfile_fp_d=1 <=> REG_D is a FP-register\n  //---------------------------------------------------------------------------\n  assign regfile_waddr_id = {regfile_fp_d, instr[REG_D_MSB:REG_D_LSB]};\n\n  // Second Register Write Address Selection\n  // Used for prepost load/store and multiplier\n  assign regfile_alu_waddr_id = regfile_alu_waddr_mux_sel ? regfile_waddr_id : regfile_addr_ra_id;\n\n  // Forwarding control signals\n  assign reg_d_ex_is_reg_a_id  = (regfile_waddr_ex_o     == regfile_addr_ra_id) && (rega_used_dec == 1'b1) && (regfile_addr_ra_id != '0);\n  assign reg_d_ex_is_reg_b_id  = (regfile_waddr_ex_o     == regfile_addr_rb_id) && (regb_used_dec == 1'b1) && (regfile_addr_rb_id != '0);\n  assign reg_d_ex_is_reg_c_id  = (regfile_waddr_ex_o     == regfile_addr_rc_id) && (regc_used_dec == 1'b1) && (regfile_addr_rc_id != '0);\n  assign reg_d_wb_is_reg_a_id  = (regfile_waddr_wb_i     == regfile_addr_ra_id) && (rega_used_dec == 1'b1) && (regfile_addr_ra_id != '0);\n  assign reg_d_wb_is_reg_b_id  = (regfile_waddr_wb_i     == regfile_addr_rb_id) && (regb_used_dec == 1'b1) && (regfile_addr_rb_id != '0);\n  assign reg_d_wb_is_reg_c_id  = (regfile_waddr_wb_i     == regfile_addr_rc_id) && (regc_used_dec == 1'b1) && (regfile_addr_rc_id != '0);\n  assign reg_d_alu_is_reg_a_id = (regfile_alu_waddr_fw_i == regfile_addr_ra_id) && (rega_used_dec == 1'b1) && (regfile_addr_ra_id != '0);\n  assign reg_d_alu_is_reg_b_id = (regfile_alu_waddr_fw_i == regfile_addr_rb_id) && (regb_used_dec == 1'b1) && (regfile_addr_rb_id != '0);\n  assign reg_d_alu_is_reg_c_id = (regfile_alu_waddr_fw_i == regfile_addr_rc_id) && (regc_used_dec == 1'b1) && (regfile_addr_rc_id != '0);\n\n\n  // kill instruction in the IF/ID stage by setting the instr_valid_id control\n  // signal to 0 for instructions that are done\n  assign clear_instr_valid_o = id_ready_o | halt_id | branch_taken_ex;\n\n  assign branch_taken_ex = branch_in_ex_o && branch_decision_i;\n\n\n  assign mult_en = mult_int_en | mult_dot_en;\n\n\n  //////////////////////////////////////////////////////////////////\n  //      _                         _____                    _    //\n  //     | |_   _ _ __ ___  _ __   |_   _|_ _ _ __ __ _  ___| |_  //\n  //  _  | | | | | '_ ` _ \\| '_ \\    | |/ _` | '__/ _` |/ _ \\ __| //\n  // | |_| | |_| | | | | | | |_) |   | | (_| | | | (_| |  __/ |_  //\n  //  \\___/ \\__,_|_| |_| |_| .__/    |_|\\__,_|_|  \\__, |\\___|\\__| //\n  //                       |_|                    |___/           //\n  //////////////////////////////////////////////////////////////////\n\n  always_comb begin : jump_target_mux\n    unique case (ctrl_transfer_target_mux_sel)\n      JT_JAL:  jump_target = pc_id_i + imm_uj_type;\n      JT_COND: jump_target = pc_id_i + imm_sb_type;\n\n      // JALR: Cannot forward RS1, since the path is too long\n      JT_JALR: jump_target = regfile_data_ra_id + imm_i_type;\n      default: jump_target = regfile_data_ra_id + imm_i_type;\n    endcase\n  end\n\n  assign jump_target_o = jump_target;\n\n\n  ////////////////////////////////////////////////////////\n  //   ___                                 _      _     //\n  //  / _ \\ _ __   ___ _ __ __ _ _ __   __| |    / \\    //\n  // | | | | '_ \\ / _ \\ '__/ _` | '_ \\ / _` |   / _ \\   //\n  // | |_| | |_) |  __/ | | (_| | | | | (_| |  / ___ \\  //\n  //  \\___/| .__/ \\___|_|  \\__,_|_| |_|\\__,_| /_/   \\_\\ //\n  //       |_|                                          //\n  ////////////////////////////////////////////////////////\n\n  // ALU_Op_a Mux\n  always_comb begin : alu_operand_a_mux\n    case (alu_op_a_mux_sel)\n      OP_A_REGA_OR_FWD: alu_operand_a = operand_a_fw_id;\n      OP_A_REGB_OR_FWD: alu_operand_a = operand_b_fw_id;\n      OP_A_REGC_OR_FWD: alu_operand_a = operand_c_fw_id;\n      OP_A_CURRPC:      alu_operand_a = pc_id_i;\n      OP_A_IMM:         alu_operand_a = imm_a;\n      default:          alu_operand_a = operand_a_fw_id;\n    endcase\n    ;  // case (alu_op_a_mux_sel)\n  end\n\n  always_comb begin : immediate_a_mux\n    unique case (imm_a_mux_sel)\n      IMMA_Z:    imm_a = imm_z_type;\n      IMMA_ZERO: imm_a = '0;\n    endcase\n  end\n\n  // Operand a forwarding mux\n  always_comb begin : operand_a_fw_mux\n    case (operand_a_fw_mux_sel)\n      SEL_FW_EX:   operand_a_fw_id = regfile_alu_wdata_fw_i;\n      SEL_FW_WB:   operand_a_fw_id = regfile_wdata_wb_i;\n      SEL_REGFILE: operand_a_fw_id = regfile_data_ra_id;\n      default:     operand_a_fw_id = regfile_data_ra_id;\n    endcase\n    ;  // case (operand_a_fw_mux_sel)\n  end\n\n  //////////////////////////////////////////////////////\n  //   ___                                 _   ____   //\n  //  / _ \\ _ __   ___ _ __ __ _ _ __   __| | | __ )  //\n  // | | | | '_ \\ / _ \\ '__/ _` | '_ \\ / _` | |  _ \\  //\n  // | |_| | |_) |  __/ | | (_| | | | | (_| | | |_) | //\n  //  \\___/| .__/ \\___|_|  \\__,_|_| |_|\\__,_| |____/  //\n  //       |_|                                        //\n  //////////////////////////////////////////////////////\n\n  // Immediate Mux for operand B\n  always_comb begin : immediate_b_mux\n    unique case (imm_b_mux_sel)\n      IMMB_I:      imm_b = imm_i_type;\n      IMMB_S:      imm_b = imm_s_type;\n      IMMB_U:      imm_b = imm_u_type;\n      IMMB_PCINCR: imm_b = is_compressed_i ? 32'h2 : 32'h4;\n      IMMB_S2:     imm_b = imm_s2_type;\n      IMMB_BI:     imm_b = imm_bi_type;\n      IMMB_S3:     imm_b = imm_s3_type;\n      IMMB_VS:     imm_b = imm_vs_type;\n      IMMB_VU:     imm_b = imm_vu_type;\n      IMMB_SHUF:   imm_b = imm_shuffle_type;\n      IMMB_CLIP:   imm_b = {1'b0, imm_clip_type[31:1]};\n      default:     imm_b = imm_i_type;\n    endcase\n  end\n\n  // ALU_Op_b Mux\n  always_comb begin : alu_operand_b_mux\n    case (alu_op_b_mux_sel)\n      OP_B_REGA_OR_FWD: operand_b = operand_a_fw_id;\n      OP_B_REGB_OR_FWD: operand_b = operand_b_fw_id;\n      OP_B_REGC_OR_FWD: operand_b = operand_c_fw_id;\n      OP_B_IMM:         operand_b = imm_b;\n      OP_B_BMASK:       operand_b = $unsigned(operand_b_fw_id[4:0]);\n      default:          operand_b = operand_b_fw_id;\n    endcase  // case (alu_op_b_mux_sel)\n  end\n\n\n  // scalar replication for operand B and shuffle type\n  always_comb begin\n    if (alu_vec_mode == VEC_MODE8) begin\n      operand_b_vec    = {4{operand_b[7:0]}};\n      imm_shuffle_type = imm_shuffleb_type;\n    end else begin\n      operand_b_vec    = {2{operand_b[15:0]}};\n      imm_shuffle_type = imm_shuffleh_type;\n    end\n  end\n\n  // choose normal or scalar replicated version of operand b\n  assign alu_operand_b = (scalar_replication == 1'b1) ? operand_b_vec : operand_b;\n\n\n  // Operand b forwarding mux\n  always_comb begin : operand_b_fw_mux\n    case (operand_b_fw_mux_sel)\n      SEL_FW_EX:   operand_b_fw_id = regfile_alu_wdata_fw_i;\n      SEL_FW_WB:   operand_b_fw_id = regfile_wdata_wb_i;\n      SEL_REGFILE: operand_b_fw_id = regfile_data_rb_id;\n      default:     operand_b_fw_id = regfile_data_rb_id;\n    endcase\n    ;  // case (operand_b_fw_mux_sel)\n  end\n\n\n  //////////////////////////////////////////////////////\n  //   ___                                 _    ____  //\n  //  / _ \\ _ __   ___ _ __ __ _ _ __   __| |  / ___| //\n  // | | | | '_ \\ / _ \\ '__/ _` | '_ \\ / _` | | |     //\n  // | |_| | |_) |  __/ | | (_| | | | | (_| | | |___  //\n  //  \\___/| .__/ \\___|_|  \\__,_|_| |_|\\__,_|  \\____| //\n  //       |_|                                        //\n  //////////////////////////////////////////////////////\n\n  // ALU OP C Mux\n  always_comb begin : alu_operand_c_mux\n    case (alu_op_c_mux_sel)\n      OP_C_REGC_OR_FWD: operand_c = operand_c_fw_id;\n      OP_C_REGB_OR_FWD: operand_c = operand_b_fw_id;\n      OP_C_JT:          operand_c = jump_target;\n      default:          operand_c = operand_c_fw_id;\n    endcase  // case (alu_op_c_mux_sel)\n  end\n\n\n  // scalar replication for operand C and shuffle type\n  always_comb begin\n    if (alu_vec_mode == VEC_MODE8) begin\n      operand_c_vec = {4{operand_c[7:0]}};\n    end else begin\n      operand_c_vec = {2{operand_c[15:0]}};\n    end\n  end\n\n  // choose normal or scalar replicated version of operand b\n  assign alu_operand_c = (scalar_replication_c == 1'b1) ? operand_c_vec : operand_c;\n\n\n  // Operand c forwarding mux\n  always_comb begin : operand_c_fw_mux\n    case (operand_c_fw_mux_sel)\n      SEL_FW_EX:   operand_c_fw_id = regfile_alu_wdata_fw_i;\n      SEL_FW_WB:   operand_c_fw_id = regfile_wdata_wb_i;\n      SEL_REGFILE: operand_c_fw_id = regfile_data_rc_id;\n      default:     operand_c_fw_id = regfile_data_rc_id;\n    endcase\n    ;  // case (operand_c_fw_mux_sel)\n  end\n\n\n  ///////////////////////////////////////////////////////////////////////////\n  //  ___                              _ _       _              ___ ____   //\n  // |_ _|_ __ ___  _ __ ___   ___  __| (_) __ _| |_ ___  ___  |_ _|  _ \\  //\n  //  | || '_ ` _ \\| '_ ` _ \\ / _ \\/ _` | |/ _` | __/ _ \\/ __|  | || | | | //\n  //  | || | | | | | | | | | |  __/ (_| | | (_| | ||  __/\\__ \\  | || |_| | //\n  // |___|_| |_| |_|_| |_| |_|\\___|\\__,_|_|\\__,_|\\__\\___||___/ |___|____/  //\n  //                                                                       //\n  ///////////////////////////////////////////////////////////////////////////\n\n  always_comb begin\n    unique case (bmask_a_mux)\n      BMASK_A_ZERO: bmask_a_id_imm = '0;\n      BMASK_A_S3:   bmask_a_id_imm = imm_s3_type[4:0];\n    endcase\n  end\n  always_comb begin\n    unique case (bmask_b_mux)\n      BMASK_B_ZERO: bmask_b_id_imm = '0;\n      BMASK_B_ONE:  bmask_b_id_imm = 5'd1;\n      BMASK_B_S2:   bmask_b_id_imm = imm_s2_type[4:0];\n      BMASK_B_S3:   bmask_b_id_imm = imm_s3_type[4:0];\n    endcase\n  end\n\n  always_comb begin\n    unique case (alu_bmask_a_mux_sel)\n      BMASK_A_IMM: bmask_a_id = bmask_a_id_imm;\n      BMASK_A_REG: bmask_a_id = operand_b_fw_id[9:5];\n    endcase\n  end\n  always_comb begin\n    unique case (alu_bmask_b_mux_sel)\n      BMASK_B_IMM: bmask_b_id = bmask_b_id_imm;\n      BMASK_B_REG: bmask_b_id = operand_b_fw_id[4:0];\n    endcase\n  end\n\n  generate\n    if (!COREV_PULP) begin\n      assign imm_vec_ext_id = imm_vu_type[1:0];\n    end else begin\n      assign imm_vec_ext_id = (alu_vec) ? imm_vu_type[1:0] : 2'b0;\n    end\n  endgenerate\n\n  always_comb begin\n    unique case (mult_imm_mux)\n      MIMM_ZERO: mult_imm_id = '0;\n      MIMM_S3:   mult_imm_id = imm_s3_type[4:0];\n    endcase\n  end\n\n  /////////////////////////////\n  // APU operand assignment  //\n  /////////////////////////////\n  // read regs\n  generate\n    if (APU == 1) begin : gen_apu\n\n      if (APU_NARGS_CPU >= 1) assign apu_operands[0] = alu_operand_a;\n      if (APU_NARGS_CPU >= 2) assign apu_operands[1] = alu_operand_b;\n      if (APU_NARGS_CPU >= 3) assign apu_operands[2] = alu_operand_c;\n\n      // write reg\n      assign apu_waddr = regfile_alu_waddr_id;\n\n      // flags\n      assign apu_flags = (FPU == 1) ? {fpu_int_fmt, fpu_src_fmt, fpu_dst_fmt, fp_rnd_mode} : '0;\n\n      // dependency checks\n      always_comb begin\n        unique case (alu_op_a_mux_sel)\n          OP_A_CURRPC: begin\n            if (ctrl_transfer_target_mux_sel == JT_JALR) begin\n              apu_read_regs[0]       = regfile_addr_ra_id;\n              apu_read_regs_valid[0] = 1'b1;\n            end else begin\n              apu_read_regs[0]       = regfile_addr_ra_id;\n              apu_read_regs_valid[0] = 1'b0;\n            end\n          end  // OP_A_CURRPC:\n          OP_A_REGA_OR_FWD: begin\n            apu_read_regs[0]       = regfile_addr_ra_id;\n            apu_read_regs_valid[0] = 1'b1;\n          end  // OP_A_REGA_OR_FWD:\n          OP_A_REGB_OR_FWD, OP_A_REGC_OR_FWD: begin\n            apu_read_regs[0]       = regfile_addr_rb_id;\n            apu_read_regs_valid[0] = 1'b1;\n          end\n          default: begin\n            apu_read_regs[0]       = regfile_addr_ra_id;\n            apu_read_regs_valid[0] = 1'b0;\n          end\n        endcase\n      end\n\n      always_comb begin\n        unique case (alu_op_b_mux_sel)\n          OP_B_REGA_OR_FWD: begin\n            apu_read_regs[1]       = regfile_addr_ra_id;\n            apu_read_regs_valid[1] = 1'b1;\n          end\n          OP_B_REGB_OR_FWD, OP_B_BMASK: begin\n            apu_read_regs[1]       = regfile_addr_rb_id;\n            apu_read_regs_valid[1] = 1'b1;\n          end\n          OP_B_REGC_OR_FWD: begin\n            apu_read_regs[1]       = regfile_addr_rc_id;\n            apu_read_regs_valid[1] = 1'b1;\n          end\n          OP_B_IMM: begin\n            if (alu_bmask_b_mux_sel == BMASK_B_REG) begin\n              apu_read_regs[1]       = regfile_addr_rb_id;\n              apu_read_regs_valid[1] = 1'b1;\n            end else begin\n              apu_read_regs[1]       = regfile_addr_rb_id;\n              apu_read_regs_valid[1] = 1'b0;\n            end\n          end\n          default: begin\n            apu_read_regs[1]       = regfile_addr_rb_id;\n            apu_read_regs_valid[1] = 1'b0;\n          end\n        endcase\n      end\n\n      always_comb begin\n        unique case (alu_op_c_mux_sel)\n          OP_C_REGB_OR_FWD: begin\n            apu_read_regs[2]       = regfile_addr_rb_id;\n            apu_read_regs_valid[2] = 1'b1;\n          end\n          OP_C_REGC_OR_FWD: begin\n            if ((alu_op_a_mux_sel != OP_A_REGC_OR_FWD) && (ctrl_transfer_target_mux_sel != JT_JALR) &&\n                !((alu_op_b_mux_sel == OP_B_IMM) && (alu_bmask_b_mux_sel == BMASK_B_REG)) &&\n                !(alu_op_b_mux_sel == OP_B_BMASK)) begin\n              apu_read_regs[2]       = regfile_addr_rc_id;\n              apu_read_regs_valid[2] = 1'b1;\n            end else begin\n              apu_read_regs[2]       = regfile_addr_rc_id;\n              apu_read_regs_valid[2] = 1'b0;\n            end\n          end\n          default: begin\n            apu_read_regs[2]       = regfile_addr_rc_id;\n            apu_read_regs_valid[2] = 1'b0;\n          end\n        endcase\n      end\n\n      assign apu_write_regs[0]       = regfile_alu_waddr_id;\n      assign apu_write_regs_valid[0] = regfile_alu_we_id;\n\n      assign apu_write_regs[1]       = regfile_waddr_id;\n      assign apu_write_regs_valid[1] = regfile_we_id;\n\n      assign apu_read_regs_o         = apu_read_regs;\n      assign apu_read_regs_valid_o   = apu_read_regs_valid;\n\n      assign apu_write_regs_o        = apu_write_regs;\n      assign apu_write_regs_valid_o  = apu_write_regs_valid;\n    end else begin : gen_no_apu\n      for (genvar i = 0; i < APU_NARGS_CPU; i++) begin : gen_apu_tie_off\n        assign apu_operands[i] = '0;\n      end\n\n      assign apu_read_regs          = '0;\n      assign apu_read_regs_valid    = '0;\n      assign apu_write_regs         = '0;\n      assign apu_write_regs_valid   = '0;\n      assign apu_waddr              = '0;\n      assign apu_flags              = '0;\n      assign apu_write_regs_o       = '0;\n      assign apu_read_regs_o        = '0;\n      assign apu_write_regs_valid_o = '0;\n      assign apu_read_regs_valid_o  = '0;\n    end\n  endgenerate\n\n  assign apu_perf_dep_o = apu_stall;\n  // stall when we access the CSR after a multicycle APU instruction\n  assign csr_apu_stall  = (csr_access & (apu_en_ex_o & (apu_lat_ex_o[1] == 1'b1) | apu_busy_i));\n\n  /////////////////////////////////////////////////////////\n  //  ____  _____ ____ ___ ____ _____ _____ ____  ____   //\n  // |  _ \\| ____/ ___|_ _/ ___|_   _| ____|  _ \\/ ___|  //\n  // | |_) |  _|| |  _ | |\\___ \\ | | |  _| | |_) \\___ \\  //\n  // |  _ <| |__| |_| || | ___) || | | |___|  _ < ___) | //\n  // |_| \\_\\_____\\____|___|____/ |_| |_____|_| \\_\\____/  //\n  //                                                     //\n  /////////////////////////////////////////////////////////\n\n  cv32e40p_register_file #(\n      .ADDR_WIDTH(6),\n      .DATA_WIDTH(32),\n      .FPU       (FPU),\n      .ZFINX     (ZFINX)\n  ) register_file_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .scan_cg_en_i(scan_cg_en_i),\n\n      // Read port a\n      .raddr_a_i(regfile_addr_ra_id),\n      .rdata_a_o(regfile_data_ra_id),\n\n      // Read port b\n      .raddr_b_i(regfile_addr_rb_id),\n      .rdata_b_o(regfile_data_rb_id),\n\n      // Read port c\n      .raddr_c_i(regfile_addr_rc_id),\n      .rdata_c_o(regfile_data_rc_id),\n\n      // Write port a\n      .waddr_a_i(regfile_waddr_wb_i),\n      .wdata_a_i(regfile_wdata_wb_i),\n      .we_a_i   (regfile_we_wb_power_i),\n\n      // Write port b\n      .waddr_b_i(regfile_alu_waddr_fw_i),\n      .wdata_b_i(regfile_alu_wdata_fw_i),\n      .we_b_i   (regfile_alu_we_fw_power_i)\n  );\n\n\n  ///////////////////////////////////////////////\n  //  ____  _____ ____ ___  ____  _____ ____   //\n  // |  _ \\| ____/ ___/ _ \\|  _ \\| ____|  _ \\  //\n  // | | | |  _|| |  | | | | | | |  _| | |_) | //\n  // | |_| | |__| |__| |_| | |_| | |___|  _ <  //\n  // |____/|_____\\____\\___/|____/|_____|_| \\_\\ //\n  //                                           //\n  ///////////////////////////////////////////////\n\n  cv32e40p_decoder #(\n      .COREV_PULP      (COREV_PULP),\n      .COREV_CLUSTER   (COREV_CLUSTER),\n      .A_EXTENSION     (A_EXTENSION),\n      .FPU             (FPU),\n      .FPU_ADDMUL_LAT  (FPU_ADDMUL_LAT),\n      .FPU_OTHERS_LAT  (FPU_OTHERS_LAT),\n      .ZFINX           (ZFINX),\n      .PULP_SECURE     (PULP_SECURE),\n      .USE_PMP         (USE_PMP),\n      .APU_WOP_CPU     (APU_WOP_CPU),\n      .DEBUG_TRIGGER_EN(DEBUG_TRIGGER_EN)\n  ) decoder_i (\n      // controller related signals\n      .deassert_we_i(deassert_we),\n\n      .illegal_insn_o(illegal_insn_dec),\n      .ebrk_insn_o   (ebrk_insn_dec),\n\n      .mret_insn_o(mret_insn_dec),\n      .uret_insn_o(uret_insn_dec),\n      .dret_insn_o(dret_insn_dec),\n\n      .mret_dec_o(mret_dec),\n      .uret_dec_o(uret_dec),\n      .dret_dec_o(dret_dec),\n\n      .ecall_insn_o(ecall_insn_dec),\n      .wfi_o       (wfi_insn_dec),\n\n      .fencei_insn_o(fencei_insn_dec),\n\n      .rega_used_o(rega_used_dec),\n      .regb_used_o(regb_used_dec),\n      .regc_used_o(regc_used_dec),\n\n      .reg_fp_a_o(regfile_fp_a),\n      .reg_fp_b_o(regfile_fp_b),\n      .reg_fp_c_o(regfile_fp_c),\n      .reg_fp_d_o(regfile_fp_d),\n\n      .bmask_a_mux_o        (bmask_a_mux),\n      .bmask_b_mux_o        (bmask_b_mux),\n      .alu_bmask_a_mux_sel_o(alu_bmask_a_mux_sel),\n      .alu_bmask_b_mux_sel_o(alu_bmask_b_mux_sel),\n\n      // from IF/ID pipeline\n      .instr_rdata_i   (instr),\n      .illegal_c_insn_i(illegal_c_insn_i),\n\n      // ALU signals\n      .alu_en_o              (alu_en),\n      .alu_operator_o        (alu_operator),\n      .alu_op_a_mux_sel_o    (alu_op_a_mux_sel),\n      .alu_op_b_mux_sel_o    (alu_op_b_mux_sel),\n      .alu_op_c_mux_sel_o    (alu_op_c_mux_sel),\n      .alu_vec_o             (alu_vec),\n      .alu_vec_mode_o        (alu_vec_mode),\n      .scalar_replication_o  (scalar_replication),\n      .scalar_replication_c_o(scalar_replication_c),\n      .imm_a_mux_sel_o       (imm_a_mux_sel),\n      .imm_b_mux_sel_o       (imm_b_mux_sel),\n      .regc_mux_o            (regc_mux),\n      .is_clpx_o             (is_clpx),\n      .is_subrot_o           (is_subrot),\n\n      // MUL signals\n      .mult_operator_o   (mult_operator),\n      .mult_int_en_o     (mult_int_en),\n      .mult_sel_subword_o(mult_sel_subword),\n      .mult_signed_mode_o(mult_signed_mode),\n      .mult_imm_mux_o    (mult_imm_mux),\n      .mult_dot_en_o     (mult_dot_en),\n      .mult_dot_signed_o (mult_dot_signed),\n\n      // FPU / APU signals\n      .fs_off_i     (fs_off_i),\n      .frm_i        (frm_i),\n      .fpu_src_fmt_o(fpu_src_fmt),\n      .fpu_dst_fmt_o(fpu_dst_fmt),\n      .fpu_int_fmt_o(fpu_int_fmt),\n      .apu_en_o     (apu_en),\n      .apu_op_o     (apu_op),\n      .apu_lat_o    (apu_lat),\n      .fp_rnd_mode_o(fp_rnd_mode),\n\n      // Register file control signals\n      .regfile_mem_we_o       (regfile_we_id),\n      .regfile_alu_we_o       (regfile_alu_we_id),\n      .regfile_alu_we_dec_o   (regfile_alu_we_dec_id),\n      .regfile_alu_waddr_sel_o(regfile_alu_waddr_mux_sel),\n\n      // CSR control signals\n      .csr_access_o      (csr_access),\n      .csr_status_o      (csr_status),\n      .csr_op_o          (csr_op),\n      .current_priv_lvl_i(current_priv_lvl_i),\n\n      // Data bus interface\n      .data_req_o           (data_req_id),\n      .data_we_o            (data_we_id),\n      .prepost_useincr_o    (prepost_useincr),\n      .data_type_o          (data_type_id),\n      .data_sign_extension_o(data_sign_ext_id),\n      .data_reg_offset_o    (data_reg_offset_id),\n      .data_load_event_o    (data_load_event_id),\n\n      // Atomic memory access\n      .atop_o(atop_id),\n\n      // hwloop signals\n      .hwlp_we_o            (hwlp_we),\n      .hwlp_target_mux_sel_o(hwlp_target_mux_sel),\n      .hwlp_start_mux_sel_o (hwlp_start_mux_sel),\n      .hwlp_cnt_mux_sel_o   (hwlp_cnt_mux_sel),\n\n      // debug mode\n      .debug_mode_i        (debug_mode_o),\n      .debug_wfi_no_sleep_i(debug_wfi_no_sleep),\n\n      // jump/branches\n      .ctrl_transfer_insn_in_dec_o   (ctrl_transfer_insn_in_dec_o),\n      .ctrl_transfer_insn_in_id_o    (ctrl_transfer_insn_in_id),\n      .ctrl_transfer_target_mux_sel_o(ctrl_transfer_target_mux_sel),\n\n      // HPM related control signals\n      .mcounteren_i(mcounteren_i)\n\n  );\n\n  ////////////////////////////////////////////////////////////////////\n  //    ____ ___  _   _ _____ ____   ___  _     _     _____ ____    //\n  //   / ___/ _ \\| \\ | |_   _|  _ \\ / _ \\| |   | |   | ____|  _ \\   //\n  //  | |  | | | |  \\| | | | | |_) | | | | |   | |   |  _| | |_) |  //\n  //  | |__| |_| | |\\  | | | |  _ <| |_| | |___| |___| |___|  _ <   //\n  //   \\____\\___/|_| \\_| |_| |_| \\_\\\\___/|_____|_____|_____|_| \\_\\  //\n  //                                                                //\n  ////////////////////////////////////////////////////////////////////\n\n  cv32e40p_controller #(\n      .COREV_CLUSTER(COREV_CLUSTER),\n      .COREV_PULP   (COREV_PULP),\n      .FPU          (FPU)\n  ) controller_i (\n      .clk          (clk),  // Gated clock\n      .clk_ungated_i(clk_ungated_i),  // Ungated clock\n      .rst_n        (rst_n),\n\n      .fetch_enable_i   (fetch_enable_i),\n      .ctrl_busy_o      (ctrl_busy_o),\n      .is_decoding_o    (is_decoding_o),\n      .is_fetch_failed_i(is_fetch_failed_i),\n\n      // decoder related signals\n      .deassert_we_o(deassert_we),\n\n      .illegal_insn_i(illegal_insn_dec),\n      .ecall_insn_i  (ecall_insn_dec),\n      .mret_insn_i   (mret_insn_dec),\n      .uret_insn_i   (uret_insn_dec),\n\n      .dret_insn_i(dret_insn_dec),\n\n      .mret_dec_i(mret_dec),\n      .uret_dec_i(uret_dec),\n      .dret_dec_i(dret_dec),\n\n\n      .wfi_i        (wfi_insn_dec),\n      .ebrk_insn_i  (ebrk_insn_dec),\n      .fencei_insn_i(fencei_insn_dec),\n      .csr_status_i (csr_status),\n\n      .hwlp_mask_o(hwlp_mask),\n\n      // from IF/ID pipeline\n      .instr_valid_i(instr_valid_i),\n\n      // from prefetcher\n      .instr_req_o(instr_req_o),\n\n      // to prefetcher\n      .pc_set_o       (pc_set_o),\n      .pc_mux_o       (pc_mux_o),\n      .exc_pc_mux_o   (exc_pc_mux_o),\n      .exc_cause_o    (exc_cause_o),\n      .trap_addr_mux_o(trap_addr_mux_o),\n\n      // HWLoop signls\n      .pc_id_i(pc_id_i),\n\n      .hwlp_start_addr_i(hwlp_start_o),\n      .hwlp_end_addr_i  (hwlp_end_o),\n      .hwlp_counter_i   (hwlp_cnt_o),\n      .hwlp_dec_cnt_o   (hwlp_dec_cnt),\n\n      .hwlp_jump_o     (hwlp_jump_o),\n      .hwlp_targ_addr_o(hwlp_target_o),\n\n      // LSU\n      .data_req_ex_i    (data_req_ex_o),\n      .data_we_ex_i     (data_we_ex_o),\n      .data_misaligned_i(data_misaligned_i),\n      .data_load_event_i(data_load_event_id),\n      .data_err_i       (data_err_i),\n      .data_err_ack_o   (data_err_ack_o),\n\n      // ALU\n      .mult_multicycle_i(mult_multicycle_i),\n\n      // APU\n      .apu_en_i               (apu_en),\n      .apu_read_dep_i         (apu_read_dep_i),\n      .apu_read_dep_for_jalr_i(apu_read_dep_for_jalr_i),\n      .apu_write_dep_i        (apu_write_dep_i),\n\n      .apu_stall_o(apu_stall),\n\n      // jump/branch control\n      .branch_taken_ex_i          (branch_taken_ex),\n      .ctrl_transfer_insn_in_id_i (ctrl_transfer_insn_in_id),\n      .ctrl_transfer_insn_in_dec_i(ctrl_transfer_insn_in_dec_o),\n\n      // Interrupt signals\n      .irq_wu_ctrl_i     (irq_wu_ctrl),\n      .irq_req_ctrl_i    (irq_req_ctrl),\n      .irq_sec_ctrl_i    (irq_sec_ctrl),\n      .irq_id_ctrl_i     (irq_id_ctrl),\n      .current_priv_lvl_i(current_priv_lvl_i),\n      .irq_ack_o         (irq_ack_o),\n      .irq_id_o          (irq_id_o),\n\n      // Debug Signal\n      .debug_mode_o          (debug_mode_o),\n      .debug_cause_o         (debug_cause_o),\n      .debug_csr_save_o      (debug_csr_save_o),\n      .debug_req_i           (debug_req_i),\n      .debug_single_step_i   (debug_single_step_i),\n      .debug_ebreakm_i       (debug_ebreakm_i),\n      .debug_ebreaku_i       (debug_ebreaku_i),\n      .trigger_match_i       (trigger_match_i),\n      .debug_p_elw_no_sleep_o(debug_p_elw_no_sleep_o),\n      .debug_wfi_no_sleep_o  (debug_wfi_no_sleep),\n      .debug_havereset_o     (debug_havereset_o),\n      .debug_running_o       (debug_running_o),\n      .debug_halted_o        (debug_halted_o),\n\n      // Wakeup Signal\n      .wake_from_sleep_o(wake_from_sleep_o),\n\n      // CSR Controller Signals\n      .csr_save_cause_o     (csr_save_cause_o),\n      .csr_cause_o          (csr_cause_o),\n      .csr_save_if_o        (csr_save_if_o),\n      .csr_save_id_o        (csr_save_id_o),\n      .csr_save_ex_o        (csr_save_ex_o),\n      .csr_restore_mret_id_o(csr_restore_mret_id_o),\n      .csr_restore_uret_id_o(csr_restore_uret_id_o),\n\n      .csr_restore_dret_id_o(csr_restore_dret_id_o),\n\n      .csr_irq_sec_o(csr_irq_sec_o),\n\n      // Write targets from ID\n      .regfile_we_id_i       (regfile_alu_we_dec_id),\n      .regfile_alu_waddr_id_i(regfile_alu_waddr_id),\n\n      // Forwarding signals from regfile\n      .regfile_we_ex_i   (regfile_we_ex_o),\n      .regfile_waddr_ex_i(regfile_waddr_ex_o),\n      .regfile_we_wb_i   (regfile_we_wb_i),\n\n      // regfile port 2\n      .regfile_alu_we_fw_i(regfile_alu_we_fw_i),\n\n      // Forwarding detection signals\n      .reg_d_ex_is_reg_a_i (reg_d_ex_is_reg_a_id),\n      .reg_d_ex_is_reg_b_i (reg_d_ex_is_reg_b_id),\n      .reg_d_ex_is_reg_c_i (reg_d_ex_is_reg_c_id),\n      .reg_d_wb_is_reg_a_i (reg_d_wb_is_reg_a_id),\n      .reg_d_wb_is_reg_b_i (reg_d_wb_is_reg_b_id),\n      .reg_d_wb_is_reg_c_i (reg_d_wb_is_reg_c_id),\n      .reg_d_alu_is_reg_a_i(reg_d_alu_is_reg_a_id),\n      .reg_d_alu_is_reg_b_i(reg_d_alu_is_reg_b_id),\n      .reg_d_alu_is_reg_c_i(reg_d_alu_is_reg_c_id),\n\n      // Forwarding signals\n      .operand_a_fw_mux_sel_o(operand_a_fw_mux_sel),\n      .operand_b_fw_mux_sel_o(operand_b_fw_mux_sel),\n      .operand_c_fw_mux_sel_o(operand_c_fw_mux_sel),\n\n      // Stall signals\n      .halt_if_o(halt_if),\n      .halt_id_o(halt_id),\n\n      .misaligned_stall_o(misaligned_stall),\n      .jr_stall_o        (jr_stall),\n      .load_stall_o      (load_stall),\n\n      .id_ready_i(id_ready_o),\n      .id_valid_i(id_valid_o),\n\n      .ex_valid_i(ex_valid_i),\n\n      .wb_ready_i(wb_ready_i),\n\n      // Performance Counters\n      .perf_pipeline_stall_o(perf_pipeline_stall)\n  );\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //  _____      _       _____             _             _ _            //\n  // |_   _|    | |     /  __ \\           | |           | | |           //\n  //   | | _ __ | |_    | /  \\/ ___  _ __ | |_ _ __ ___ | | | ___ _ __  //\n  //   | || '_ \\| __|   | |    / _ \\| '_ \\| __| '__/ _ \\| | |/ _ \\ '__| //\n  //  _| || | | | |_ _  | \\__/\\ (_) | | | | |_| | | (_) | | |  __/ |    //\n  //  \\___/_| |_|\\__(_)  \\____/\\___/|_| |_|\\__|_|  \\___/|_|_|\\___|_|    //\n  //                                                                    //\n  ////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_int_controller #(\n      .PULP_SECURE(PULP_SECURE)\n  ) int_controller_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      // External interrupt lines\n      .irq_i    (irq_i),\n      .irq_sec_i(irq_sec_i),\n\n      // To cv32e40p_controller\n      .irq_req_ctrl_o(irq_req_ctrl),\n      .irq_sec_ctrl_o(irq_sec_ctrl),\n      .irq_id_ctrl_o (irq_id_ctrl),\n      .irq_wu_ctrl_o (irq_wu_ctrl),\n\n      // To/from with cv32e40p_cs_registers\n      .mie_bypass_i      (mie_bypass_i),\n      .mip_o             (mip_o),\n      .m_ie_i            (m_irq_enable_i),\n      .u_ie_i            (u_irq_enable_i),\n      .current_priv_lvl_i(current_priv_lvl_i)\n  );\n\n  generate\n    if (COREV_PULP) begin : gen_hwloop_regs\n\n      ///////////////////////////////////////////////\n      //  _   ___        ___     ___   ___  ____   //\n      // | | | \\ \\      / / |   / _ \\ / _ \\|  _ \\  //\n      // | |_| |\\ \\ /\\ / /| |  | | | | | | | |_) | //\n      // |  _  | \\ V  V / | |__| |_| | |_| |  __/  //\n      // |_| |_|  \\_/\\_/  |_____\\___/ \\___/|_|     //\n      //                                           //\n      ///////////////////////////////////////////////\n\n\n      cv32e40p_hwloop_regs #(\n          .N_REGS(N_HWLP)\n      ) hwloop_regs_i (\n          .clk  (clk),\n          .rst_n(rst_n),\n\n          // from ID\n          .hwlp_start_data_i(hwlp_start),\n          .hwlp_end_data_i  (hwlp_end),\n          .hwlp_cnt_data_i  (hwlp_cnt),\n          .hwlp_we_i        (hwlp_we_masked),\n          .hwlp_regid_i     (hwlp_regid),\n\n          // from controller\n          .valid_i(hwlp_valid),\n\n          // to hwloop controller\n          .hwlp_start_addr_o(hwlp_start_o),\n          .hwlp_end_addr_o  (hwlp_end_o),\n          .hwlp_counter_o   (hwlp_cnt_o),\n\n          // from hwloop controller\n          .hwlp_dec_cnt_i(hwlp_dec_cnt)\n      );\n\n      assign hwlp_valid = instr_valid_i & clear_instr_valid_o;\n\n      // hwloop register id\n      assign hwlp_regid = instr[7];  // rd contains hwloop register id\n\n      // hwloop target mux\n      always_comb begin\n        case (hwlp_target_mux_sel)\n          2'b00:   hwlp_end = pc_id_i + {imm_iz_type[29:0], 2'b0};\n          2'b01:   hwlp_end = pc_id_i + {imm_z_type[29:0], 2'b0};\n          2'b10:   hwlp_end = operand_a_fw_id;\n          default: hwlp_end = operand_a_fw_id;\n        endcase\n      end\n\n      // hwloop start mux\n      always_comb begin\n        case (hwlp_start_mux_sel)\n          2'b00:   hwlp_start = hwlp_end;  // for PC + I imm\n          2'b01:   hwlp_start = pc_id_i + 4;  // for next PC\n          2'b10:   hwlp_start = operand_a_fw_id;\n          default: hwlp_start = operand_a_fw_id;\n        endcase\n      end\n\n      // hwloop cnt mux\n      always_comb begin : hwlp_cnt_mux\n        case (hwlp_cnt_mux_sel)\n          1'b0: hwlp_cnt = imm_iz_type;\n          1'b1: hwlp_cnt = operand_a_fw_id;\n        endcase\n        ;\n      end\n\n      /*\n        when hwlp_mask is 1, the controller is about to take an interrupt\n        the xEPC is going to have the hwloop instruction PC, therefore, do not update the\n        hwloop registers to make clear that the instruction hasn't been executed.\n        Although it may not be a HW bugs causing uninteded behaviours,\n        it helps verifications processes when checking the hwloop regs\n      */\n      assign hwlp_we_masked = hwlp_we & ~{3{hwlp_mask}} & {3{id_ready_o}};\n\n    end else begin : gen_no_hwloop_regs\n\n      assign hwlp_start_o   = 'b0;\n      assign hwlp_end_o     = 'b0;\n      assign hwlp_cnt_o     = 'b0;\n      assign hwlp_valid     = 'b0;\n      assign hwlp_we_masked = 'b0;\n      assign hwlp_start     = 'b0;\n      assign hwlp_end       = 'b0;\n      assign hwlp_cnt       = 'b0;\n      assign hwlp_regid     = 'b0;\n\n    end\n  endgenerate\n\n\n  /////////////////////////////////////////////////////////////////////////////////\n  //   ___ ____        _______  __  ____ ___ ____  _____ _     ___ _   _ _____   //\n  //  |_ _|  _ \\      | ____\\ \\/ / |  _ \\_ _|  _ \\| ____| |   |_ _| \\ | | ____|  //\n  //   | || | | |_____|  _|  \\  /  | |_) | || |_) |  _| | |    | ||  \\| |  _|    //\n  //   | || |_| |_____| |___ /  \\  |  __/| ||  __/| |___| |___ | || |\\  | |___   //\n  //  |___|____/      |_____/_/\\_\\ |_|  |___|_|   |_____|_____|___|_| \\_|_____|  //\n  //                                                                             //\n  /////////////////////////////////////////////////////////////////////////////////\n\n  always_ff @(posedge clk, negedge rst_n) begin : ID_EX_PIPE_REGISTERS\n    if (rst_n == 1'b0) begin\n      alu_en_ex_o            <= '0;\n      alu_operator_ex_o      <= ALU_SLTU;\n      alu_operand_a_ex_o     <= '0;\n      alu_operand_b_ex_o     <= '0;\n      alu_operand_c_ex_o     <= '0;\n      bmask_a_ex_o           <= '0;\n      bmask_b_ex_o           <= '0;\n      imm_vec_ext_ex_o       <= '0;\n      alu_vec_mode_ex_o      <= '0;\n      alu_clpx_shift_ex_o    <= 2'b0;\n      alu_is_clpx_ex_o       <= 1'b0;\n      alu_is_subrot_ex_o     <= 1'b0;\n\n      mult_operator_ex_o     <= MUL_MAC32;\n      mult_operand_a_ex_o    <= '0;\n      mult_operand_b_ex_o    <= '0;\n      mult_operand_c_ex_o    <= '0;\n      mult_en_ex_o           <= 1'b0;\n      mult_sel_subword_ex_o  <= 1'b0;\n      mult_signed_mode_ex_o  <= 2'b00;\n      mult_imm_ex_o          <= '0;\n\n      mult_dot_op_a_ex_o     <= '0;\n      mult_dot_op_b_ex_o     <= '0;\n      mult_dot_op_c_ex_o     <= '0;\n      mult_dot_signed_ex_o   <= '0;\n      mult_is_clpx_ex_o      <= 1'b0;\n      mult_clpx_shift_ex_o   <= 2'b0;\n      mult_clpx_img_ex_o     <= 1'b0;\n\n      apu_en_ex_o            <= '0;\n      apu_op_ex_o            <= '0;\n      apu_lat_ex_o           <= '0;\n      apu_operands_ex_o[0]   <= '0;\n      apu_operands_ex_o[1]   <= '0;\n      apu_operands_ex_o[2]   <= '0;\n      apu_flags_ex_o         <= '0;\n      apu_waddr_ex_o         <= '0;\n\n\n      regfile_waddr_ex_o     <= 6'b0;\n      regfile_we_ex_o        <= 1'b0;\n\n      regfile_alu_waddr_ex_o <= 6'b0;\n      regfile_alu_we_ex_o    <= 1'b0;\n      prepost_useincr_ex_o   <= 1'b0;\n\n      csr_access_ex_o        <= 1'b0;\n      csr_op_ex_o            <= CSR_OP_READ;\n\n      data_we_ex_o           <= 1'b0;\n      data_type_ex_o         <= 2'b0;\n      data_sign_ext_ex_o     <= 2'b0;\n      data_reg_offset_ex_o   <= 2'b0;\n      data_req_ex_o          <= 1'b0;\n      data_load_event_ex_o   <= 1'b0;\n      atop_ex_o              <= 5'b0;\n\n      data_misaligned_ex_o   <= 1'b0;\n\n      pc_ex_o                <= '0;\n\n      branch_in_ex_o         <= 1'b0;\n\n    end else if (data_misaligned_i) begin\n      // misaligned data access case\n      if (ex_ready_i) begin  // misaligned access case, only unstall alu operands\n\n        // if we are using post increments, then we have to use the\n        // original value of the register for the second memory access\n        // => keep it stalled\n        if (prepost_useincr_ex_o == 1'b1) begin\n          alu_operand_a_ex_o <= operand_a_fw_id;\n        end\n\n        alu_operand_b_ex_o   <= 32'h4;\n        regfile_alu_we_ex_o  <= 1'b0;\n        prepost_useincr_ex_o <= 1'b1;\n\n        data_misaligned_ex_o <= 1'b1;\n      end\n    end else if (mult_multicycle_i) begin\n      mult_operand_c_ex_o <= operand_c_fw_id;\n    end else begin\n      // normal pipeline unstall case\n\n      if (id_valid_o) begin  // unstall the whole pipeline\n        alu_en_ex_o <= alu_en;\n        if (alu_en) begin\n          alu_operator_ex_o  <= alu_operator;\n          alu_operand_a_ex_o <= alu_operand_a;\n          if (alu_op_b_mux_sel == OP_B_REGB_OR_FWD && (alu_operator == ALU_CLIP || alu_operator == ALU_CLIPU)) begin\n            alu_operand_b_ex_o <= {1'b0, alu_operand_b[30:0]};\n          end else begin\n            alu_operand_b_ex_o <= alu_operand_b;\n          end\n          alu_operand_c_ex_o  <= alu_operand_c;\n          bmask_a_ex_o        <= bmask_a_id;\n          bmask_b_ex_o        <= bmask_b_id;\n          imm_vec_ext_ex_o    <= imm_vec_ext_id;\n          alu_vec_mode_ex_o   <= alu_vec_mode;\n          alu_is_clpx_ex_o    <= is_clpx;\n          alu_clpx_shift_ex_o <= instr[14:13];\n          alu_is_subrot_ex_o  <= is_subrot;\n        end\n\n        mult_en_ex_o <= mult_en;\n        if (mult_int_en) begin\n          mult_operator_ex_o    <= mult_operator;\n          mult_sel_subword_ex_o <= mult_sel_subword;\n          mult_signed_mode_ex_o <= mult_signed_mode;\n          mult_operand_a_ex_o   <= alu_operand_a;\n          mult_operand_b_ex_o   <= alu_operand_b;\n          mult_operand_c_ex_o   <= alu_operand_c;\n          mult_imm_ex_o         <= mult_imm_id;\n        end\n        if (mult_dot_en) begin\n          mult_operator_ex_o   <= mult_operator;\n          mult_dot_signed_ex_o <= mult_dot_signed;\n          mult_dot_op_a_ex_o   <= alu_operand_a;\n          mult_dot_op_b_ex_o   <= alu_operand_b;\n          mult_dot_op_c_ex_o   <= alu_operand_c;\n          mult_is_clpx_ex_o    <= is_clpx;\n          mult_clpx_shift_ex_o <= instr[14:13];\n          mult_clpx_img_ex_o   <= instr[25];\n        end\n\n        // APU pipeline\n        apu_en_ex_o <= apu_en;\n        if (apu_en) begin\n          apu_op_ex_o       <= apu_op;\n          apu_lat_ex_o      <= apu_lat;\n          apu_operands_ex_o <= apu_operands;\n          apu_flags_ex_o    <= apu_flags;\n          apu_waddr_ex_o    <= apu_waddr;\n        end\n\n        regfile_we_ex_o <= regfile_we_id;\n        if (regfile_we_id) begin\n          regfile_waddr_ex_o <= regfile_waddr_id;\n        end\n\n        regfile_alu_we_ex_o <= regfile_alu_we_id;\n        if (regfile_alu_we_id) begin\n          regfile_alu_waddr_ex_o <= regfile_alu_waddr_id;\n        end\n\n        prepost_useincr_ex_o <= prepost_useincr;\n\n        csr_access_ex_o      <= csr_access;\n        csr_op_ex_o          <= csr_op;\n\n        data_req_ex_o        <= data_req_id;\n        if (data_req_id) begin  // only needed for LSU when there is an active request\n          data_we_ex_o         <= data_we_id;\n          data_type_ex_o       <= data_type_id;\n          data_sign_ext_ex_o   <= data_sign_ext_id;\n          data_reg_offset_ex_o <= data_reg_offset_id;\n          data_load_event_ex_o <= data_load_event_id;\n          atop_ex_o            <= atop_id;\n        end else begin\n          data_load_event_ex_o <= 1'b0;\n        end\n\n        data_misaligned_ex_o <= 1'b0;\n\n        if ((ctrl_transfer_insn_in_id == BRANCH_COND) || data_req_id) begin\n          pc_ex_o <= pc_id_i;\n        end\n\n        branch_in_ex_o <= ctrl_transfer_insn_in_id == BRANCH_COND;\n      end else if (ex_ready_i) begin\n        // EX stage is ready but we don't have a new instruction for it,\n        // so we set all write enables to 0, but unstall the pipe\n\n        regfile_we_ex_o      <= 1'b0;\n\n        regfile_alu_we_ex_o  <= 1'b0;\n\n        csr_op_ex_o          <= CSR_OP_READ;\n\n        data_req_ex_o        <= 1'b0;\n\n        data_load_event_ex_o <= 1'b0;\n\n        data_misaligned_ex_o <= 1'b0;\n\n        branch_in_ex_o       <= 1'b0;\n\n        apu_en_ex_o          <= 1'b0;\n\n        alu_operator_ex_o    <= ALU_SLTU;\n\n        mult_en_ex_o         <= 1'b0;\n\n        alu_en_ex_o          <= 1'b1;\n\n      end else if (csr_access_ex_o) begin\n        //In the EX stage there was a CSR access, to avoid multiple\n        //writes to the RF, disable regfile_alu_we_ex_o.\n        //Not doing it can overwrite the RF file with the currennt CSR value rather than the old one\n        regfile_alu_we_ex_o <= 1'b0;\n      end\n    end\n  end\n\n  // Performance Counter Events\n\n  // Illegal/ebreak/ecall are never counted as retired instructions. Note that actually issued instructions\n  // are being counted; the manner in which CSR instructions access the performance counters guarantees\n  // that this count will correspond to the retired isntructions count.\n  assign minstret = id_valid_o && is_decoding_o && !(illegal_insn_dec || ebrk_insn_dec || ecall_insn_dec);\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      id_valid_q               <= 1'b0;\n      mhpmevent_minstret_o     <= 1'b0;\n      mhpmevent_load_o         <= 1'b0;\n      mhpmevent_store_o        <= 1'b0;\n      mhpmevent_jump_o         <= 1'b0;\n      mhpmevent_branch_o       <= 1'b0;\n      mhpmevent_compressed_o   <= 1'b0;\n      mhpmevent_branch_taken_o <= 1'b0;\n      mhpmevent_jr_stall_o     <= 1'b0;\n      mhpmevent_imiss_o        <= 1'b0;\n      mhpmevent_ld_stall_o     <= 1'b0;\n      mhpmevent_pipe_stall_o   <= 1'b0;\n    end else begin\n      // Helper signal\n      id_valid_q <= id_valid_o;\n      // ID stage counts\n      mhpmevent_minstret_o <= minstret;\n      mhpmevent_load_o <= minstret && data_req_id && !data_we_id;\n      mhpmevent_store_o <= minstret && data_req_id && data_we_id;\n      mhpmevent_jump_o           <= minstret && ((ctrl_transfer_insn_in_id == BRANCH_JAL) || (ctrl_transfer_insn_in_id == BRANCH_JALR));\n      mhpmevent_branch_o <= minstret && (ctrl_transfer_insn_in_id == BRANCH_COND);\n      mhpmevent_compressed_o <= minstret && is_compressed_i;\n      // EX stage count\n      mhpmevent_branch_taken_o <= mhpmevent_branch_o && branch_decision_i;\n      // IF stage count\n      mhpmevent_imiss_o <= perf_imiss_i;\n      // Jump-register-hazard; do not count stall on flushed instructions (id_valid_q used to only count first cycle)\n      mhpmevent_jr_stall_o <= jr_stall && !halt_id && id_valid_q;\n      // Load-use-hazard; do not count stall on flushed instructions (id_valid_q used to only count first cycle)\n      mhpmevent_ld_stall_o <= load_stall && !halt_id && id_valid_q;\n      // ELW\n      mhpmevent_pipe_stall_o <= perf_pipeline_stall;\n    end\n  end\n\n  // stall control\n  assign id_ready_o = ((~misaligned_stall) & (~jr_stall) & (~load_stall) & (~apu_stall) & (~csr_apu_stall) & ex_ready_i);\n  assign id_valid_o = (~halt_id) & id_ready_o;\n  assign halt_if_o = halt_if;\n\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n`ifdef CV32E40P_ASSERT_ON\n\n  always_comb begin\n    if (FPU == 1) begin\n      assert (APU_NDSFLAGS_CPU >= C_RM+2*cv32e40p_fpu_pkg::FP_FORMAT_BITS+cv32e40p_fpu_pkg::INT_FORMAT_BITS)\n      else\n        $error(\"[apu] APU_NDSFLAGS_CPU APU flagbits is smaller than %0d\",\n               C_RM + 2 * cv32e40p_fpu_pkg::FP_FORMAT_BITS + cv32e40p_fpu_pkg::INT_FORMAT_BITS);\n    end\n  end\n\n  // make sure that branch decision is valid when jumping\n  a_br_decision :\n  assert property (@(posedge clk) (branch_in_ex_o) |-> (branch_decision_i !== 1'bx))\n  else begin\n    $warning(\"%t, Branch decision is X in module %m\", $time);\n    $stop;\n  end\n\n  // the instruction delivered to the ID stage should always be valid\n  a_valid_instr :\n  assert property (@(posedge clk) (instr_valid_i & (~illegal_c_insn_i)) |-> (!$isunknown(instr)))\n  else $warning(\"%t, Instruction is valid, but has at least one X\", $time);\n\n  // Check that instruction after taken branch is flushed (more should actually be flushed, but that is not checked here)\n  // and that EX stage is ready to receive flushed instruction immediately\n  property p_branch_taken_ex;\n    @(posedge clk) disable iff (!rst_n) (branch_taken_ex == 1'b1) |-> ((ex_ready_i == 1'b1) &&\n                                                                          (alu_en == 1'b0) && (apu_en == 1'b0) &&\n                                                                          (mult_en == 1'b0) && (mult_int_en == 1'b0) &&\n                                                                          (mult_dot_en == 1'b0) && (regfile_we_id == 1'b0) &&\n                                                                          (regfile_alu_we_id == 1'b0) && (data_req_id == 1'b0));\n  endproperty\n\n  a_branch_taken_ex :\n  assert property (p_branch_taken_ex);\n\n  // Check that if IRQ PC update does not coincide with IRQ related CSR write\n  // MIE is excluded from the check because it has a bypass.\n  property p_irq_csr;\n    @(posedge clk) disable iff (!rst_n) (pc_set_o && (pc_mux_o == PC_EXCEPTION) && ((exc_pc_mux_o == EXC_PC_EXCEPTION) || (exc_pc_mux_o == EXC_PC_IRQ)) &&\n                                            csr_access_ex_o && (csr_op_ex_o != CSR_OP_READ)) |->\n                                           ((alu_operand_b_ex_o[11:0] != CSR_MSTATUS) && (alu_operand_b_ex_o[11:0] != CSR_USTATUS) &&\n                                            (alu_operand_b_ex_o[11:0] != CSR_MEPC) && (alu_operand_b_ex_o[11:0] != CSR_UEPC) &&\n                                            (alu_operand_b_ex_o[11:0] != CSR_MCAUSE) && (alu_operand_b_ex_o[11:0] != CSR_UCAUSE) &&\n                                            (alu_operand_b_ex_o[11:0] != CSR_MTVEC) && (alu_operand_b_ex_o[11:0] != CSR_UTVEC));\n  endproperty\n\n  a_irq_csr :\n  assert property (p_irq_csr);\n\n  // Check that xret does not coincide with CSR write (to avoid using wrong return address)\n  // This check is more strict than really needed; a CSR instruction would be allowed in EX as long\n  // as its write action happens before the xret CSR usage\n  property p_xret_csr;\n    @(posedge clk) disable iff (!rst_n) (pc_set_o && ((pc_mux_o == PC_MRET) || (pc_mux_o == PC_URET) || (pc_mux_o == PC_DRET))) |->\n                                           (!(csr_access_ex_o && (csr_op_ex_o != CSR_OP_READ)));\n  endproperty\n\n  a_xret_csr :\n  assert property (p_xret_csr);\n\n  generate\n    if (!A_EXTENSION) begin : gen_no_a_extension_assertions\n\n      // Check that A extension opcodes are decoded as illegal when A extension not enabled\n      property p_illegal_0;\n        @(posedge clk) disable iff (!rst_n) (instr[6:0] == OPCODE_AMO) |-> (illegal_insn_dec == 'b1);\n      endproperty\n\n      a_illegal_0 :\n      assert property (p_illegal_0);\n\n    end\n  endgenerate\n\n  generate\n    if (!COREV_PULP) begin : gen_no_pulp_xpulp_assertions\n\n      // Check that PULP extension opcodes are decoded as illegal when PULP extension is not enabled\n      property p_illegal_1;\n        @(posedge clk) disable iff (!rst_n) ((instr[6:0] == OPCODE_CUSTOM_0) || (instr[6:0] == OPCODE_CUSTOM_1) ||\n                                             (instr[6:0] == OPCODE_CUSTOM_2) || (instr[6:0] == OPCODE_CUSTOM_3))\n                                            |-> (illegal_insn_dec == 'b1);\n      endproperty\n\n      a_illegal_1 :\n      assert property (p_illegal_1);\n\n      // Check that certain ALU operations are not used when PULP extension is not enabled\n      property p_alu_op;\n        @(posedge clk) disable iff (!rst_n) (1'b1) |-> ( (alu_operator != ALU_ADDU ) && (alu_operator != ALU_SUBU ) &&\n                                                           (alu_operator != ALU_ADDR ) && (alu_operator != ALU_SUBR ) &&\n                                                           (alu_operator != ALU_ADDUR) && (alu_operator != ALU_SUBUR) &&\n                                                           (alu_operator != ALU_ROR) && (alu_operator != ALU_BEXT) &&\n                                                           (alu_operator != ALU_BEXTU) && (alu_operator != ALU_BINS) &&\n                                                           (alu_operator != ALU_BCLR) && (alu_operator != ALU_BSET) &&\n                                                           (alu_operator != ALU_BREV) && (alu_operator != ALU_FF1) &&\n                                                           (alu_operator != ALU_FL1) && (alu_operator != ALU_CNT) &&\n                                                           (alu_operator != ALU_CLB) && (alu_operator != ALU_EXTS) &&\n                                                           (alu_operator != ALU_EXT) && (alu_operator != ALU_LES) &&\n                                                           (alu_operator != ALU_LEU) && (alu_operator != ALU_GTS) &&\n                                                           (alu_operator != ALU_GTU) && (alu_operator != ALU_SLETS) &&\n                                                           (alu_operator != ALU_SLETU) && (alu_operator != ALU_ABS) &&\n                                                           (alu_operator != ALU_CLIP) && (alu_operator != ALU_CLIPU) &&\n                                                           (alu_operator != ALU_INS) && (alu_operator != ALU_MIN) &&\n                                                           (alu_operator != ALU_MINU) && (alu_operator != ALU_MAX) &&\n                                                           (alu_operator != ALU_MAXU) && (alu_operator != ALU_SHUF) &&\n                                                           (alu_operator != ALU_SHUF2) && (alu_operator != ALU_PCKLO) &&\n                                                           (alu_operator != ALU_PCKHI) );\n      endproperty\n\n      a_alu_op :\n      assert property (p_alu_op);\n\n      // Check that certain vector modes are not used when PULP extension is not enabled\n      property p_vector_mode;\n        @(posedge clk) disable iff (!rst_n) (1'b1) |-> ( (alu_vec_mode != VEC_MODE8 ) && (alu_vec_mode != VEC_MODE16 ) );\n      endproperty\n\n      a_vector_mode :\n      assert property (p_vector_mode);\n\n      // Check that certain multiplier operations are not used when PULP extension is not enabled\n      property p_mul_op;\n        @(posedge clk) disable iff (!rst_n) (mult_int_en == 1'b1) |-> ( (mult_operator != MUL_MSU32) && (mult_operator != MUL_I) &&\n                                                                         (mult_operator != MUL_IR) && (mult_operator != MUL_DOT8) &&\n                                                                         (mult_operator != MUL_DOT16) );\n      endproperty\n\n      a_mul_op :\n      assert property (p_mul_op);\n\n    end\n  endgenerate\n\n  // Check that illegal instruction has no other side effects\n  property p_illegal_2;\n    @(posedge clk) disable iff (!rst_n) (illegal_insn_dec == 1'b1) |-> !(ebrk_insn_dec || mret_insn_dec || uret_insn_dec || dret_insn_dec ||\n                                                                            ecall_insn_dec || wfi_insn_dec || fencei_insn_dec ||\n                                                                            alu_en || mult_int_en || mult_dot_en || apu_en ||\n                                                                            regfile_we_id || regfile_alu_we_id ||\n                                                                            csr_op != CSR_OP_READ || data_req_id);\n  endproperty\n\n  a_illegal_2 :\n  assert property (p_illegal_2);\n\n`endif\n\nendmodule  // cv32e40p_id_stage\n","lang":"verilog"};
processSrcData(g_data);