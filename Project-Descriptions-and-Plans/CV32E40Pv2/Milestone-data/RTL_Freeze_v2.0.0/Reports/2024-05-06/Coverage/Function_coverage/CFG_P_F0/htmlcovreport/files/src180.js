var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/env/uvme/cov/uvme_rv32x_hwloop_covg.sv","src":"///////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2023 OpenHW Group\n// Copyright 2023 Dolphin Design\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://solderpad.org/licenses/\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier:Apache-2.0 WITH SHL-2.0\n//*******************************************************************************************************************************************\n\n// Note: \n// 1) This coverage model complements Imperas coverage XPULPV2 with addtional coverage collection related to hwloops\n// 2) It uses uvmt_cv32e40p_rvvi_if\n// 3) Has covergroup for hwloops csr setup registers\n// 4) Has covergroup for hwloops features and events within hwloops such as exception, irq and debug entry (debug covers haltreq, trigger, ebreakm, step)\n// 5) Improvement[Optional]: hwloop_stat_sub for handle (irq/debug) implementation\n\n`ifndef UVME_RV32X_HWLOOP_COVG\n`define UVME_RV32X_HWLOOP_COVG\n\nclass uvme_rv32x_hwloop_covg # (\n  parameter int ILEN    = 32,\n  parameter int XLEN    = 32\n) extends uvm_component;\n\n  localparam SKIP_RVVI_INIT_VALID_CNT = 1;\n  localparam HWLOOP_NB = 2;\n  localparam CSR_LPSTART0_ADDR = 32'hCC0;\n  localparam CSR_LPEND0_ADDR   = 32'hCC1;\n  localparam CSR_LPCOUNT0_ADDR = 32'hCC2;\n  localparam INSTR_CBREAK      = 32'h9002;\n  localparam INSN_ILLEGAL      = 32'hFFFFFFFF; // user-defined for any illegal insn that leads to illegal exception\n  localparam INSN_EBREAKM      = 32'hFFFFFFFE; // user-defined\n\n  typedef enum bit [1:0] {NULL_TYPE=0, SINGLE, NESTED}          hwloop_type_t;\n  typedef enum bit [1:0] {NULL_SETUP=0, SHORT, LONG}            hwloop_setup_t;\n  typedef enum int {EXCP_EBREAK=0, EXCP_ECALL, EXCP_ILLEGAL, \n                    IS_IRQ, DBG_HALTREQ, DBG_EBREAKM, DBG_TRIG, \n                    DBG_STEP, MC_INSN, TOTAL_EVENT=9}           hwloop_evt_t;\n  typedef enum int {LOC_LPSTART=0, LOC_LPSTART_P4, \n                    LOC_LPEND, LOC_LPEND_M4, \n                    LOC_OTHERS, TOTAL_LOC=5}                    hwloop_evt_loc_t;\n\n  typedef struct {\n    bit [31:0] lp_start     [HWLOOP_NB];\n    bit [31:0] lp_end       [HWLOOP_NB];\n    bit [31:0] lp_count     [HWLOOP_NB];\n    bit        lp_start_wb  [HWLOOP_NB];\n    bit        lp_end_wb    [HWLOOP_NB];\n    bit        lp_count_wb  [HWLOOP_NB];\n  } s_csr_hwloop;\n  typedef struct {\n    hwloop_type_t         hwloop_type;\n    hwloop_setup_t        hwloop_setup            [HWLOOP_NB];\n    s_csr_hwloop          hwloop_csr;\n    bit                   sample_hwloop_csr_done  [HWLOOP_NB];\n    bit                   execute_instr_in_hwloop [HWLOOP_NB];\n    int                   track_lp_cnt            [HWLOOP_NB];\n    int unsigned          dbg_haltreq_cnt         [HWLOOP_NB];\n    int unsigned          dbg_ebreakm_cnt         [HWLOOP_NB];\n    int unsigned          dbg_trigger_cnt         [HWLOOP_NB];\n    int unsigned          dbg_step_cnt            [HWLOOP_NB];\n    int unsigned          excp_ebreak_cnt         [HWLOOP_NB];\n    int unsigned          excp_ecall_cnt          [HWLOOP_NB];\n    int unsigned          excp_illegal_cnt        [HWLOOP_NB];\n  } s_hwloop_stat;\n  typedef struct {\n    bit               en_cov_irq                  ;\n    bit               en_cov_dbg_haltreq          ;\n    bit               en_cov_dbg_ebreakm          ;\n    bit               en_cov_dbg_trigger          ;\n    bit               en_cov_dbg_step_cnt         ;\n    bit               en_cov_dbg_step_cnt_loc     ;\n    bit               en_cov_excp_ebreak          ;\n    bit               en_cov_excp_ecall           ;\n    bit               en_cov_excp_illegal         ;\n    bit               en_cov_mc_insn              ;\n    bit               en_cov_insn                 ;\n    bit               en_cov_event_loc            ;\n  } s_hwloop_cov;\n\n  // PROPERTIES - START\n\n  `define DEF_LOCAL_VARS(TYPE) \\\n  local s_csr_hwloop        csr_hwloop_``TYPE                 = '{default:0}; \\\n  local s_hwloop_stat       hwloop_stat_``TYPE                = '{default:0, hwloop_type:NULL_TYPE, hwloop_setup:'{default:NULL_SETUP}}; \\\n  local logic [31:0]        prev_pc_rdata_``TYPE              = '{default:0}; \\\n  local hwloop_evt_loc_t    hwloop_evt_loc_``TYPE             [HWLOOP_NB][hwloop_evt_t][$]; \\\n  local bit [(ILEN-1):0]    insn_list_in_hwloop_``TYPE        [HWLOOP_NB][$]; \\\n  local bit [(ILEN-1):0]    mc_insn_list_in_hwloop_``TYPE     [HWLOOP_NB][$]; \\\n  local bit [31:0]          irq_vect_``TYPE                   [HWLOOP_NB][$]; \\\n  local bit                 lpend_has_pending_irq_``TYPE      [HWLOOP_NB] = '{default:0}; \\\n  local bit                 done_insn_list_capture_``TYPE     [HWLOOP_NB] = '{default:0}; \\\n  local bit                 done_insn_list_capture_d1_``TYPE  [HWLOOP_NB] = '{default:0}; \\\n  local s_hwloop_cov        hwloop_cov_``TYPE                 [HWLOOP_NB] = '{default:0};\n  \n  `DEF_LOCAL_VARS(main)\n  `DEF_LOCAL_VARS(sub)\n  `DEF_LOCAL_VARS(init)\n\n  virtual       uvmt_cv32e40p_rvvi_if #( .XLEN(XLEN), .ILEN(ILEN)) cv32e40p_rvvi_vif;\n  string        _header = \"XPULPV2_HWLOOP_COV\";\n  bit           en_cvg_sampling = 1;\n  bit           in_nested_loop0 = 0, in_nested_loop0_d1 = 0;\n  bit           is_ebreak = 0, is_ebreakm = 0, is_ecall = 0, is_illegal = 0, is_irq = 0, is_dbg_mode = 0, is_mc_insn = 0;\n  bit           is_trap = 0; // trap any period that is redundant due to handling entry which causes data flush\n  bit           has_pending_trap_due2_dbg = 0;    // has trap pending due to debug mode entry\n  bit           has_trap_due2_dbg_match_trig = 0; // has trap due to debug trigger match\n  bit           has_pending_trap_due2_irq = 0;    // has trap pending due to irq entry\n  bit           enter_hwloop_sub = 0;\n  int           enter_hwloop_sub_cnt = 0;\n  bit           pending_irq = 0;\n  logic [31:0]  prev_irq_onehot_priority = 0, prev_irq_onehot_priority_always = 0;\n  bit           prev_irq_onehot_priority_is_0 = 0;\n\n  dcsr_cause_t      dcsr_cause;\n  exception_code_t  exception_code;\n\n  // PROPERTIES - END\n\n  // COVERGROUPS DEFINE HERE - START\n\n  `define CG_CSR_HWLOOP(LOOP_IDX) cg_csr_hwloop_``LOOP_IDX``\n  `define DEF_CG_CSR_HWLOOP(LOOP_IDX) covergroup cg_csr_hwloop_``LOOP_IDX with function sample(s_csr_hwloop csr_hwloop); \\\n    option.per_instance         = 1; \\\n    `ifdef MODEL_TECH \\\n    option.get_inst_coverage    = 1; \\\n    `endif \\\n    type_option.merge_instances = 1; \\\n    cp_lpstart_``LOOP_IDX : coverpoint (csr_hwloop.lp_start[``LOOP_IDX``]) iff (csr_hwloop.lp_start_wb[``LOOP_IDX``] && csr_hwloop.lp_end_wb[``LOOP_IDX``] && csr_hwloop.lp_count_wb[``LOOP_IDX``]) { \\\n      bins lpstart_range_0      = {[32'h0000_03FC : 32'h0000_0004]}; \\\n      bins lpstart_range_1      = {[32'h0000_0FFC : 32'h0000_0400]}; \\\n      bins lpstart_range_2      = {[32'h0000_FFFC : 32'h0000_1000]}; \\\n      // higher range is not covered now due to limited generated codespace (amend if needed) \\\n    } \\\n    cp_lpend_``LOOP_IDX : coverpoint (csr_hwloop.lp_end[``LOOP_IDX``]) iff (csr_hwloop.lp_start_wb[``LOOP_IDX``] && csr_hwloop.lp_end_wb[``LOOP_IDX``] && csr_hwloop.lp_count_wb[``LOOP_IDX``]) { \\\n      bins lpend_range_0        = {[32'h0000_03FC : 32'h0000_0004]}; \\\n      bins lpend_range_1        = {[32'h0000_0FFC : 32'h0000_0400]}; \\\n      bins lpend_range_2        = {[32'h0000_FFFC : 32'h0000_1000]}; \\\n      // higher range is not covered now due to limited generated codespace (amend if needed) \\\n    } \\\n    cp_lpcount_``LOOP_IDX : coverpoint (csr_hwloop.lp_count[``LOOP_IDX``]) iff (csr_hwloop.lp_start_wb[``LOOP_IDX``] && csr_hwloop.lp_end_wb[``LOOP_IDX``] && csr_hwloop.lp_count_wb[``LOOP_IDX``]) { \\\n      // bins lpcount_zero           = {32'h0}; // valid CSR writes to sample should be when lpcount{0/1}.value != 0 \\\n      bins lpcount_range_low_1    = {[32'h0000_0190 : 32'h0000_0001]}; // count 0-400 \\\n      bins lpcount_range_low_2    = {[32'h0000_03FF : 32'h0000_0191]}; // count 401-1023 \\\n      bins lpcount_range_low_3    = {[32'h0000_0FFE : 32'h0000_0400]}; // count 1024-4094 \\\n      bins lpcount_range_low_4    = {32'h0000_0FFF}; // 4095 \\\n      // higher counts are not covered now to reduced simtime (amend if needed) \\\n    } \\\n    ccp_lpstart_0_lpend_lpcount_``LOOP_IDX : cross cp_lpstart_``LOOP_IDX``, cp_lpend_``LOOP_IDX``, cp_lpcount_``LOOP_IDX`` { \\\n      ignore_bins ignore__lpstart_range_1 = binsof (cp_lpstart_``LOOP_IDX``.lpstart_range_1); \\\n      ignore_bins ignore__lpstart_range_2 = binsof (cp_lpstart_``LOOP_IDX``.lpstart_range_2); \\\n      // ignore below due to long simtime if cross higher count with large loop \\\n      ignore_bins ignore__lpcount_low4    = binsof (cp_lpcount_``LOOP_IDX``.lpcount_range_low_4); \\\n    } \\\n    ccp_lpstart_1_lpend_lpcount_``LOOP_IDX : cross cp_lpstart_``LOOP_IDX``, cp_lpend_``LOOP_IDX``, cp_lpcount_``LOOP_IDX`` { \\\n      ignore_bins ignore__lpstart_range_0 = binsof (cp_lpstart_``LOOP_IDX``.lpstart_range_0); \\\n      ignore_bins ignore__lpstart_range_2 = binsof (cp_lpstart_``LOOP_IDX``.lpstart_range_2); \\\n      ignore_bins ignore__lpend_range_0   = binsof (cp_lpend_``LOOP_IDX``.lpend_range_0); \\\n      // ignore below due to long simtime if cross higher count with large loop \\\n      ignore_bins ignore__lpcount_low4    = binsof (cp_lpcount_``LOOP_IDX``.lpcount_range_low_4); \\\n    } \\\n    ccp_lpstart_2_lpend_lpcount_``LOOP_IDX : cross cp_lpstart_``LOOP_IDX``, cp_lpend_``LOOP_IDX``, cp_lpcount_``LOOP_IDX`` { \\\n      ignore_bins ignore__lpstart_range_0 = binsof (cp_lpstart_``LOOP_IDX``.lpstart_range_0); \\\n      ignore_bins ignore__lpstart_range_1 = binsof (cp_lpstart_``LOOP_IDX``.lpstart_range_1); \\\n      ignore_bins ignore__lpend_range_0   = binsof (cp_lpend_``LOOP_IDX``.lpend_range_0); \\\n      ignore_bins ignore__lpend_range_1   = binsof (cp_lpend_``LOOP_IDX``.lpend_range_1); \\\n      // ignore below due to long simtime if cross higher count with large loop \\\n      ignore_bins ignore__lpcount_low4    = binsof (cp_lpcount_``LOOP_IDX``.lpcount_range_low_4); \\\n    } \\\n  endgroup : cg_csr_hwloop_``LOOP_IDX\n\n  `define CG_FEATURES_OF_HWLOOP(LOOP_IDX) cg_features_of_hwloop_``LOOP_IDX``\n  `define DEF_CG_FEATURES_OF_HWLOOP(LOOP_IDX) covergroup cg_features_of_hwloop_``LOOP_IDX with function \\\n    sample(int lp_idx, s_hwloop_stat hwloop_stat, s_hwloop_cov hwloop_cov, bit [31:0] insn=32'b0, bit [31:0] irq=32'b0, hwloop_evt_loc_t evt_loc=TOTAL_LOC); \\\n    option.per_instance         = 1; \\\n    `ifdef MODEL_TECH \\\n    option.get_inst_coverage    = 1; \\\n    `endif \\\n    type_option.merge_instances = 1; \\\n    cp_hwloop_type : coverpoint (hwloop_stat.hwloop_type) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``]) { \\\n      bins single_hwloop      = {SINGLE}; \\\n      bins nested_hwloop      = {NESTED}; \\\n      illegal_bins invalid    = default; \\\n    } \\\n    cp_hwloop_setup : coverpoint (hwloop_stat.hwloop_setup[``LOOP_IDX``]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``]) { \\\n      bins short_hwloop_setup = {SHORT}; \\\n      bins long_hwloop_setup  = {LONG}; \\\n      illegal_bins invalid    = default; \\\n    } \\\n    cp_hwloop_irq : coverpoint (irq) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_irq) { \\\n      // priority order (high->low) : irq[31]...irq[16], irq[11], irq[3], irq[7] \\\n      bins vec_irq_1hot_priority[]    = {32'h0000_0008, \\\n                                         32'h0000_0080, \\\n                                         32'h0000_0800, \\\n                                         32'h0001_0000, 32'h0002_0000, 32'h0004_0000, 32'h0008_0000, \\\n                                         32'h0010_0000, 32'h0020_0000, 32'h0040_0000, 32'h0080_0000, \\\n                                         32'h0100_0000, 32'h0200_0000, 32'h0400_0000, 32'h0800_0000, \\\n                                         32'h1000_0000, 32'h2000_0000, 32'h4000_0000, 32'h8000_0000}; \\\n    } \\\n    cp_hwloop_dbg_haltreq : coverpoint (hwloop_stat.dbg_haltreq_cnt[lp_idx]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_dbg_haltreq) { \\\n      bins        dbg_haltreq     = {[1:$]}; \\\n    } \\\n    cp_hwloop_dbg_ebreakm : coverpoint (hwloop_stat.dbg_ebreakm_cnt[lp_idx]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_dbg_ebreakm) { \\\n      bins        dbg_ebreakm     = {[1:$]}; \\\n    } \\\n    cp_hwloop_dbg_trigger : coverpoint (hwloop_stat.dbg_trigger_cnt[lp_idx]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_dbg_trigger) { \\\n      bins        dbg_trigger     = {[1:$]}; \\\n    } \\\n    cp_hwloop_dbg_step_cnt : coverpoint (hwloop_stat.dbg_step_cnt[lp_idx]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_dbg_step_cnt) { \\\n      bins dbg_step_range_1       = {[1:4]}; \\\n      bins dbg_step_range_2       = {[5:20]}; \\\n      bins dbg_step_range_3       = {[20:50]}; \\\n      bins dbg_step_range_4       = {[51:$]}; \\\n    } \\\n    cp_hwloop_dbg_step_cnt_loc : coverpoint (hwloop_stat.dbg_step_cnt[lp_idx]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_dbg_step_cnt_loc) { \\\n      bins dbg_step_cnt_loc       = {[1:$]}; \\\n    } \\\n    cp_hwloop_excp_ebreak : coverpoint (hwloop_stat.excp_ebreak_cnt[lp_idx]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_excp_ebreak) { \\\n      bins        excp_ebreak     = {[1:$]}; \\\n    } \\\n    cp_hwloop_excp_ecall : coverpoint (hwloop_stat.excp_ecall_cnt[lp_idx]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_excp_ecall) { \\\n      bins        excp_ecall      = {[1:$]}; \\\n    } \\\n    cp_hwloop_excp_illegal : coverpoint (hwloop_stat.excp_illegal_cnt[lp_idx]) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_excp_illegal) { \\\n      bins        excp_illegal    = {[1:$]}; \\\n    } \\\n    cp_hwloop_mc_insn : coverpoint (insn) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_mc_insn) { \\\n      // RV32F \\\n      `RV32F_INSTR_BINS \\\n      // RV32M \\\n      wildcard bins div     = {TB_INSTR_DIV}; \\\n      wildcard bins divu    = {TB_INSTR_DIVU}; \\\n      wildcard bins rem     = {TB_INSTR_REM}; \\\n      wildcard bins remu    = {TB_INSTR_REMU}; \\\n      wildcard bins pmuh    = {TB_INSTR_PMUH}; \\\n      wildcard bins pmulhsu = {TB_INSTR_PMULHSU}; \\\n      wildcard bins pmulhu  = {TB_INSTR_PMULHU}; \\\n    } \\\n    cp_hwloop_loc : coverpoint (evt_loc) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_event_loc) { \\\n      bins loc_lpstart        = {LOC_LPSTART}; \\\n      bins loc_lpstart_plus4  = {LOC_LPSTART_P4}; \\\n      bins loc_lpend          = {LOC_LPEND}; \\\n      bins loc_lpend_minus4   = {LOC_LPEND_M4}; \\\n      bins loc_others         = {LOC_OTHERS}; \\\n    } \\\n    // note: hwloop setup custom instructions are not allow in hwloop_0 (manual exclusion needed) \\\n    cp_insn_list_in_hwloop : coverpoint (insn) iff (hwloop_stat.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_cov.en_cov_insn) { \\\n      wildcard bins lui     = {TB_INSTR_LUI}; \\\n      wildcard bins auipc   = {TB_INSTR_AUIPC}; \\\n      // OPIMM \\\n      `OPIMM_INSTR_BINS \\\n      // OP \\\n      `OP_INSTR_BINS \\\n      // SYSTEM \\\n      wildcard bins csrrw   = {TB_INSTR_CSRRW}; \\\n      wildcard bins csrrs   = {TB_INSTR_CSRRS}; \\\n      wildcard bins csrrc   = {TB_INSTR_CSRRC}; \\\n      wildcard bins csrrwi  = {TB_INSTR_CSRRWI}; \\\n      wildcard bins csrrsi  = {TB_INSTR_CSRRSI}; \\\n      wildcard bins csrrci  = {TB_INSTR_CSRRCI}; \\\n      wildcard bins ecall   = {TB_INSTR_ECALL}; \\\n      wildcard bins ebreak  = {TB_INSTR_EBREAK}; \\\n      // RV32M \\\n      `RV32M_INSTR_BINS \\\n      // RV32F \\\n      `RV32F_INSTR_BINS \\\n      // LOAD STORE \\\n      `LOAD_STORE_INSTR_BINS \\\n      // RV32X \\\n      `RV32X_PULP_INSTR_BINS \\\n      // user-defined instructions \\\n      wildcard bins instr_illegal_exception = {{INSN_ILLEGAL}}; \\\n      wildcard bins instr_ebreakm           = {{INSN_EBREAKM}}; \\\n      // Others \\\n      illegal_bins other_instr              = default; \\\n    } \\\n    ccp_hwloop_type_setup_insn_list   : cross cp_hwloop_type, cp_hwloop_setup, cp_insn_list_in_hwloop; \\\n    ccp_hwloop_type_irq_loc           : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_irq; \\\n    ccp_hwloop_type_dbg_haltreq_loc   : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_dbg_haltreq; \\\n    ccp_hwloop_type_dbg_ebreakm_loc   : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_dbg_ebreakm; \\\n    ccp_hwloop_type_dbg_trigger_loc   : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_dbg_trigger; \\\n    ccp_hwloop_type_dbg_step_cnt      : cross cp_hwloop_type, cp_hwloop_dbg_step_cnt; /* todo: x with lpcount */ \\\n    ccp_hwloop_type_dbg_step_cnt_loc  : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_dbg_step_cnt_loc; \\\n    ccp_hwloop_type_excp_ebreak_loc   : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_excp_ebreak; \\\n    ccp_hwloop_type_excp_ecall_loc    : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_excp_ecall; \\\n    ccp_hwloop_type_excp_illegal_loc  : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_excp_illegal; \\\n    ccp_hwloop_type_excp_mc_insn_loc  : cross cp_hwloop_type, cp_hwloop_loc, cp_hwloop_mc_insn; \\\n  endgroup : cg_features_of_hwloop_``LOOP_IDX``\n\n  `DEF_CG_CSR_HWLOOP(0)\n  `DEF_CG_CSR_HWLOOP(1)\n  `DEF_CG_FEATURES_OF_HWLOOP(0)\n  `DEF_CG_FEATURES_OF_HWLOOP(1)\n\n  // COVERGROUPS DEFINE HERE - START\n\n  `uvm_component_utils(uvme_rv32x_hwloop_covg)\n\n  function new(string name=\"uvme_rv32x_hwloop_covg\", uvm_component parent=null);\n    super.new(name, parent);\n    `CG_CSR_HWLOOP(0)         = new(); `CG_CSR_HWLOOP(0).set_inst_name($sformatf(\"cg_csr_hwloop_0\"));\n    `CG_CSR_HWLOOP(1)         = new(); `CG_CSR_HWLOOP(1).set_inst_name($sformatf(\"cg_csr_hwloop_1\"));\n    `CG_FEATURES_OF_HWLOOP(0) = new(); `CG_FEATURES_OF_HWLOOP(0).set_inst_name($sformatf(\"cg_features_of_hwloop_0\"));\n    `CG_FEATURES_OF_HWLOOP(1) = new(); `CG_FEATURES_OF_HWLOOP(1).set_inst_name($sformatf(\"cg_features_of_hwloop_1\"));\n  endfunction: new\n\n  function void build_phase(uvm_phase phase);\n    super.build_phase(phase);\n    if (!(uvm_config_db#(virtual uvmt_cv32e40p_rvvi_if)::get(this, \"\", \"cv32e40p_rvvi_vif\", cv32e40p_rvvi_vif))) begin\n        `uvm_fatal(_header, \"cv32e40p_rvvi_vif no found in uvm_config_db\");\n    end\n    if ($test$plusargs(\"skip_sampling_uvme_rv32x_hwloop_covg\")) begin\n      `uvm_info(_header, \"Skip uvme_rv32x_hwloop_covg cvg sampling due to test intention\", UVM_WARNING);\n      en_cvg_sampling = 0;\n    end\n  endfunction : build_phase\n\n\n  // conditions to collect location for different locations\n  `define CHECK_PC_EQUAL_LPSTART(IN1, IN2, IN3, IN4)  is_pc_equal_lpstart(``IN1, ``IN2, ``IN3, ``IN4)\n  `define CHECK_PC_EQUAL_LPEND(IN1, IN2, IN3, IN4)    is_pc_equal_lpend(``IN1, ``IN2, ``IN3, ``IN4)\n  `define CHECK_PC_WITHIN_LP(IN1, IN2, IN3)           is_pc_within_lp(``IN1, ``IN2, ``IN3)\n  `define IF_CURRENT_IS_MAIN_HWLOOP(LOOP_IDX, EVT) \\\n  if (``LOOP_IDX`` == 0 || ``LOOP_IDX`` == 1) begin \\\n    bit temp_in_nested_loop0 = (``LOOP_IDX`` == 0) ? 0 : in_nested_loop0; \\\n    if (hwloop_stat_main.execute_instr_in_hwloop[``LOOP_IDX``] && hwloop_stat_main.track_lp_cnt[``LOOP_IDX``] >= 0 && !temp_in_nested_loop0) begin \\\n      unique case (``EVT``) \\\n        EXCP_EBREAK: begin \\\n          hwloop_stat_main.excp_ebreak_cnt[``LOOP_IDX``]++; \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_EBREAK].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_EBREAK].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_EBREAK].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_EBREAK].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][EXCP_EBREAK].push_back(LOC_OTHERS); \\\n        end \\\n        EXCP_ECALL : begin \\\n          hwloop_stat_main.excp_ecall_cnt[``LOOP_IDX``]++; \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ECALL].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ECALL].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ECALL].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ECALL].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ECALL].push_back(LOC_OTHERS); \\\n        end \\\n        EXCP_ILLEGAL : begin \\\n          hwloop_stat_main.excp_illegal_cnt[``LOOP_IDX``]++; \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ILLEGAL].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ILLEGAL].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ILLEGAL].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ILLEGAL].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][EXCP_ILLEGAL].push_back(LOC_OTHERS); \\\n        end \\\n        IS_IRQ : begin \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][IS_IRQ].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][IS_IRQ].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][IS_IRQ].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][IS_IRQ].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][IS_IRQ].push_back(LOC_OTHERS); \\\n          irq_vect_main[``LOOP_IDX``].push_back(prev_irq_onehot_priority); \\\n        end \\\n        DBG_HALTREQ : begin \\\n          hwloop_stat_main.dbg_haltreq_cnt[``LOOP_IDX``]++; \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_HALTREQ].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_HALTREQ].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_HALTREQ].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_HALTREQ].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][DBG_HALTREQ].push_back(LOC_OTHERS); \\\n        end \\\n        DBG_TRIG : begin \\\n          hwloop_stat_main.dbg_trigger_cnt[``LOOP_IDX``]++; \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_TRIG].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_TRIG].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_TRIG].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_TRIG].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][DBG_TRIG].push_back(LOC_OTHERS); \\\n        end \\\n        DBG_STEP : begin \\\n          hwloop_stat_main.dbg_step_cnt[``LOOP_IDX``]++; \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_STEP].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_STEP].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_STEP].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, prev_pc_rdata_main))         hwloop_evt_loc_main[``LOOP_IDX``][DBG_STEP].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][DBG_STEP].push_back(LOC_OTHERS); \\\n        end \\\n        DBG_EBREAKM : begin \\\n          hwloop_stat_main.dbg_ebreakm_cnt[``LOOP_IDX``]++; \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, cv32e40p_rvvi_vif.pc_rdata)) hwloop_evt_loc_main[``LOOP_IDX``][DBG_EBREAKM].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, cv32e40p_rvvi_vif.pc_rdata)) hwloop_evt_loc_main[``LOOP_IDX``][DBG_EBREAKM].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, cv32e40p_rvvi_vif.pc_rdata)) hwloop_evt_loc_main[``LOOP_IDX``][DBG_EBREAKM].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, cv32e40p_rvvi_vif.pc_rdata)) hwloop_evt_loc_main[``LOOP_IDX``][DBG_EBREAKM].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][DBG_EBREAKM].push_back(LOC_OTHERS); \\\n        end \\\n        MC_INSN : begin \\\n          if      (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, cv32e40p_rvvi_vif.pc_rdata)) hwloop_evt_loc_main[``LOOP_IDX``][MC_INSN].push_back(LOC_LPSTART); \\\n          else if (`CHECK_PC_EQUAL_LPSTART(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, cv32e40p_rvvi_vif.pc_rdata)) hwloop_evt_loc_main[``LOOP_IDX``][MC_INSN].push_back(LOC_LPSTART_P4); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 0, cv32e40p_rvvi_vif.pc_rdata)) hwloop_evt_loc_main[``LOOP_IDX``][MC_INSN].push_back(LOC_LPEND); \\\n          else if (  `CHECK_PC_EQUAL_LPEND(hwloop_stat_main.hwloop_csr, ``LOOP_IDX``, 1, cv32e40p_rvvi_vif.pc_rdata)) hwloop_evt_loc_main[``LOOP_IDX``][MC_INSN].push_back(LOC_LPEND_M4); \\\n          else                                                                                                        hwloop_evt_loc_main[``LOOP_IDX``][MC_INSN].push_back(LOC_OTHERS); \\\n        end \\\n      endcase  \\\n    end \\\n  end\n\n  // task to sample cg_csr_hwloop\n  `define CHECK_N_SAMPLE_CSR_HWLOOP(TYPE) check_n_sample_csr_hwloop_``TYPE``();\n  `define DEF_CHECK_N_SAMPLE_CSR_HWLOOP(TYPE) task check_n_sample_csr_hwloop_``TYPE``(); \\\n    for (int i=0; i<HWLOOP_NB; i++) begin \\\n      int short_setup_cnt = 0; // use for cv.setup (all start, end and count happen stimultenously in one cycle) \\\n      if (cv32e40p_rvvi_vif.csr_wb[CSR_LPSTART0_ADDR+i*4]) begin : UPDATE_LPSTART \\\n        csr_hwloop_``TYPE``.lp_start[i]    = cv32e40p_rvvi_vif.csr[CSR_LPSTART0_ADDR+i*4]; \\\n        csr_hwloop_``TYPE``.lp_start_wb[i] = cv32e40p_rvvi_vif.csr_wb[CSR_LPSTART0_ADDR+i*4]; \\\n        short_setup_cnt++; \\\n      end \\\n      if (cv32e40p_rvvi_vif.csr_wb[CSR_LPEND0_ADDR+i*4]) begin : UPDATE_LPEND \\\n        csr_hwloop_``TYPE``.lp_end[i]      = cv32e40p_rvvi_vif.csr[CSR_LPEND0_ADDR+i*4]; \\\n        csr_hwloop_``TYPE``.lp_end_wb[i]   = cv32e40p_rvvi_vif.csr_wb[CSR_LPEND0_ADDR+i*4]; \\\n        short_setup_cnt++; \\\n      end \\\n      if (cv32e40p_rvvi_vif.csr_wb[CSR_LPCOUNT0_ADDR+i*4]) begin : UPDATE_LPCOUNT \\\n        csr_hwloop_``TYPE``.lp_count[i]    = cv32e40p_rvvi_vif.csr[CSR_LPCOUNT0_ADDR+i*4]; \\\n        csr_hwloop_``TYPE``.lp_count_wb[i] = cv32e40p_rvvi_vif.csr_wb[CSR_LPCOUNT0_ADDR+i*4]; \\\n        short_setup_cnt++; \\\n      end \\\n      if (csr_hwloop_``TYPE``.lp_start_wb[i] && csr_hwloop_``TYPE``.lp_end_wb[i] && csr_hwloop_``TYPE``.lp_count_wb[i]) begin : SAMPLE_HWLOP_CSR \\\n        if (csr_hwloop_``TYPE``.lp_count[i] != 0 && !hwloop_stat_``TYPE``.sample_hwloop_csr_done[i]) begin \\\n            `uvm_info(_header, $sformatf(\"DEBUG - cg_csr_hwloop[%0d] - sampling csr_hwloop is %p\", i, csr_hwloop_``TYPE``), UVM_DEBUG); \\\n            unique case (i) \\\n              0:  begin \\\n                    `CG_CSR_HWLOOP(0).sample(csr_hwloop_``TYPE``); \\\n                    `uvm_info(_header, $sformatf(\"DEBUG - cg_csr_hwloop[%0d] - get_inst_coverage = %.2f, get_coverage = %.2f\", i, `CG_CSR_HWLOOP(0).get_inst_coverage(), `CG_CSR_HWLOOP(0).get_coverage), UVM_DEBUG); \\\n                  end \\\n              1:  begin \\\n                    `CG_CSR_HWLOOP(1).sample(csr_hwloop_``TYPE``); \\\n                    `uvm_info(_header, $sformatf(\"DEBUG - cg_csr_hwloop[%0d] - get_inst_coverage = %.2f, get_coverage = %.2f\", i, `CG_CSR_HWLOOP(1).get_inst_coverage(), `CG_CSR_HWLOOP(1).get_coverage), UVM_DEBUG); \\\n                  end \\\n            endcase \\\n          // update hwloop_stat \\\n          hwloop_stat_``TYPE``.hwloop_csr.lp_start[i] = csr_hwloop_``TYPE``.lp_start[i]; \\\n          hwloop_stat_``TYPE``.hwloop_csr.lp_end[i]   = csr_hwloop_``TYPE``.lp_end[i]; \\\n          hwloop_stat_``TYPE``.hwloop_csr.lp_count[i] = csr_hwloop_``TYPE``.lp_count[i]; \\\n          if (short_setup_cnt == 3) \\\n            hwloop_stat_``TYPE``.hwloop_setup[i]      = SHORT; \\\n          else                       \\\n            hwloop_stat_``TYPE``.hwloop_setup[i]      = LONG; \\\n          hwloop_stat_``TYPE``.sample_hwloop_csr_done[i] = 1'b1; \\\n        end \\\n        else if (hwloop_stat_``TYPE``.execute_instr_in_hwloop[i]) begin \\\n          hwloop_stat_``TYPE``.hwloop_csr.lp_start[i] = csr_hwloop_``TYPE``.lp_start[i]; \\\n          hwloop_stat_``TYPE``.hwloop_csr.lp_end[i]   = csr_hwloop_``TYPE``.lp_end[i]; \\\n          hwloop_stat_``TYPE``.hwloop_csr.lp_count[i] = csr_hwloop_``TYPE``.lp_count[i]; \\\n        end \\\n      end // SAMPLE_HWLOP_CSR \\\n    end // for \\\n  endtask : check_n_sample_csr_hwloop_``TYPE``\n\n  `DEF_CHECK_N_SAMPLE_CSR_HWLOOP(main)\n  // `DEF_CHECK_N_SAMPLE_CSR_HWLOOP(sub)\n\n  // task to sample cg_features_of_hwloop\n  `define MC_INSN_OP_CODE  {OPCODE_OP, OPCODE_OP_FP, OPCODE_OP_FMADD, OPCODE_OP_FNMADD, OPCODE_OP_FMSUB, OPCODE_OP_FNMSUB, OPCODE_LOAD_FP, OPCODE_STORE_FP}\n  `define CHECK_N_SAMPLE_HWLOOP(TYPE) check_n_sample_hwloop_``TYPE``();\n  `define DEF_CHECK_N_SAMPLE_HWLOOP(TYPE) task check_n_sample_hwloop_``TYPE``(); \\\n    for (int i=0; i<HWLOOP_NB; i++) begin : UPDATE_HWLOOP_STAT \\\n      if (hwloop_stat_``TYPE``.hwloop_csr.lp_count[i] != 0) begin \\\n        if (is_pc_equal_lpstart(hwloop_stat_``TYPE``.hwloop_csr, i, 0, cv32e40p_rvvi_vif.pc_rdata) && hwloop_stat_``TYPE``.track_lp_cnt[i] == 0) begin \\\n          hwloop_stat_``TYPE``.execute_instr_in_hwloop[i] = 1'b1; \\\n          hwloop_stat_``TYPE``.track_lp_cnt[i]          = hwloop_stat_``TYPE``.hwloop_csr.lp_count[i]; \\\n          if      ( hwloop_stat_``TYPE``.execute_instr_in_hwloop[0] &&  hwloop_stat_``TYPE``.execute_instr_in_hwloop[1]) hwloop_stat_``TYPE``.hwloop_type = NESTED; \\\n          else if ( hwloop_stat_``TYPE``.execute_instr_in_hwloop[0] && !hwloop_stat_``TYPE``.execute_instr_in_hwloop[1]) hwloop_stat_``TYPE``.hwloop_type = SINGLE; \\\n          else if (!hwloop_stat_``TYPE``.execute_instr_in_hwloop[0] &&  hwloop_stat_``TYPE``.execute_instr_in_hwloop[1]) hwloop_stat_``TYPE``.hwloop_type = SINGLE; \\\n        end \\\n      end \\\n    end // UPDATE_HWLOOP_STAT \\\n    for (int i=0; i<HWLOOP_NB; i++) begin : COLLECT_INSTR \\\n      if (hwloop_stat_``TYPE``.execute_instr_in_hwloop[i]) begin \\\n        lpend_has_pending_irq_``TYPE``[i] = 0; \\\n        done_insn_list_capture_d1_``TYPE``[i] = done_insn_list_capture_``TYPE``[i]; \\\n        unique case (i) \\\n          0 : begin // nested or single is the same \\\n                if (!done_insn_list_capture_``TYPE``[i]) begin \\\n                  if (is_illegal)       insn_list_in_hwloop_``TYPE``[i].push_back(INSN_ILLEGAL); \\\n                  else if (is_ebreakm)  insn_list_in_hwloop_``TYPE``[i].push_back(INSN_EBREAKM); \\\n                  else                  insn_list_in_hwloop_``TYPE``[i].push_back(cv32e40p_rvvi_vif.insn); \\\n                  if (cv32e40p_rvvi_vif.insn[6:0] inside `MC_INSN_OP_CODE) begin \\\n                    if ((cv32e40p_rvvi_vif.insn[6:0] == OPCODE_OP && cv32e40p_rvvi_vif.insn[31:25] != 7'b0000001) || \\\n                        (cv32e40p_rvvi_vif.insn[6:0] == OPCODE_OP && cv32e40p_rvvi_vif.insn[14:12] == 3'b000) \\\n                    ) is_mc_insn = 0; \\\n                    else begin \\\n                      is_mc_insn = 1;  mc_insn_list_in_hwloop_``TYPE``[i].push_back(cv32e40p_rvvi_vif.insn); \\\n                      `IF_CURRENT_IS_MAIN_HWLOOP(i, MC_INSN) \\\n                    end \\\n                  end \\\n                  else is_mc_insn = 0; \\\n                  check_ebreakm_entry(i); \\\n                end \\\n                else if (is_ebreakm) begin \\\n                  insn_list_in_hwloop_``TYPE``[i].push_back(INSN_EBREAKM); \\\n                  check_ebreakm_entry(i); \\\n                end \\\n                if (is_pc_equal_lpend(hwloop_stat_``TYPE``.hwloop_csr, i, 0, cv32e40p_rvvi_vif.pc_rdata) && hwloop_stat_``TYPE``.track_lp_cnt[i] != 0) begin \\\n                  // if (pending_irq) lpend_has_pending_irq_``TYPE``[i] = 1; \\\n                  if (pending_irq && cv32e40p_rvvi_vif.trap) lpend_has_pending_irq_``TYPE``[i] = 1; \\\n                  hwloop_stat_``TYPE``.track_lp_cnt[i]--; \\\n                  done_insn_list_capture_``TYPE``[i] = 1; \\\n                  assert(hwloop_stat_``TYPE``.track_lp_cnt[i] >= 0); \\\n                end \\\n              end \\\n          1 : begin // in nested, skip when executing hwloop0  \\\n                in_nested_loop0_d1 = in_nested_loop0; \\\n                if (hwloop_stat_``TYPE``.hwloop_type == NESTED && hwloop_stat_``TYPE``.track_lp_cnt[0] != 0) begin \\\n                  in_nested_loop0 = 1; continue; \\\n                end \\\n                else if (hwloop_stat_``TYPE``.hwloop_type == NESTED && hwloop_stat_``TYPE``.track_lp_cnt[0] == 0 && in_nested_loop0) begin \\\n                  in_nested_loop0 = 0; continue; \\\n                end \\\n                if (!done_insn_list_capture_``TYPE``[i]) begin \\\n                  if (is_illegal)       insn_list_in_hwloop_``TYPE``[i].push_back(INSN_ILLEGAL); \\\n                  else if (is_ebreakm)  insn_list_in_hwloop_``TYPE``[i].push_back(INSN_EBREAKM); \\\n                  else                  insn_list_in_hwloop_``TYPE``[i].push_back(cv32e40p_rvvi_vif.insn); \\\n                  if (cv32e40p_rvvi_vif.insn[6:0] inside `MC_INSN_OP_CODE) begin \\\n                    if ((cv32e40p_rvvi_vif.insn[6:0] == OPCODE_OP && cv32e40p_rvvi_vif.insn[31:25] != 7'b0000001) || \\\n                        (cv32e40p_rvvi_vif.insn[6:0] == OPCODE_OP && cv32e40p_rvvi_vif.insn[14:12] == 3'b000) \\\n                    ) is_mc_insn = 0; \\\n                    else begin \\\n                      is_mc_insn = 1;  mc_insn_list_in_hwloop_``TYPE``[i].push_back(cv32e40p_rvvi_vif.insn); \\\n                      `IF_CURRENT_IS_MAIN_HWLOOP(i, MC_INSN) \\\n                    end \\\n                  end \\\n                  else is_mc_insn = 0; \\\n                  check_ebreakm_entry(i); \\\n                end \\\n                else if (is_ebreakm) begin \\\n                  insn_list_in_hwloop_``TYPE``[i].push_back(INSN_EBREAKM); \\\n                  check_ebreakm_entry(i); \\\n                end \\\n                if (is_pc_equal_lpend(hwloop_stat_``TYPE``.hwloop_csr, i, 0, cv32e40p_rvvi_vif.pc_rdata) && hwloop_stat_``TYPE``.track_lp_cnt[i] != 0) begin \\\n                  // if (pending_irq) lpend_has_pending_irq_``TYPE``[i] = 1; \\\n                  if (pending_irq && cv32e40p_rvvi_vif.trap) lpend_has_pending_irq_``TYPE``[i] = 1; \\\n                  hwloop_stat_``TYPE``.track_lp_cnt[i]--; \\\n                  done_insn_list_capture_``TYPE``[i] = 1; \\\n                  assert(hwloop_stat_``TYPE``.track_lp_cnt[i] >= 0); \\\n                end \\\n              end \\\n        endcase  \\\n      end \\\n    end // COLLECT_INSTR \\\n    if ( \\\n      (hwloop_stat_``TYPE``.hwloop_type == NESTED && done_insn_list_capture_``TYPE``[1] && hwloop_stat_``TYPE``.track_lp_cnt[1] == 0) || \\\n      (hwloop_stat_``TYPE``.hwloop_type == SINGLE && done_insn_list_capture_``TYPE``[1] && hwloop_stat_``TYPE``.track_lp_cnt[1] == 0) || \\\n      (hwloop_stat_``TYPE``.hwloop_type == SINGLE && done_insn_list_capture_``TYPE``[0] && hwloop_stat_``TYPE``.track_lp_cnt[0] == 0) \\\n    ) begin : SAMPLE_END_OF_HWLOOPS \\\n      for (int i=0; i<HWLOOP_NB; i++) begin \\\n        // FOR_CP_INSN_LIST_IN_HWLOOP \\\n        hwloop_cov_``TYPE``[i].en_cov_insn = 1; \\\n        while (insn_list_in_hwloop_``TYPE``[i].size() != 0) begin \\\n          bit [31:0] insn_item; \\\n          insn_item = insn_list_in_hwloop_``TYPE``[i].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_INSN_LIST_IN_HWLOOP - LOOP_%0d - insn_item is %8h\", i, insn_item), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .insn(insn_item)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .insn(insn_item)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_cov_``TYPE``[i].en_cov_insn = 0; \\\n        // FOR_CP_HWLOOP_IRQ_LOC \\\n        hwloop_cov_``TYPE``[i].en_cov_irq = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        while (irq_vect_``TYPE``[i].size() != 0) begin \\\n          bit [31:0]    irq_item; \\\n          hwloop_evt_loc_t  evt_loc; \\\n          irq_item = irq_vect_``TYPE``[i].pop_front(); \\\n          evt_loc  = hwloop_evt_loc_``TYPE``[i][IS_IRQ].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_IRQ_LOC - LOOP_%0d - irq_item is %8h at loc[%s]\", i, irq_item, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .irq(irq_item), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .irq(irq_item), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][IS_IRQ].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_irq = 0; \\\n        // FOR_CP_HWLOOP_DBG_HALTREQ \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_haltreq = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        for (int j=0; j<hwloop_stat_``TYPE``.dbg_haltreq_cnt[i]; j++) begin \\\n          hwloop_evt_loc_t  evt_loc; \\\n          evt_loc  = hwloop_evt_loc_``TYPE``[i][DBG_HALTREQ].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_DBG_HALTREQ - LOOP_%0d - dbg_haltreq at loc[%s]\", i, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][DBG_HALTREQ].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_haltreq = 0; \\\n        // FOR_CP_HWLOOP_DBG_EBREAKM \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_ebreakm = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        for (int j=0; j<hwloop_stat_``TYPE``.dbg_ebreakm_cnt[i]; j++) begin \\\n          hwloop_evt_loc_t  evt_loc; \\\n          evt_loc  = hwloop_evt_loc_``TYPE``[i][DBG_EBREAKM].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_DBG_EBREAKM - LOOP_%0d - dbg_ebreakm at loc[%s]\", i, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][DBG_EBREAKM].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_ebreakm = 0; \\\n        // FOR_CP_HWLOOP_DBG_TRIGGER \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_trigger = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        for (int j=0; j<hwloop_stat_``TYPE``.dbg_trigger_cnt[i]; j++) begin \\\n          hwloop_evt_loc_t  evt_loc; \\\n          evt_loc  = hwloop_evt_loc_``TYPE``[i][DBG_TRIG].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_DBG_TRIGGER - LOOP_%0d - dbg_trigger at loc[%s]\", i, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][DBG_TRIG].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_trigger = 0; \\\n        // FOR_CP_HWLOOP_DBG_STEP_CNT \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_step_cnt = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 0; \\\n        if (hwloop_stat_``TYPE``.dbg_step_cnt[i] > 0) begin \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_DBG_STEP_CNT - LOOP_%0d - dbg_step_cnt %0d\", i, hwloop_stat_``TYPE``.dbg_step_cnt[i]), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i])); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i])); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_step_cnt = 0; \\\n        // FOR_CP_HWLOOP_DBG_STEP_CNT_LOC \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_step_cnt_loc = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        for (int j=0; j<hwloop_stat_``TYPE``.dbg_step_cnt[i]; j++) begin \\\n          hwloop_evt_loc_t  evt_loc; \\\n          evt_loc  = hwloop_evt_loc_``TYPE``[i][DBG_STEP].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_DBG_STEP_CNT_LOC - LOOP_%0d - dbg_step at loc[%s]\", i, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][DBG_STEP].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_dbg_step_cnt_loc = 0; \\\n        // FOR_CP_HWLOOP_EXCP_EBREAK \\\n        hwloop_cov_``TYPE``[i].en_cov_excp_ebreak = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        for (int j=0; j<hwloop_stat_``TYPE``.excp_ebreak_cnt[i]; j++) begin \\\n          hwloop_evt_loc_t  evt_loc; \\\n          evt_loc  = hwloop_evt_loc_``TYPE``[i][EXCP_EBREAK].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_EXCP_EBREAK - LOOP_%0d - excp_ebreak at loc[%s]\", i, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][EXCP_EBREAK].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_excp_ebreak = 0; \\\n        // FOR_CP_HWLOOP_EXCP_ECALL \\\n        hwloop_cov_``TYPE``[i].en_cov_excp_ecall = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        for (int j=0; j<hwloop_stat_``TYPE``.excp_ecall_cnt[i]; j++) begin \\\n          hwloop_evt_loc_t  evt_loc; \\\n          evt_loc  = hwloop_evt_loc_``TYPE``[i][EXCP_ECALL].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_EXCP_ECALL - LOOP_%0d - excp_ecall at loc[%s]\", i, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][EXCP_ECALL].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_excp_ecall = 0; \\\n        // FOR_CP_HWLOOP_EXCP_ILLEGAL \\\n        hwloop_cov_``TYPE``[i].en_cov_excp_illegal = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        for (int j=0; j<hwloop_stat_``TYPE``.excp_illegal_cnt[i]; j++) begin \\\n          hwloop_evt_loc_t  evt_loc; \\\n          evt_loc  = hwloop_evt_loc_``TYPE``[i][EXCP_ILLEGAL].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_EXCP_ILLEGAL - LOOP_%0d - excp_illegal at loc[%s]\", i, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][EXCP_ILLEGAL].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_excp_illegal = 0; \\\n        // FOR_CP_HWLOOP_MC_INSN \\\n        hwloop_cov_``TYPE``[i].en_cov_mc_insn = 1; hwloop_cov_``TYPE``[i].en_cov_event_loc = 1; \\\n        while (mc_insn_list_in_hwloop_``TYPE``[i].size() != 0) begin \\\n          bit [31:0] insn_item; \\\n          hwloop_evt_loc_t  evt_loc; \\\n          insn_item = mc_insn_list_in_hwloop_``TYPE``[i].pop_front(); \\\n          evt_loc   = hwloop_evt_loc_``TYPE``[i][MC_INSN].pop_front(); \\\n          `uvm_info(_header, $sformatf(\"DEBUG - FOR_CP_HWLOOP_MC_INSN - LOOP_%0d - insn_item is %8h at loc[%s]\", i, insn_item, evt_loc.name()), UVM_DEBUG); \\\n          unique case (i) \\\n            0:  begin \\\n                  `CG_FEATURES_OF_HWLOOP(0).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .insn(insn_item), .evt_loc(evt_loc)); \\\n                end \\\n            1:  begin  \\\n                  `CG_FEATURES_OF_HWLOOP(1).sample(.lp_idx(i), .hwloop_stat(hwloop_stat_``TYPE``), .hwloop_cov(hwloop_cov_``TYPE``[i]), .insn(insn_item), .evt_loc(evt_loc)); \\\n                end \\\n          endcase \\\n        end \\\n        hwloop_evt_loc_``TYPE``[i][MC_INSN].delete(); \\\n        hwloop_cov_``TYPE``[i].en_cov_mc_insn = 0; \\\n        lpend_has_pending_irq_``TYPE``[i]     = 0; \\\n        done_insn_list_capture_``TYPE``[i]    = 0; \\\n        done_insn_list_capture_d1_``TYPE``[i] = 0; \\\n        hwloop_cov_``TYPE``[i]                = hwloop_cov_init[i]; \\\n      end // for HWLOOP_NB \\\n      csr_hwloop_``TYPE``     = csr_hwloop_init; \\\n      hwloop_stat_``TYPE``    = hwloop_stat_init; \\\n      in_nested_loop0         = 0; \\\n      in_nested_loop0_d1      = 0; \\\n    end // SAMPLE_END_OF_HWLOOPS \\\n  endtask : check_n_sample_hwloop_``TYPE``\n\n  `DEF_CHECK_N_SAMPLE_HWLOOP(main)\n  // `DEF_CHECK_N_SAMPLE_HWLOOP(sub)\n\n\n  function void check_exception_entry(int lp_idx);\n      exception_code = exception_code_t'(cv32e40p_rvvi_vif.csr_mcause_ecp_code);\n      case (exception_code)\n        CODE_EBREAK :  begin\n          if (lp_idx)  begin `IF_CURRENT_IS_MAIN_HWLOOP(1, EXCP_EBREAK) end\n          else         begin `IF_CURRENT_IS_MAIN_HWLOOP(0, EXCP_EBREAK) end \n        end\n        CODE_ECALL :   begin\n          if (lp_idx)  begin `IF_CURRENT_IS_MAIN_HWLOOP(1, EXCP_ECALL) end\n          else         begin `IF_CURRENT_IS_MAIN_HWLOOP(0, EXCP_ECALL) end \n        end\n        CODE_ILLEGAL : begin\n          if (lp_idx)  begin `IF_CURRENT_IS_MAIN_HWLOOP(1, EXCP_ILLEGAL) end\n          else         begin `IF_CURRENT_IS_MAIN_HWLOOP(0, EXCP_ILLEGAL) end \n        end\n        default: begin `uvm_error(_header, $sformatf(\"DEBUG - Invalid csr_mcause_ecp_code %5d\", cv32e40p_rvvi_vif.csr_mcause_ecp_code)); end\n      endcase\n  endfunction : check_exception_entry\n\n  function void check_ebreakm_entry(int lp_idx);\n    if (cv32e40p_rvvi_vif.csr_dcsr_ebreakm && cv32e40p_rvvi_vif.insn == TB_INSTR_EBREAK) begin\n      if (lp_idx) begin `IF_CURRENT_IS_MAIN_HWLOOP(1, DBG_EBREAKM) end\n      else        begin `IF_CURRENT_IS_MAIN_HWLOOP(0, DBG_EBREAKM) end \n    end\n  endfunction : check_ebreakm_entry\n\n  function void check_exception_exit();\n    if (cv32e40p_rvvi_vif.valid && cv32e40p_rvvi_vif.insn == TB_INSTR_MRET && !cv32e40p_rvvi_vif.trap) begin\n      is_ebreak = 0; is_ecall = 0; is_illegal = 0; is_trap = 0;\n      `uvm_info(_header, $sformatf(\"DEBUG - EXCEPTION Exit\"), UVM_DEBUG);\n    end\n  endfunction : check_exception_exit\n\n  function void update_prev_irq_onehot_priority();\n    prev_irq_onehot_priority = cv32e40p_rvvi_vif.irq_onehot_priority;\n  endfunction : update_prev_irq_onehot_priority\n\n  function bit pc_is_mtvec_addr();\n    if (cv32e40p_rvvi_vif.pc_rdata >= cv32e40p_rvvi_vif.mtvec_base_addr && cv32e40p_rvvi_vif.pc_rdata < (cv32e40p_rvvi_vif.mtvec_base_addr + 32*4)) return 1; // direct or vector mode\n    else return 0;\n  endfunction : pc_is_mtvec_addr\n\n  function bit is_mcause_irq();\n    return cv32e40p_rvvi_vif.csr_mcause_irq;\n  endfunction : is_mcause_irq\n\n  task run_phase(uvm_phase phase);\n    super.run_phase(phase);\n    wait(en_cvg_sampling);\n\n    fork // Background threads - START\n\n      forever begin : SET_EXCEPTION_FLAG\n        wait (cv32e40p_rvvi_vif.clk && cv32e40p_rvvi_vif.valid && cv32e40p_rvvi_vif.trap);\n        if (\n          cv32e40p_rvvi_vif.csr_trig_execute && cv32e40p_rvvi_vif.csr_trig_pc == cv32e40p_rvvi_vif.pc_rdata // debug trig match assert trap\n        ) begin\n          is_trap = 0;\n          wait (!cv32e40p_rvvi_vif.trap); // bypass and do nothing\n          has_trap_due2_dbg_match_trig = 1;\n        end\n        else if (\n            ((cv32e40p_rvvi_vif.irq_onehot_priority == 0 && prev_irq_onehot_priority == 0) || prev_irq_onehot_priority_is_0 || cv32e40p_rvvi_vif.csr_dcsr_step) && \n            !pending_irq && !is_dbg_mode && !is_irq) begin // set excep flag only if no pending irq, not in irq and not in dbg mode\n          is_trap = 1;\n          case (cv32e40p_rvvi_vif.insn)\n            TB_INSTR_EBREAK, INSTR_CBREAK : if (cv32e40p_rvvi_vif.csr_dcsr_ebreakm) begin \n                                              is_trap = 0;\n                                              @(posedge cv32e40p_rvvi_vif.clk); continue; \n                                            end \n                                            else begin is_ebreak  = 1; `uvm_info(_header, $sformatf(\"DEBUG - EXCEPTION Entry due to EBREAK\"), UVM_DEBUG); end\n            TB_INSTR_ECALL                : begin      is_ecall   = 1; `uvm_info(_header, $sformatf(\"DEBUG - EXCEPTION Entry due to ECALL\"), UVM_DEBUG); end\n            default                       : begin      is_illegal = 1; `uvm_info(_header, $sformatf(\"DEBUG - EXCEPTION Entry due to ILLEGAL\"), UVM_DEBUG); end\n          endcase\n          wait (!(is_ebreak | is_ecall | is_illegal));\n        end\n        else begin \n          is_trap = 0;\n          wait (!cv32e40p_rvvi_vif.trap); \n        end // bypass if pending irq exist\n      end // EXCEPTION_HANDLING\n\n      forever begin : SET_PENDING_IRQ_FLAG\n        @(negedge cv32e40p_rvvi_vif.clk);\n        if (cv32e40p_rvvi_vif.irq_onehot_priority !== prev_irq_onehot_priority) begin\n          pending_irq = 0;\n          prev_irq_onehot_priority_is_0 = 0;\n          if (enter_hwloop_sub) update_prev_irq_onehot_priority(); // within excp period\n          else if ((hwloop_stat_main.execute_instr_in_hwloop[0] | hwloop_stat_main.execute_instr_in_hwloop[1])) begin // within main loop\n            if (prev_irq_onehot_priority === 0) begin prev_irq_onehot_priority_is_0 = 1; update_prev_irq_onehot_priority(); end // new pending\n            else begin // last irq or any pending irq(s)\n              if (!is_irq) pending_irq = 1;\n              else begin \n                repeat(2) @(negedge cv32e40p_rvvi_vif.clk);\n                if (!is_irq) pending_irq = 1;\n                else update_prev_irq_onehot_priority();\n              end\n            end\n          end\n          else begin update_prev_irq_onehot_priority(); end // outside hwloop period\n        end\n      end // SET_PENDING_IRQ_FLAG\n      forever begin : IRQ_EXIT\n        wait (hwloop_stat_main.execute_instr_in_hwloop[0] | hwloop_stat_main.execute_instr_in_hwloop[1]);\n        @(posedge cv32e40p_rvvi_vif.clk);\n        if (is_irq && cv32e40p_rvvi_vif.valid && cv32e40p_rvvi_vif.insn == TB_INSTR_MRET) begin\n          `uvm_info(_header, $sformatf(\"DEBUG - IRQ Exit\"), UVM_DEBUG);\n          is_irq = 0;\n        end\n      end // IRQ_EXIT\n      forever begin : SIGNALS_CHG_WHEN_IS_IRQ_ASSERT\n        @(posedge is_irq);\n        if (is_ebreakm) begin // TBD: will ebreakm assert trap?\n          for (int j=0; j<HWLOOP_NB; j++) begin\n            logic [31:0] discarded_insn;\n            if (hwloop_stat_main.execute_instr_in_hwloop[j] && lpend_has_pending_irq_main[j]) begin \n              discarded_insn = insn_list_in_hwloop_main[j].pop_back();\n              assert(discarded_insn == INSN_EBREAKM);\n              void'(hwloop_evt_loc_main[j][DBG_EBREAKM].pop_back());\n              hwloop_stat_main.track_lp_cnt[j]++; lpend_has_pending_irq_main[j] = 0;\n            end\n          end // for\n        end\n      end // SIGNALS_CHG_WHEN_IS_IRQ_ASSERT\n\n      forever begin : DBG_ENTRY\n        // wait (hwloop_stat_main.execute_instr_in_hwloop[0] | hwloop_stat_main.execute_instr_in_hwloop[1]);\n        wait (!is_dbg_mode);\n        wait (cv32e40p_rvvi_vif.clk && cv32e40p_rvvi_vif.valid && cv32e40p_rvvi_vif.pc_rdata == cv32e40p_rvvi_vif.dm_halt_addr && dcsr_cause_t'(cv32e40p_rvvi_vif.csr_dcsr_cause) inside {EBREAKM, TRIGGER, HALTREQ, STEP}) begin\n          dcsr_cause = dcsr_cause_t'(cv32e40p_rvvi_vif.csr_dcsr_cause);\n          is_dbg_mode = 1;\n          unique case(dcsr_cause)\n            EBREAKM : begin /* do nothing */ end\n            TRIGGER : begin\n                        if (hwloop_stat_main.execute_instr_in_hwloop[1] && !(in_nested_loop0|in_nested_loop0_d1)) begin `IF_CURRENT_IS_MAIN_HWLOOP(1, DBG_TRIG) end\n                        else                                                                                      begin `IF_CURRENT_IS_MAIN_HWLOOP(0, DBG_TRIG) end\n                      end\n            HALTREQ : begin\n                        if (hwloop_stat_main.execute_instr_in_hwloop[1] && !(in_nested_loop0|in_nested_loop0_d1)) begin `IF_CURRENT_IS_MAIN_HWLOOP(1, DBG_HALTREQ) end\n                        else                                                                                      begin `IF_CURRENT_IS_MAIN_HWLOOP(0, DBG_HALTREQ) end\n                      end\n            STEP    : begin\n                        if (hwloop_stat_main.execute_instr_in_hwloop[1] && !(in_nested_loop0|in_nested_loop0_d1)) begin `IF_CURRENT_IS_MAIN_HWLOOP(1, DBG_STEP) end\n                        else                                                                                      begin `IF_CURRENT_IS_MAIN_HWLOOP(0, DBG_STEP) end\n                      end\n          endcase\n          `uvm_info(_header, $sformatf(\"DEBUG - Debug Mode Entry due to %s\", dcsr_cause.name()), UVM_DEBUG);\n        end\n      end // DBG_ENTRY\n      forever begin : DBG_EXIT\n        // wait (hwloop_stat_main.execute_instr_in_hwloop[0] | hwloop_stat_main.execute_instr_in_hwloop[1]);\n        wait (is_dbg_mode);\n        wait (cv32e40p_rvvi_vif.clk && cv32e40p_rvvi_vif.valid && cv32e40p_rvvi_vif.insn == TB_INSTR_DRET) begin\n          @(posedge cv32e40p_rvvi_vif.clk) ; @(negedge cv32e40p_rvvi_vif.clk);\n          `uvm_info(_header, $sformatf(\"DEBUG - Debug Mode Exit\"), UVM_DEBUG);\n          is_dbg_mode = 0; is_ebreakm = 0;\n        end\n      end // DBG_EXIT\n      forever begin : SIGNALS_CHG_WHEN_IS_DBG_MODE_ASSERT\n        @(posedge is_dbg_mode);\n        lpend_has_pending_irq_main[0] = 0; \n        lpend_has_pending_irq_main[1] = 0;\n      end // SIGNALS_CHG_WHEN_IS_DBG_MODE_ASSERT\n\n    join_none // Background threads - END\n\n    forever begin\n      @(posedge cv32e40p_rvvi_vif.clk);\n      if (cv32e40p_rvvi_vif.valid) begin : VALID_IS_HIGH\n\n        if (enter_hwloop_sub) begin \n          enter_hwloop_sub_cnt++;\n          if (is_trap && is_dbg_mode && !cv32e40p_rvvi_vif.csr_dcsr_step && enter_hwloop_sub_cnt == 1) begin : TRAP_DUETO_DBG_ENTRY // exception trap and debug are b2b cycles (except debug step)\n            has_pending_trap_due2_dbg = 1; is_trap = 0; \n            enter_hwloop_sub = 0; enter_hwloop_sub_cnt = 0;\n          end // TRAP_DUETO_DBG_ENTRY\n          else if (pc_is_mtvec_addr() && !is_mcause_irq()) begin : EXCEPTION_ENTRY\n            for (int i=0; i<HWLOOP_NB; i++) begin\n              if (hwloop_stat_main.execute_instr_in_hwloop[i] && !done_insn_list_capture_d1_main[i]) begin\n              case (i)\n                0: check_exception_entry(i);\n                1: begin\n                    if (in_nested_loop0) continue;\n                    else check_exception_entry(i);\n                   end\n              endcase\n              end\n            end\n          end // EXCEPTION_ENTRY\n          else if (pc_is_mtvec_addr() && is_mcause_irq()) begin : IRQ_ENTRY\n            if (hwloop_stat_main.execute_instr_in_hwloop[0] | hwloop_stat_main.execute_instr_in_hwloop[1]) begin\n              if (is_trap && enter_hwloop_sub_cnt == 1) begin : TRAP_DUETO_IRQ_ENTRY // exception trap and irq are b2b cycles\n                if (hwloop_stat_main.execute_instr_in_hwloop[0] && lpend_has_pending_irq_main[0]) begin hwloop_stat_main.track_lp_cnt[0]++; lpend_has_pending_irq_main[0] = 0; end\n                if (hwloop_stat_main.execute_instr_in_hwloop[1] && lpend_has_pending_irq_main[1]) begin hwloop_stat_main.track_lp_cnt[1]++; lpend_has_pending_irq_main[1] = 0; end\n                has_pending_trap_due2_irq = 1; is_trap = 0;\n                enter_hwloop_sub = 0; enter_hwloop_sub_cnt = 0;\n                pending_irq = 0;\n                `uvm_info(_header, $sformatf(\"DEBUG - EXCEPTION Entry is replaced with IRQ Entry (higher priority)\"), UVM_DEBUG);\n                `IF_CURRENT_IS_MAIN_HWLOOP(0, IS_IRQ)\n                `IF_CURRENT_IS_MAIN_HWLOOP(1, IS_IRQ)\n                update_prev_irq_onehot_priority();\n                `uvm_info(_header, $sformatf(\"DEBUG - IRQ Entry\"), UVM_DEBUG);\n              end // TRAP_DUETO_IRQ_ENTRY\n              is_irq = 1; wait (!is_irq); continue; \n            end\n          end // IRQ_ENTRY\n\n          // [optional] todo: for hwloops that outside main code (e.g irq only, dbg only, or irq->dbg); currently commented out due to pending for implementation\n          // `CHECK_N_SAMPLE_CSR_HWLOOP(sub);\n          // `CHECK_N_SAMPLE_HWLOOP(sub);\n          // [optional] todo: mie has effect on irq during exception. Current hwloop tests do not exercise nested irq with mie enabled\n\n          check_exception_exit();\n          if (!(is_ebreak || is_ecall || is_illegal || has_pending_trap_due2_dbg || has_pending_trap_due2_irq)) begin enter_hwloop_sub = 0; enter_hwloop_sub_cnt = 0; end\n          prev_pc_rdata_sub = cv32e40p_rvvi_vif.pc_rdata;\n        end\n\n        else begin : MAIN\n          if (pc_is_mtvec_addr() && is_mcause_irq()) begin : IRQ_ENTRY\n            if (hwloop_stat_main.execute_instr_in_hwloop[0] | hwloop_stat_main.execute_instr_in_hwloop[1]) begin\n              pending_irq = 0;\n              `IF_CURRENT_IS_MAIN_HWLOOP(0, IS_IRQ)\n              `IF_CURRENT_IS_MAIN_HWLOOP(1, IS_IRQ)\n              update_prev_irq_onehot_priority();\n              `uvm_info(_header, $sformatf(\"DEBUG - IRQ Entry\"), UVM_DEBUG);\n              if (lpend_has_pending_irq_main[0]) begin hwloop_stat_main.track_lp_cnt[0]++; lpend_has_pending_irq_main[0] = 0; end\n              if (lpend_has_pending_irq_main[1]) begin hwloop_stat_main.track_lp_cnt[1]++; lpend_has_pending_irq_main[1] = 0; end\n              is_irq = 1; wait (!is_irq); continue; \n            end\n          end // IRQ_ENTRY\n          if (has_pending_trap_due2_irq)  begin\n            assert(prev_pc_rdata_main == cv32e40p_rvvi_vif.pc_rdata);\n            if (pc_is_mtvec_addr() || (cv32e40p_rvvi_vif.trap && is_trap)) begin is_trap = 1; enter_hwloop_sub = 1; has_pending_trap_due2_irq = 0; continue; end // if pc is exception related\n            else begin              is_ebreak = 0; is_ecall = 0; is_illegal = 0; is_trap = 0; enter_hwloop_sub = 0; has_pending_trap_due2_irq = 0; continue; end // if pc is non-exception related\n          end\n          if (is_dbg_mode)                begin wait (!is_dbg_mode); continue; end\n          if (has_pending_trap_due2_dbg)  begin // e.g exception event intercept with debug step\n            assert(!cv32e40p_rvvi_vif.csr_dcsr_step); // this is not mean for step debug\n            if (pc_is_mtvec_addr() || (cv32e40p_rvvi_vif.trap && is_trap)) begin is_trap = 1; enter_hwloop_sub = 1; has_pending_trap_due2_dbg = 0; continue; end // if pc is exception related\n            else begin              is_ebreak = 0; is_ecall = 0; is_illegal = 0; is_trap = 0; enter_hwloop_sub = 0; has_pending_trap_due2_dbg = 0; continue; end // if pc is non-exception related\n          end\n          if (has_trap_due2_dbg_match_trig) begin // e.g exception event intercept with debug trigger\n            has_trap_due2_dbg_match_trig = 0;\n          end\n          if (cv32e40p_rvvi_vif.csr_dcsr_ebreakm && cv32e40p_rvvi_vif.insn == TB_INSTR_EBREAK) is_ebreakm = 1; else is_ebreakm = 0;\n          `CHECK_N_SAMPLE_CSR_HWLOOP(main);\n          `CHECK_N_SAMPLE_HWLOOP(main);\n          if (is_ebreak || is_ecall || is_illegal) enter_hwloop_sub = 1;\n          prev_pc_rdata_main = cv32e40p_rvvi_vif.pc_rdata;\n        end\n\n      end // VALID_DETECTED\n    end // forever\n\n  endtask : run_phase\n\n  function void final_phase(uvm_phase phase);\n    super.final_phase(phase);\n    if (hwloop_stat_main == hwloop_stat_init) begin\n      `uvm_info(_header, $sformatf(\"DEBUG - No prematured hwloops when test done\"), UVM_DEBUG);\n    end\n    else begin\n      `uvm_error(_header, $sformatf(\"Detected prematured hwloops when test done. Please debug ... \"));\n    end\n  endfunction : final_phase\n\n  function bit is_pc_equal_lpstart(s_csr_hwloop csr_hwloop, int csr_idx=0, int fwd_offset=0, logic [31:0] pc_rdata);\n    if (pc_rdata == csr_hwloop.lp_start[csr_idx]+(fwd_offset*4)) return 1;\n    else return 0; \n  endfunction: is_pc_equal_lpstart\n\n  function bit is_pc_equal_lpend(s_csr_hwloop csr_hwloop, int csr_idx=0, int rvs_offset=0, logic [31:0] pc_rdata);\n    if (pc_rdata == csr_hwloop.lp_end[csr_idx]-4-(rvs_offset*4)) return 1;\n    else return 0; \n  endfunction: is_pc_equal_lpend\n\n  function bit is_pc_within_lp(s_csr_hwloop csr_hwloop, int csr_idx=0, logic [31:0] pc_rdata);\n    if (pc_rdata >= csr_hwloop.lp_start[csr_idx] && cv32e40p_rvvi_vif.pc_rdata <= csr_hwloop.lp_end[csr_idx]-4) return 1;\n    else return 0;\n  endfunction : is_pc_within_lp\n\nendclass : uvme_rv32x_hwloop_covg\n\n`endif\n","lang":"verilog"};
processSrcData(g_data);