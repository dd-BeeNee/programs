var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/env/uvme/cov/uvme_interrupt_covg_v2.sv","src":"///////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2023 OpenHW Group\n// Copyright 2024 Dolphin Design\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://solderpad.org/licenses/\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier:Apache-2.0 WITH SHL-2.0\n//*******************************************************************************************************************************************\n\n// Note: \n// 1) This coverage model is to replace v1 model (uvme_interrupt_covg)\n// 2) all cvg have similar cvgs as defined in v1 model\n// 3) It uses uvmt_cv32e40p_rvvi_if\n\n`ifndef UVME_INTERRUPT_COVG_V2\n`define UVME_INTERRUPT_COVG_V2\n\nclass uvme_interrupt_covg_v2 # (\n  parameter int ILEN    = 32,\n  parameter int XLEN    = 32\n) extends uvm_component;\n\n  // PROPERTIES - START\n  virtual             uvmt_cv32e40p_rvvi_if #( .XLEN(XLEN), .ILEN(ILEN)) cv32e40p_rvvi_vif;\n\n  string              _header           = \"INTERRUPT_COVG_V2\";\n  bit                 en_cvg_sampling   = 1;\n  int unsigned        irq_nested_count  = 0;\n  bit                 is_irq            = 0;\n  bit                 is_wfi            = 0;\n  bit                 is_trap           = 0;\n  logic [(ILEN-1):0]  current_insn      = '{default:0};\n  logic [(ILEN-1):0]  prev_insn         = '{default:0};\n  logic [(ILEN-1):0]  prev_insn_d       = '{default:0};\n  // PROPERTIES - END\n    \n  // COVERGROUPS DEFINE HERE - START\n  `define CG_INTERRUPT(EVENT) cg_``EVENT``\n  `define DEF_CG_INTERRUPT(EVENT) covergroup cg_``EVENT`` (bit has_ignore_irq_entry=0, bit has_ignore_irq_exit=0) with function sample(logic [31:0] insn=32'b0); \\\n    option.per_instance         = 1; \\\n    `ifdef MODEL_TECH \\\n    option.get_inst_coverage    = 1; \\\n    `endif \\\n    type_option.merge_instances = 1; \\\n    cp_insn_list : coverpoint (insn) iff (en_cvg_sampling) { \\\n      wildcard bins lui     = {TB_INSTR_LUI}; \\\n      wildcard bins auipc   = {TB_INSTR_AUIPC}; \\\n      // BRANCH / JUMP \\\n      `JUMP_INSTR_BINS \\\n      `BRANCH_INSTR_BINS \\\n      // OPIMM -  \\\n      `OPIMM_INSTR_BINS \\\n      // OP - \\\n      `OP_INSTR_BINS \\\n      // SYSTEM - \\\n      wildcard bins csrrw   = {TB_INSTR_CSRRW}; \\\n      wildcard bins csrrs   = {TB_INSTR_CSRRS}; \\\n      wildcard bins csrrc   = {TB_INSTR_CSRRC}; \\\n      wildcard bins csrrwi  = {TB_INSTR_CSRRWI}; \\\n      wildcard bins csrrsi  = {TB_INSTR_CSRRSI}; \\\n      wildcard bins csrrci  = {TB_INSTR_CSRRCI}; \\\n      wildcard bins mret    = {TB_INSTR_MRET}; \\\n      wildcard bins dret    = {TB_INSTR_DRET}; \\\n      wildcard bins wfi     = {TB_INSTR_WFI}; \\\n      // FENCE - \\\n      `FENCE_INSTR_BINS \\\n      // RV32M - \\\n      `RV32M_INSTR_BINS \\\n      // LOAD STORE - \\\n      `LOAD_STORE_INSTR_BINS \\\n      // RV32C \\\n      `RV32C_INSTR_BINS \\\n      // RV32F/ZFINX - \\\n      `ifdef FPU \\\n        `ifdef ZFINX \\\n          `ZFINX_INSTR_BINS \\\n        `else \\\n          `RV32F_INSTR_BINS \\\n        `endif \\\n      `endif \\\n      // RV32X - \\\n      `RV32X_PULP_INSTR_BINS \\\n      // Ignore bins \\\n      ignore_bins ebreak_excp   = {TB_INSTR_EBREAK}   with ((item == TB_INSTR_EBREAK)   && has_ignore_irq_entry); \\\n      ignore_bins c_ebreak_excp = {TB_INSTR_C_EBREAK} with ((item == TB_INSTR_C_EBREAK) && has_ignore_irq_entry); \\\n      ignore_bins ecal_excp     = {TB_INSTR_ECALL}    with ((item == TB_INSTR_ECALL)    && has_ignore_irq_entry); \\\n      ignore_bins mret_excp     = {TB_INSTR_MRET}     with ((item == TB_INSTR_MRET)     && has_ignore_irq_exit); \\\n      ignore_bins dret_excp     = {TB_INSTR_DRET}     with ((item == TB_INSTR_DRET)     && has_ignore_irq_exit); \\\n    } \\\n  endgroup : cg_``EVENT``\n\n  `DEF_CG_INTERRUPT(irq_entry)\n  `DEF_CG_INTERRUPT(irq_exit)\n  `DEF_CG_INTERRUPT(wfi_entry)\n  `DEF_CG_INTERRUPT(wfi_exit)\n  // COVERGROUPS DEFINE HERE - END\n\n  `uvm_component_utils(uvme_interrupt_covg_v2)\n\n  function new(string name=\"uvme_interrupt_covg_v2\", uvm_component parent=null);\n    super.new(name, parent);\n    `CG_INTERRUPT(irq_entry) = new(.has_ignore_irq_entry(1), .has_ignore_irq_exit(0));\n    `CG_INTERRUPT(irq_exit)  = new(.has_ignore_irq_entry(0), .has_ignore_irq_exit(1));\n    `CG_INTERRUPT(wfi_entry) = new(.has_ignore_irq_entry(0), .has_ignore_irq_exit(0));\n    `CG_INTERRUPT(wfi_exit)  = new(.has_ignore_irq_entry(0), .has_ignore_irq_exit(0));\n    `CG_INTERRUPT(irq_entry).set_inst_name($sformatf(\"cg_irq_entry\"));\n    `CG_INTERRUPT(irq_exit).set_inst_name( $sformatf(\"cg_irq_exit\"));\n    `CG_INTERRUPT(wfi_entry).set_inst_name($sformatf(\"cg_wfi_entry\"));\n    `CG_INTERRUPT(wfi_exit).set_inst_name( $sformatf(\"cg_wfi_exit\"));\n  endfunction: new\n\n  function void build_phase(uvm_phase phase);\n    super.build_phase(phase);\n    if (!(uvm_config_db#(virtual uvmt_cv32e40p_rvvi_if)::get(this, \"\", \"cv32e40p_rvvi_vif\", cv32e40p_rvvi_vif))) begin\n        `uvm_fatal(_header, \"cv32e40p_rvvi_vif no found in uvm_config_db\");\n    end\n    if ($test$plusargs(\"skip_sampling_uvme_interrupt_covg_v2\")) begin\n      `uvm_info(_header, \"Skip uvme_interrupt_covg_v2 cvg sampling due to test intention\", UVM_WARNING);\n      en_cvg_sampling = 0;\n    end\n  endfunction : build_phase\n\n  function bit pc_is_mtvec_addr();\n    if (cv32e40p_rvvi_vif.pc_rdata >= cv32e40p_rvvi_vif.mtvec_base_addr && cv32e40p_rvvi_vif.pc_rdata < (cv32e40p_rvvi_vif.mtvec_base_addr + 32*4)) return 1; // direct or vector mode\n    else return 0;\n  endfunction : pc_is_mtvec_addr\n\n  function bit is_mcause_irq();\n    return cv32e40p_rvvi_vif.csr_mcause_irq;\n  endfunction : is_mcause_irq\n\n  // illegal instruction - ecall - ebreak - compress\n  task run_phase(uvm_phase phase);\n    super.run_phase(phase);\n\n    forever begin\n      @(posedge cv32e40p_rvvi_vif.clk);\n      if (cv32e40p_rvvi_vif.valid) begin : VALID_IS_HIGH\n\n        current_insn = get_user_def_c_insn_if_true(cv32e40p_rvvi_vif.insn);\n        if (cv32e40p_rvvi_vif.trap) is_trap = 1;\n        else is_trap = 0;\n\n        // IRQ related - START\n        if (current_insn == TB_INSTR_MRET && is_irq) begin\n          irq_nested_count--;\n        end\n        if (prev_insn == TB_INSTR_MRET && is_irq) begin : IRQ_EXIT\n          `uvm_info(_header, $sformatf(\"DEBUG - IRQ Exit  - current_insn is '%8h\", current_insn), UVM_DEBUG);\n          `CG_INTERRUPT(irq_exit).sample(current_insn); // sample insn after irq exit\n          is_irq = 0;\n        end\n        if (pc_is_mtvec_addr() && is_mcause_irq()) begin : IRQ_ENTRY\n          `uvm_info(_header, $sformatf(\"DEBUG - IRQ Entry - prev_insn    is '%8h\", (is_trap) ? prev_insn_d : prev_insn), UVM_DEBUG);\n          irq_nested_count++;\n          if (is_trap) begin `CG_INTERRUPT(irq_entry).sample(prev_insn_d); end  // sample insn before irq entry (insn prior trap)\n          else begin         `CG_INTERRUPT(irq_entry).sample(prev_insn); end    // sample insn before irq entry\n          is_irq = 1;\n        end\n        // IRQ related - END\n\n        // WFI related - START\n        if (is_wfi && prev_insn == TB_INSTR_WFI) begin : WFI_EXIT\n          `uvm_info(_header, $sformatf(\"DEBUG - WFI Exit  - current_insn is '%8h\", current_insn), UVM_DEBUG);\n          `CG_INTERRUPT(wfi_exit).sample(current_insn); // sample insn after wfi exit\n          is_wfi = 0;\n        end\n        if (current_insn == TB_INSTR_WFI) begin : WFI_ENTRY\n          `uvm_info(_header, $sformatf(\"DEBUG - WFI Entry - prev_insn    is '%8h\", prev_insn), UVM_DEBUG);\n          `CG_INTERRUPT(wfi_entry).sample(prev_insn); // sample insn before wfi entry\n          is_wfi = 1;\n        end\n        // WFI related - END\n\n        prev_insn_d = prev_insn;\n        prev_insn   = current_insn;\n      end\n    end // forever\n\n  endtask : run_phase\n\n  function void final_phase(uvm_phase phase);\n    super.final_phase(phase);\n    // assert(irq_nested_count == 0);\n  endfunction : final_phase\n\nendclass : uvme_interrupt_covg_v2\n\n`endif\n","lang":"verilog"};
processSrcData(g_data);