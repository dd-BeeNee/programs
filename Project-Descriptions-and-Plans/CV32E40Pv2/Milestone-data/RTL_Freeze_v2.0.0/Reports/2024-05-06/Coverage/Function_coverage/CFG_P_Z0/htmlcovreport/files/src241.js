var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_controller.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Matthias Baer - baermatt@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                 Robert Balas - balasr@iis.ee.ethz.ch                       //\n//                 Andrea Bettati - andrea.bettati@studenti.unipr.it          //\n//                                                                            //\n// Design Name:    Main controller                                            //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Main CPU controller of the processor                       //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_controller import cv32e40p_pkg::*;\n#(\n  parameter COREV_CLUSTER = 0,\n  parameter COREV_PULP    = 0,\n  parameter FPU           = 0\n)\n(\n  input  logic        clk,                        // Gated clock\n  input  logic        clk_ungated_i,              // Ungated clock\n  input  logic        rst_n,\n\n  input  logic        fetch_enable_i,             // Start the decoding\n  output logic        ctrl_busy_o,                // Core is busy processing instructions\n  output logic        is_decoding_o,              // Core is in decoding state\n  input  logic        is_fetch_failed_i,\n\n  // decoder related signals\n  output logic        deassert_we_o,              // deassert write enable for next instruction\n\n  input  logic        illegal_insn_i,             // decoder encountered an invalid instruction\n  input  logic        ecall_insn_i,               // decoder encountered an ecall instruction\n  input  logic        mret_insn_i,                // decoder encountered an mret instruction\n  input  logic        uret_insn_i,                // decoder encountered an uret instruction\n\n  input  logic        dret_insn_i,                // decoder encountered an dret instruction\n\n  input  logic        mret_dec_i,\n  input  logic        uret_dec_i,\n  input  logic        dret_dec_i,\n\n  input  logic        wfi_i,                      // decoder wants to execute a WFI\n  input  logic        ebrk_insn_i,                // decoder encountered an ebreak instruction\n  input  logic        fencei_insn_i,              // decoder encountered an fence.i instruction\n  input  logic        csr_status_i,               // decoder encountered an csr status instruction\n\n  output logic        hwlp_mask_o,                // prevent writes on the hwloop instructions in case interrupt are taken\n\n  // from IF/ID pipeline\n  input  logic        instr_valid_i,              // instruction coming from IF/ID pipeline is valid\n\n  // from prefetcher\n  output logic        instr_req_o,                // Start fetching instructions\n\n  // to prefetcher\n  output logic        pc_set_o,                   // jump to address set by pc_mux\n  output logic [3:0]  pc_mux_o,                   // Selector in the Fetch stage to select the rigth PC (normal, jump ...)\n  output logic [2:0]  exc_pc_mux_o,               // Selects target PC for exception\n  output logic [1:0]  trap_addr_mux_o,            // Selects trap address base\n\n  // HWLoop signls\n  input  logic [31:0]       pc_id_i,\n\n  // from hwloop_regs\n  input  logic [1:0] [31:0] hwlp_start_addr_i,\n  input  logic [1:0] [31:0] hwlp_end_addr_i,\n  input  logic [1:0] [31:0] hwlp_counter_i,\n\n  // to hwloop_regs\n  output logic [1:0]        hwlp_dec_cnt_o,\n\n  output logic              hwlp_jump_o,\n  output logic [31:0]       hwlp_targ_addr_o,\n\n  // LSU\n  input  logic        data_req_ex_i,              // data memory access is currently performed in EX stage\n  input  logic        data_we_ex_i,\n  input  logic        data_misaligned_i,\n  input  logic        data_load_event_i,\n  input  logic        data_err_i,\n  output logic        data_err_ack_o,\n\n  // from ALU\n  input  logic        mult_multicycle_i,          // multiplier is taken multiple cycles and uses op c as storage\n\n  // APU dependency checks\n  input  logic        apu_en_i,\n  input  logic        apu_read_dep_i,\n  input  logic        apu_read_dep_for_jalr_i,\n  input  logic        apu_write_dep_i,\n\n  output logic        apu_stall_o,\n\n  // jump/branch signals\n  input  logic        branch_taken_ex_i,          // branch taken signal from EX ALU\n  input  logic [1:0]  ctrl_transfer_insn_in_id_i,               // jump is being calculated in ALU\n  input  logic [1:0]  ctrl_transfer_insn_in_dec_i,              // jump is being calculated in ALU\n\n  // Interrupt Controller Signals\n  input  logic        irq_req_ctrl_i,\n  input  logic        irq_sec_ctrl_i,\n  input  logic [4:0]  irq_id_ctrl_i,\n  input  logic        irq_wu_ctrl_i,\n  input  PrivLvl_t    current_priv_lvl_i,\n\n  output logic        irq_ack_o,\n  output logic [4:0]  irq_id_o,\n\n  output logic [4:0]  exc_cause_o,\n\n  // Debug Signal\n  output logic         debug_mode_o,\n  output logic [2:0]   debug_cause_o,\n  output logic         debug_csr_save_o,\n  input  logic         debug_req_i,\n  input  logic         debug_single_step_i,\n  input  logic         debug_ebreakm_i,\n  input  logic         debug_ebreaku_i,\n  input  logic         trigger_match_i,\n  output logic         debug_p_elw_no_sleep_o,\n  output logic         debug_wfi_no_sleep_o,\n  output logic         debug_havereset_o,\n  output logic         debug_running_o,\n  output logic         debug_halted_o,\n\n  // Wakeup Signal\n  output logic        wake_from_sleep_o,\n\n  output logic        csr_save_if_o,\n  output logic        csr_save_id_o,\n  output logic        csr_save_ex_o,\n  output logic [5:0]  csr_cause_o,\n  output logic        csr_irq_sec_o,\n  output logic        csr_restore_mret_id_o,\n  output logic        csr_restore_uret_id_o,\n\n  output logic        csr_restore_dret_id_o,\n\n  output logic        csr_save_cause_o,\n\n\n  // Regfile target\n  input  logic        regfile_we_id_i,            // currently decoded we enable\n  input  logic [5:0]  regfile_alu_waddr_id_i,     // currently decoded target address\n\n  // Forwarding signals from regfile\n  input  logic        regfile_we_ex_i,            // FW: write enable from  EX stage\n  input  logic [5:0]  regfile_waddr_ex_i,         // FW: write address from EX stage\n  input  logic        regfile_we_wb_i,            // FW: write enable from  WB stage\n  input  logic        regfile_alu_we_fw_i,        // FW: ALU/MUL write enable from  EX stage\n\n  // forwarding signals\n  output logic [1:0]  operand_a_fw_mux_sel_o,     // regfile ra data selector form ID stage\n  output logic [1:0]  operand_b_fw_mux_sel_o,     // regfile rb data selector form ID stage\n  output logic [1:0]  operand_c_fw_mux_sel_o,     // regfile rc data selector form ID stage\n\n  // forwarding detection signals\n  input logic         reg_d_ex_is_reg_a_i,\n  input logic         reg_d_ex_is_reg_b_i,\n  input logic         reg_d_ex_is_reg_c_i,\n  input logic         reg_d_wb_is_reg_a_i,\n  input logic         reg_d_wb_is_reg_b_i,\n  input logic         reg_d_wb_is_reg_c_i,\n  input logic         reg_d_alu_is_reg_a_i,\n  input logic         reg_d_alu_is_reg_b_i,\n  input logic         reg_d_alu_is_reg_c_i,\n\n  // stall signals\n  output logic        halt_if_o,\n  output logic        halt_id_o,\n\n  output logic        misaligned_stall_o,\n  output logic        jr_stall_o,\n  output logic        load_stall_o,\n\n  input  logic        id_ready_i,                 // ID stage is ready\n  input  logic        id_valid_i,                 // ID stage is valid\n\n  input  logic        ex_valid_i,                 // EX stage is done\n\n  input  logic        wb_ready_i,                 // WB stage is ready\n\n  // Performance Counters\n  output logic        perf_pipeline_stall_o       // stall due to cv.elw extra cycles\n);\n\n  // FSM state encoding\n  ctrl_state_e ctrl_fsm_cs, ctrl_fsm_ns;\n\n  // Debug state\n  debug_state_e debug_fsm_cs, debug_fsm_ns;\n\n  logic jump_done, jump_done_q, jump_in_dec, branch_in_id;\n\n  logic data_err_q;\n\n  logic debug_mode_q, debug_mode_n;\n  logic ebrk_force_debug_mode;\n  logic is_hwlp_body;\n  logic illegal_insn_q, illegal_insn_n;\n  logic debug_req_entry_q, debug_req_entry_n;\n  logic debug_force_wakeup_q, debug_force_wakeup_n;\n\n  logic hwlp_end0_eq_pc;\n  logic hwlp_end1_eq_pc;\n  logic hwlp_counter0_gt_1;\n  logic hwlp_counter1_gt_1;\n  logic hwlp_counter0_eq_1;\n  logic hwlp_counter1_eq_1;\n  logic hwlp_counter0_eq_0;\n  logic hwlp_counter1_eq_0;\n  logic hwlp_end0_eq_pc_plus4;\n  logic hwlp_end1_eq_pc_plus4;\n  logic hwlp_start0_leq_pc;\n  logic hwlp_start1_leq_pc;\n  logic hwlp_end0_geq_pc;\n  logic hwlp_end1_geq_pc;\n  // Auxiliary signals to make hwlp_jump_o last only one cycle (converting it into a pulse)\n  logic hwlp_end_4_id_d, hwlp_end_4_id_q;\n\n  logic debug_req_q;\n  logic debug_req_pending;\n\n  // qualify wfi vs nosleep locally \n  logic wfi_active;\n\n\n  ////////////////////////////////////////////////////////////////////////////////////////////\n  //   ____ ___  ____  _____    ____ ___  _   _ _____ ____   ___  _     _     _____ ____    //\n  //  / ___/ _ \\|  _ \\| ____|  / ___/ _ \\| \\ | |_   _|  _ \\ / _ \\| |   | |   | ____|  _ \\   //\n  // | |  | | | | |_) |  _|   | |  | | | |  \\| | | | | |_) | | | | |   | |   |  _| | |_) |  //\n  // | |__| |_| |  _ <| |___  | |__| |_| | |\\  | | | |  _ <| |_| | |___| |___| |___|  _ <   //\n  //  \\____\\___/|_| \\_\\_____|  \\____\\___/|_| \\_| |_| |_| \\_\\\\___/|_____|_____|_____|_| \\_\\  //\n  //                                                                                        //\n  ////////////////////////////////////////////////////////////////////////////////////////////\n\n  always_comb\n  begin\n    // Default values\n\n    instr_req_o            = 1'b1;\n\n    data_err_ack_o         = 1'b0;\n\n    csr_save_if_o          = 1'b0;\n    csr_save_id_o          = 1'b0;\n    csr_save_ex_o          = 1'b0;\n    csr_restore_mret_id_o  = 1'b0;\n    csr_restore_uret_id_o  = 1'b0;\n\n    csr_restore_dret_id_o  = 1'b0;\n\n    csr_save_cause_o       = 1'b0;\n\n    exc_cause_o            = '0;\n    exc_pc_mux_o           = EXC_PC_IRQ;\n    trap_addr_mux_o        = TRAP_MACHINE;\n\n    csr_cause_o            = '0;\n    csr_irq_sec_o          = 1'b0;\n\n    pc_mux_o               = PC_BOOT;\n    pc_set_o               = 1'b0;\n    jump_done              = jump_done_q;\n\n    ctrl_fsm_ns            = ctrl_fsm_cs;\n\n    ctrl_busy_o            = 1'b1;\n\n    halt_if_o              = 1'b0;\n    halt_id_o              = 1'b0;\n    is_decoding_o          = 1'b0;\n    irq_ack_o              = 1'b0;\n    irq_id_o               = 5'b0;\n\n    jump_in_dec            = ctrl_transfer_insn_in_dec_i == BRANCH_JALR || ctrl_transfer_insn_in_dec_i == BRANCH_JAL;\n\n    branch_in_id           = ctrl_transfer_insn_in_id_i == BRANCH_COND;\n\n    ebrk_force_debug_mode  = (debug_ebreakm_i && current_priv_lvl_i == PRIV_LVL_M) ||\n                             (debug_ebreaku_i && current_priv_lvl_i == PRIV_LVL_U);\n    debug_csr_save_o       = 1'b0;\n    debug_cause_o          = DBG_CAUSE_EBREAK;\n    debug_mode_n           = debug_mode_q;\n\n    illegal_insn_n         = illegal_insn_q;\n    // a trap towards the debug unit is generated when one of the\n    // following conditions are true:\n    // - ebreak instruction encountered\n    // - single-stepping mode enabled\n    // - illegal instruction exception and IIE bit is set\n    // - IRQ and INTE bit is set and no exception is currently running\n    // - Debuger requests halt\n\n    debug_req_entry_n       = debug_req_entry_q;\n\n    debug_force_wakeup_n    = debug_force_wakeup_q;\n\n    perf_pipeline_stall_o   = 1'b0;\n\n    hwlp_mask_o             = 1'b0;\n\n    hwlp_dec_cnt_o          = '0;\n    hwlp_end_4_id_d         = 1'b0;\n\n    // When the controller tells to hwlp-jump, the prefetcher does not always jump immediately,\n    // but the aligner immediately modifies pc_id to HWLP_BEGIN. This condition on hwlp_targ_addr_o\n    // ensures that the target is kept constant even if pc_id is no more HWLP_END\n    hwlp_targ_addr_o        = ((hwlp_start1_leq_pc && hwlp_end1_geq_pc) && !(hwlp_start0_leq_pc && hwlp_end0_geq_pc)) ? hwlp_start_addr_i[1] : hwlp_start_addr_i[0];\n\n    unique case (ctrl_fsm_cs)\n      // We were just reset, wait for fetch_enable\n      RESET:\n      begin\n        is_decoding_o = 1'b0;\n        instr_req_o   = 1'b0;\n        if (fetch_enable_i == 1'b1)\n        begin\n          ctrl_fsm_ns = BOOT_SET;\n        end\n      end\n\n      // copy boot address to instr fetch address\n      BOOT_SET:\n      begin\n        is_decoding_o = 1'b0;\n        instr_req_o   = 1'b1;\n        pc_mux_o      = PC_BOOT;\n        pc_set_o      = 1'b1;\n        if (debug_req_pending) begin\n            ctrl_fsm_ns = DBG_TAKEN_IF;\n            debug_force_wakeup_n = 1'b1;\n        end else begin\n            ctrl_fsm_ns   = FIRST_FETCH;\n        end\n      end\n\n      WAIT_SLEEP:\n      begin\n        is_decoding_o = 1'b0;\n        ctrl_busy_o   = 1'b0;\n        instr_req_o   = 1'b0;\n        halt_if_o     = 1'b1;\n        halt_id_o     = 1'b1;\n        ctrl_fsm_ns   = SLEEP;\n      end\n\n      // instruction in if_stage is already valid\n      SLEEP:\n      begin\n        // we begin execution when an\n        // interrupt has arrived\n        is_decoding_o = 1'b0;\n        instr_req_o   = 1'b0;\n        halt_if_o     = 1'b1;\n        halt_id_o     = 1'b1;\n\n        // normal execution flow\n        // in debug mode or single step mode we leave immediately (wfi=nop)\n        if (wake_from_sleep_o) begin\n          if (debug_req_pending) begin\n              ctrl_fsm_ns = DBG_TAKEN_IF;\n              debug_force_wakeup_n = 1'b1;\n          end else begin\n              ctrl_fsm_ns  = FIRST_FETCH;\n          end\n        end else begin\n          ctrl_busy_o = 1'b0;\n        end\n      end\n\n      FIRST_FETCH:\n      begin\n        is_decoding_o = 1'b0;\n\n        // ID stage is always ready\n        ctrl_fsm_ns = DECODE;\n\n        // handle interrupts\n        if (irq_req_ctrl_i && ~(debug_req_pending || debug_mode_q)) begin\n          // This assumes that the pipeline is always flushed before\n          // going to sleep.\n          // Debug mode takes precedence over irq (see DECODE:)\n\n          // Taken IRQ\n          halt_if_o         = 1'b1;\n          halt_id_o         = 1'b1;\n\n          pc_set_o          = 1'b1;\n          pc_mux_o          = PC_EXCEPTION;\n          exc_pc_mux_o      = EXC_PC_IRQ;\n          exc_cause_o       = irq_id_ctrl_i;\n          csr_irq_sec_o     = irq_sec_ctrl_i;\n\n          // IRQ interface\n          irq_ack_o         = 1'b1;\n          irq_id_o          = irq_id_ctrl_i;\n\n          if (irq_sec_ctrl_i)\n            trap_addr_mux_o  = TRAP_MACHINE;\n          else\n            trap_addr_mux_o  = current_priv_lvl_i == PRIV_LVL_U ? TRAP_USER : TRAP_MACHINE;\n\n          csr_save_cause_o  = 1'b1;\n          csr_cause_o       = {1'b1,irq_id_ctrl_i};\n          csr_save_if_o     = 1'b1;\n        end\n      end\n\n      DECODE:\n      begin\n\n          if (branch_taken_ex_i)\n          begin //taken branch\n            // there is a branch in the EX stage that is taken\n\n            is_decoding_o = 1'b0;\n\n            pc_mux_o      = PC_BRANCH;\n            pc_set_o      = 1'b1;\n\n            // if we want to debug, flush the pipeline\n            // the current_pc_if will take the value of the next instruction to\n            // be executed (NPC)\n\n          end  //taken branch\n\n          else if (data_err_i)\n          begin //data error\n            // the current LW or SW have been blocked by the PMP\n\n            is_decoding_o     = 1'b0;\n            halt_if_o         = 1'b1;\n            halt_id_o         = 1'b1;\n            csr_save_ex_o     = 1'b1;\n            csr_save_cause_o  = 1'b1;\n            data_err_ack_o    = 1'b1;\n            //no jump in this stage as we have to wait one cycle to go to Machine Mode\n\n            csr_cause_o       = {1'b0, data_we_ex_i ? EXC_CAUSE_STORE_FAULT : EXC_CAUSE_LOAD_FAULT};\n            ctrl_fsm_ns       = FLUSH_WB;\n\n          end  //data error\n\n          else if (is_fetch_failed_i)\n          begin\n\n            // the current instruction has been blocked by the PMP\n\n            is_decoding_o     = 1'b0;\n            halt_id_o         = 1'b1;\n            halt_if_o         = 1'b1;\n            csr_save_if_o     = 1'b1;\n            csr_save_cause_o  = !debug_mode_q;\n\n            //no jump in this stage as we have to wait one cycle to go to Machine Mode\n\n            csr_cause_o       = {1'b0, EXC_CAUSE_INSTR_FAULT};\n            ctrl_fsm_ns       = FLUSH_WB;\n\n\n          end\n          // decode and execute instructions only if the current conditional\n          // branch in the EX stage is either not taken, or there is no\n          // conditional branch in the EX stage\n          else if (instr_valid_i) //valid block\n          begin: blk_decode_level1 // now analyze the current instruction in the ID stage\n\n            is_decoding_o = 1'b1;\n            illegal_insn_n = 1'b0;\n\n            if ( (debug_req_pending || trigger_match_i) & ~debug_mode_q )\n              begin\n                //Serving the debug\n                is_decoding_o     = COREV_PULP ? 1'b0 : 1'b1;\n                halt_if_o         = 1'b1;\n                halt_id_o         = 1'b1;\n                ctrl_fsm_ns       = DBG_FLUSH;\n                debug_req_entry_n = 1'b1;\n              end\n            else if (irq_req_ctrl_i && ~debug_mode_q)\n              begin\n                // Taken IRQ\n                hwlp_mask_o       = COREV_PULP ? 1'b1 : 1'b0;\n\n                is_decoding_o     = 1'b0;\n                halt_if_o         = 1'b1;\n                halt_id_o         = 1'b1;\n\n                pc_set_o          = 1'b1;\n                pc_mux_o          = PC_EXCEPTION;\n                exc_pc_mux_o      = EXC_PC_IRQ;\n                exc_cause_o       = irq_id_ctrl_i;\n                csr_irq_sec_o     = irq_sec_ctrl_i;\n\n                // IRQ interface\n                irq_ack_o         = 1'b1;\n                irq_id_o          = irq_id_ctrl_i;\n\n                if (irq_sec_ctrl_i)\n                  trap_addr_mux_o  = TRAP_MACHINE;\n                else\n                  trap_addr_mux_o  = current_priv_lvl_i == PRIV_LVL_U ? TRAP_USER : TRAP_MACHINE;\n\n                csr_save_cause_o  = 1'b1;\n                csr_cause_o       = {1'b1,irq_id_ctrl_i};\n                csr_save_id_o     = 1'b1;\n              end\n            else\n              begin\n\n                if (illegal_insn_i) begin\n\n                  halt_if_o         = 1'b1;\n                  halt_id_o         = 1'b0;\n                  ctrl_fsm_ns       = id_ready_i ? FLUSH_EX : DECODE;\n                  illegal_insn_n    = 1'b1;\n\n                end else begin\n\n                  //decoding block\n                  unique case (1'b1)\n\n                    jump_in_dec: begin\n                    // handle unconditional jumps\n                    // we can jump directly since we know the address already\n                    // we don't need to worry about conditional branches here as they\n                    // will be evaluated in the EX stage\n                      pc_mux_o = PC_JUMP;\n                      // if there is a jr stall, wait for it to be gone\n                      if ((~jr_stall_o) && (~jump_done_q)) begin\n                        pc_set_o    = 1'b1;\n                        jump_done   = 1'b1;\n                      end\n                    end\n\n                    ebrk_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n\n                      if (debug_mode_q)\n                        // we got back to the park loop in the debug rom\n                        ctrl_fsm_ns = DBG_FLUSH;\n\n                      else if (ebrk_force_debug_mode) begin\n                        // debug module commands us to enter debug mode anyway\n                        ctrl_fsm_ns  = DBG_FLUSH;\n                      end else begin\n                        // otherwise just a normal ebreak exception\n                        ctrl_fsm_ns = id_ready_i ? FLUSH_EX : DECODE;\n                      end\n\n                    end\n\n                    wfi_active: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns           = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    ecall_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns           = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    fencei_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns           = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    mret_insn_i | uret_insn_i | dret_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns           = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    csr_status_i: begin\n                      halt_if_o     = 1'b1;\n                      if (~id_ready_i) begin\n                        ctrl_fsm_ns = DECODE;\n                      end else begin\n                        ctrl_fsm_ns = FLUSH_EX;\n                        if (hwlp_end0_eq_pc) begin\n                          hwlp_dec_cnt_o[0] = 1'b1;\n                        end\n                        if (hwlp_end1_eq_pc) begin\n                          hwlp_dec_cnt_o[1] = 1'b1;\n                        end\n                      end\n                    end\n\n                    data_load_event_i: begin\n                      ctrl_fsm_ns   = id_ready_i ? ELW_EXE : DECODE;\n                      halt_if_o     = 1'b1;\n                    end\n\n                    default: begin\n\n                      if(is_hwlp_body) begin\n                        //we are at the inside of an HWloop, thus change state\n\n                        //We stay here in case we returned from the second last instruction, otherwise the next cycle\n                        //in DECODE_HWLOOP we miss to jump, we jump at PC_END.\n                        //This way looses a cycle but it's a corner case of returning from exceptions or interrupts\n\n                        ctrl_fsm_ns  = hwlp_end0_eq_pc_plus4 || hwlp_end1_eq_pc_plus4 ? DECODE : DECODE_HWLOOP;\n\n                        // we can be at the end of HWloop due to a return from interrupt or ecall or ebreak or exceptions\n                        if (hwlp_end0_eq_pc && hwlp_counter0_gt_1) begin\n                          pc_mux_o         = PC_HWLOOP;\n                          if (~jump_done_q) begin\n                            pc_set_o          = 1'b1;\n                            // Keep the instruction and the related address in the Aligner if\n                            // ID is stalled during a jump\n                            jump_done         = 1'b1;\n                            hwlp_dec_cnt_o[0] = 1'b1;\n                          end\n                        end\n                        if (hwlp_end1_eq_pc && hwlp_counter1_gt_1) begin\n                          pc_mux_o         = PC_HWLOOP;\n                          if (~jump_done_q) begin\n                            pc_set_o          = 1'b1;\n                            // Keep the instruction and the related address in the Aligner if\n                            // ID is stalled during a jump\n                            jump_done         = 1'b1;\n                            hwlp_dec_cnt_o[1] = 1'b1;\n                          end\n                        end\n                      end\n\n                      if (hwlp_end0_eq_pc && hwlp_counter0_eq_1) begin\n                        hwlp_dec_cnt_o[0] = 1'b1;\n                      end\n                      if (hwlp_end1_eq_pc && hwlp_counter1_eq_1) begin\n                        hwlp_dec_cnt_o[1] = 1'b1;\n                      end\n\n                    end\n\n                  endcase // unique case (1'b1)\n                end\n\n                if (debug_single_step_i & ~debug_mode_q) begin\n                    // prevent any more instructions from executing\n                    halt_if_o = 1'b1;\n\n                    // we don't handle dret here because its should be illegal\n                    // anyway in this context\n\n                    // illegal, ecall, ebrk and xrettransition to later to a DBG\n                    // state since we need the return address which is\n                    // determined later\n\n                    if (id_ready_i) begin\n                    // make sure the current instruction has been executed\n                        unique case(1'b1)\n\n                        illegal_insn_i | ecall_insn_i:\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        (~ebrk_force_debug_mode & ebrk_insn_i):\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        mret_insn_i | uret_insn_i:\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        branch_in_id:\n                        begin\n                            ctrl_fsm_ns    = DBG_WAIT_BRANCH;\n                        end\n\n                        default:\n                            // regular instruction or ebrk force debug\n                            ctrl_fsm_ns = DBG_FLUSH;\n                        endcase // unique case (1'b1)\n                    end\n                end\n\n              end // else: !if (irq_req_ctrl_i && ~debug_mode_q)\n\n          end  //valid block\n          else begin\n            is_decoding_o         = 1'b0;\n            perf_pipeline_stall_o = data_load_event_i;\n          end\n      end\n\n      DECODE_HWLOOP:\n      begin\n        if (COREV_PULP) begin\n          if (instr_valid_i) // valid block\n          begin // now analyze the current instruction in the ID stage\n\n            is_decoding_o = 1'b1;\n\n            if ( (debug_req_pending || trigger_match_i) & ~debug_mode_q )\n              begin\n                //Serving the debug\n                is_decoding_o     = COREV_PULP ? 1'b0 : 1'b1;\n                halt_if_o         = 1'b1;\n                halt_id_o         = 1'b1;\n                ctrl_fsm_ns       = DBG_FLUSH;\n                debug_req_entry_n = 1'b1;\n             end\n            else if (irq_req_ctrl_i && ~debug_mode_q)\n              begin\n                // Taken IRQ\n                hwlp_mask_o       = COREV_PULP ? 1'b1 : 1'b0;\n\n                is_decoding_o     = 1'b0;\n                halt_if_o         = 1'b1;\n                halt_id_o         = 1'b1;\n\n                pc_set_o          = 1'b1;\n                pc_mux_o          = PC_EXCEPTION;\n                exc_pc_mux_o      = EXC_PC_IRQ;\n                exc_cause_o       = irq_id_ctrl_i;\n                csr_irq_sec_o     = irq_sec_ctrl_i;\n\n                // IRQ interface\n                irq_ack_o         = 1'b1;\n                irq_id_o          = irq_id_ctrl_i;\n\n                if (irq_sec_ctrl_i)\n                  trap_addr_mux_o  = TRAP_MACHINE;\n                else\n                  trap_addr_mux_o  = current_priv_lvl_i == PRIV_LVL_U ? TRAP_USER : TRAP_MACHINE;\n\n                csr_save_cause_o  = 1'b1;\n                csr_cause_o       = {1'b1,irq_id_ctrl_i};\n                csr_save_id_o     = 1'b1;\n\n                ctrl_fsm_ns       = DECODE;\n              end\n            else\n              begin\n\n                if (illegal_insn_i) begin\n\n                  halt_if_o         = 1'b1;\n                  halt_id_o         = 1'b1;\n                  ctrl_fsm_ns       = FLUSH_EX;\n                  illegal_insn_n    = 1'b1;\n\n                end else begin\n\n                  //decoding block\n                  unique case (1'b1)\n\n                    ebrk_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n\n                      if (debug_mode_q)\n                        // we got back to the park loop in the debug rom\n                        ctrl_fsm_ns = DBG_FLUSH;\n\n                      else if (ebrk_force_debug_mode)\n                        // debug module commands us to enter debug mode anyway\n                        ctrl_fsm_ns  = DBG_FLUSH;\n\n                      else begin\n                        // otherwise just a normal ebreak exception\n                        ctrl_fsm_ns = id_ready_i ? FLUSH_EX : DECODE_HWLOOP;\n                      end\n\n                    end\n\n                    ecall_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns   = id_ready_i ? FLUSH_EX : DECODE_HWLOOP;\n                    end\n\n                    csr_status_i: begin\n                      halt_if_o     = 1'b1;\n                      if (~id_ready_i) begin\n                        ctrl_fsm_ns = DECODE_HWLOOP;\n                      end else begin\n                        ctrl_fsm_ns = FLUSH_EX;\n                        if (hwlp_end0_eq_pc) begin\n                          hwlp_dec_cnt_o[0] = 1'b1;\n                        end\n                        if (hwlp_end1_eq_pc) begin\n                          hwlp_dec_cnt_o[1] = 1'b1;\n                        end\n                      end\n                    end\n\n                    data_load_event_i: begin\n                      ctrl_fsm_ns   = id_ready_i ? ELW_EXE : DECODE_HWLOOP;\n                      halt_if_o     = 1'b1;\n                    end\n\n                    default: begin\n\n                       // we can be at the end of HWloop due to a return from interrupt or ecall or ebreak or exceptions\n                      if(hwlp_end1_eq_pc_plus4) begin\n                          if(hwlp_counter1_gt_1) begin\n                            hwlp_end_4_id_d  = 1'b1;\n                            hwlp_targ_addr_o = hwlp_start_addr_i[1];\n                            ctrl_fsm_ns      = DECODE_HWLOOP;\n                          end else\n                            ctrl_fsm_ns      = is_hwlp_body ? DECODE_HWLOOP : DECODE;\n                      end\n\n                      if(hwlp_end0_eq_pc_plus4) begin\n                          if(hwlp_counter0_gt_1) begin\n                            hwlp_end_4_id_d  = 1'b1;\n                            hwlp_targ_addr_o = hwlp_start_addr_i[0];\n                            ctrl_fsm_ns      = DECODE_HWLOOP;\n                          end else\n                            ctrl_fsm_ns      = is_hwlp_body ? DECODE_HWLOOP : DECODE;\n                      end\n\n                      hwlp_dec_cnt_o[0] = hwlp_end0_eq_pc && !hwlp_counter0_eq_0;\n                      hwlp_dec_cnt_o[1] = hwlp_end1_eq_pc && !hwlp_counter1_eq_0;\n\n                    end\n                  endcase // unique case (1'b1)\n                end // else: !if(illegal_insn_i)\n\n                if (debug_single_step_i & ~debug_mode_q) begin\n                    // prevent any more instructions from executing\n                    halt_if_o = 1'b1;\n\n                    // we don't handle dret here because its should be illegal\n                    // anyway in this context\n\n                    // illegal, ecall, ebrk and xrettransition to later to a DBG\n                    // state since we need the return address which is\n                    // determined later\n\n                    if (id_ready_i) begin\n                    // make sure the current instruction has been executed\n                        unique case(1'b1)\n\n                        illegal_insn_i | ecall_insn_i:\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        (~ebrk_force_debug_mode & ebrk_insn_i):\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        mret_insn_i | uret_insn_i:\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        branch_in_id:\n                        begin\n                            ctrl_fsm_ns = DBG_WAIT_BRANCH;\n                        end\n\n                        default:\n                            // regular instruction or ebrk force debug\n                            ctrl_fsm_ns = DBG_FLUSH;\n                        endcase // unique case (1'b1)\n                    end\n                end // if (debug_single_step_i & ~debug_mode_q)\n\n              end // else: !if (irq_req_ctrl_i && ~debug_mode_q)\n\n          end // block: blk_decode_level1 : valid block\n          else begin\n            is_decoding_o         = 1'b0;\n            perf_pipeline_stall_o = data_load_event_i;\n          end\n        end\n      end\n\n      // flush the pipeline, insert NOP into EX stage\n      FLUSH_EX:\n      begin\n        is_decoding_o = 1'b0;\n\n        halt_if_o = 1'b1;\n        halt_id_o = 1'b1;\n\n        if (data_err_i)\n        begin //data error\n            // the current LW or SW have been blocked by the PMP\n            csr_save_ex_o     = 1'b1;\n            csr_save_cause_o  = 1'b1;\n            data_err_ack_o    = 1'b1;\n            //no jump in this stage as we have to wait one cycle to go to Machine Mode\n            csr_cause_o       = {1'b0, data_we_ex_i ? EXC_CAUSE_STORE_FAULT : EXC_CAUSE_LOAD_FAULT};\n            ctrl_fsm_ns       = FLUSH_WB;\n            //putting illegal to 0 as if it was 1, the core is going to jump to the exception of the EX stage,\n            //so the illegal was never executed\n            illegal_insn_n    = 1'b0;\n        end  //data erro\n        else if (ex_valid_i) begin\n          //check done to prevent data harzard in the CSR registers\n          ctrl_fsm_ns = FLUSH_WB;\n\n          if(illegal_insn_q) begin\n            csr_save_id_o     = 1'b1;\n            csr_save_cause_o  = !debug_mode_q;\n            csr_cause_o       = {1'b0, EXC_CAUSE_ILLEGAL_INSN};\n          end else begin\n            unique case (1'b1)\n              ebrk_insn_i: begin\n                csr_save_id_o     = 1'b1;\n                csr_save_cause_o  = 1'b1;\n                csr_cause_o       = {1'b0, EXC_CAUSE_BREAKPOINT};\n              end\n              ecall_insn_i: begin\n                csr_save_id_o     = 1'b1;\n                csr_save_cause_o  = !debug_mode_q;\n                csr_cause_o       = {1'b0, current_priv_lvl_i == PRIV_LVL_U ? EXC_CAUSE_ECALL_UMODE : EXC_CAUSE_ECALL_MMODE};\n              end\n              default:;\n            endcase // unique case (1'b1)\n          end\n\n        end\n      end\n\n      IRQ_FLUSH_ELW:\n      begin\n        if (COREV_CLUSTER == 1'b1) begin\n          is_decoding_o = 1'b0;\n\n          halt_if_o     = 1'b1;\n          halt_id_o     = 1'b1;\n\n          ctrl_fsm_ns   = DECODE;\n\n          perf_pipeline_stall_o = data_load_event_i;\n\n          if (irq_req_ctrl_i && ~(debug_req_pending || debug_mode_q)) begin\n            // Taken IRQ\n            is_decoding_o     = 1'b0;\n            halt_if_o         = 1'b1;\n            halt_id_o         = 1'b1;\n\n            pc_set_o          = 1'b1;\n            pc_mux_o          = PC_EXCEPTION;\n            exc_pc_mux_o      = EXC_PC_IRQ;\n            exc_cause_o       = irq_id_ctrl_i;\n            csr_irq_sec_o     = irq_sec_ctrl_i;\n\n            // IRQ interface\n            irq_ack_o         = 1'b1;\n            irq_id_o          = irq_id_ctrl_i;\n\n            if (irq_sec_ctrl_i)\n              trap_addr_mux_o  = TRAP_MACHINE;\n            else\n              trap_addr_mux_o  = current_priv_lvl_i == PRIV_LVL_U ? TRAP_USER : TRAP_MACHINE;\n\n            csr_save_cause_o  = 1'b1;\n            csr_cause_o       = {1'b1,irq_id_ctrl_i};\n            csr_save_id_o     = 1'b1;\n          end\n        end\n      end\n\n      ELW_EXE:\n      begin\n        if (COREV_CLUSTER == 1'b1) begin\n          is_decoding_o = 1'b0;\n\n          halt_if_o   = 1'b1;\n          halt_id_o   = 1'b1;\n\n          //if we are here, a cv.elw is executing now in the EX stage\n          //or if an interrupt has been received\n          //the ID stage contains the PC_ID of the cv.elw, therefore halt_id is set to invalid the instruction\n          //If an interrupt occurs, we replay the ELW\n          //No needs to check irq_int_req_i since in the EX stage there is only the cv.elw, no CSR pendings\n          if(id_ready_i)\n            ctrl_fsm_ns = ((debug_req_pending || trigger_match_i) & ~debug_mode_q) ? DBG_FLUSH : IRQ_FLUSH_ELW;\n            // if from the ELW EXE we go to IRQ_FLUSH_ELW, it is assumed that if there was an IRQ req together with the grant and IE was valid, then\n            // there must be no hazard due to xIE\n          else\n            ctrl_fsm_ns = ELW_EXE;\n\n          perf_pipeline_stall_o = data_load_event_i;\n        end\n      end\n\n      // flush the pipeline, insert NOP into EX and WB stage\n      FLUSH_WB:\n      begin\n        is_decoding_o = 1'b0;\n\n        halt_if_o = 1'b1;\n        halt_id_o = 1'b1;\n\n        ctrl_fsm_ns = DECODE;\n\n        if(data_err_q) begin\n            //PMP data_error\n            pc_mux_o              = PC_EXCEPTION;\n            pc_set_o              = 1'b1;\n            trap_addr_mux_o       = TRAP_MACHINE;\n            //little hack during testing\n            exc_pc_mux_o          = EXC_PC_EXCEPTION;\n            exc_cause_o           = data_we_ex_i ? EXC_CAUSE_LOAD_FAULT : EXC_CAUSE_STORE_FAULT;\n\n        end\n        else if (is_fetch_failed_i) begin\n            //instruction fetch error\n            pc_mux_o              = PC_EXCEPTION;\n            pc_set_o              = 1'b1;\n            trap_addr_mux_o       = TRAP_MACHINE;\n            exc_pc_mux_o          = debug_mode_q ? EXC_PC_DBE : EXC_PC_EXCEPTION;\n            exc_cause_o           = EXC_CAUSE_INSTR_FAULT;\n\n        end\n        else begin\n          if(illegal_insn_q) begin\n              //exceptions\n              pc_mux_o              = PC_EXCEPTION;\n              pc_set_o              = 1'b1;\n              trap_addr_mux_o       = TRAP_MACHINE;\n              exc_pc_mux_o          = debug_mode_q ? EXC_PC_DBE : EXC_PC_EXCEPTION;\n              illegal_insn_n        = 1'b0;\n              if (debug_single_step_i && ~debug_mode_q)\n                  ctrl_fsm_ns = DBG_TAKEN_IF;\n          end else begin\n            unique case(1'b1)\n              ebrk_insn_i: begin\n                  //ebreak\n                  pc_mux_o              = PC_EXCEPTION;\n                  pc_set_o              = 1'b1;\n                  trap_addr_mux_o       = TRAP_MACHINE;\n                  exc_pc_mux_o          = EXC_PC_EXCEPTION;\n\n                  if (debug_single_step_i && ~debug_mode_q)\n                      ctrl_fsm_ns = DBG_TAKEN_IF;\n              end\n              ecall_insn_i: begin\n                  //ecall\n                  pc_mux_o              = PC_EXCEPTION;\n                  pc_set_o              = 1'b1;\n                  trap_addr_mux_o       = TRAP_MACHINE;\n                  exc_pc_mux_o          = debug_mode_q ? EXC_PC_DBE : EXC_PC_EXCEPTION;\n\n                  if (debug_single_step_i && ~debug_mode_q)\n                      ctrl_fsm_ns = DBG_TAKEN_IF;\n              end\n\n              mret_insn_i: begin\n                 csr_restore_mret_id_o =  !debug_mode_q;\n                 ctrl_fsm_ns           = XRET_JUMP;\n              end\n              uret_insn_i: begin\n                 csr_restore_uret_id_o =  !debug_mode_q;\n                 ctrl_fsm_ns           = XRET_JUMP;\n              end\n              dret_insn_i: begin\n                  csr_restore_dret_id_o = 1'b1;\n                  ctrl_fsm_ns           = XRET_JUMP;\n              end\n\n              csr_status_i: begin\n                if ((hwlp_end0_eq_pc && !hwlp_counter0_eq_0) ||\n                    (hwlp_end1_eq_pc && !hwlp_counter1_eq_0)) begin\n                  pc_mux_o = PC_HWLOOP;\n                  pc_set_o = 1'b1;\n                end\n              end\n\n              wfi_i: begin\n                  if ( debug_req_pending) begin\n                      ctrl_fsm_ns = DBG_TAKEN_IF;\n                      debug_force_wakeup_n = 1'b1;\n                  end else begin\n                    ctrl_fsm_ns = WAIT_SLEEP;\n                  end\n              end\n              fencei_insn_i: begin\n                  // we just jump to instruction after the fence.i since that\n                  // forces the instruction cache to refetch\n                  pc_mux_o              = PC_FENCEI;\n                  pc_set_o              = 1'b1;\n              end\n              default:;\n            endcase\n          end\n        end\n\n      end\n\n      XRET_JUMP:\n      begin\n        is_decoding_o = 1'b0;\n        ctrl_fsm_ns   = DECODE;\n        unique case(1'b1)\n          mret_dec_i: begin\n              //mret\n              pc_mux_o              = debug_mode_q ? PC_EXCEPTION : PC_MRET;\n              pc_set_o              = 1'b1;\n              exc_pc_mux_o          = EXC_PC_DBE; // only used if in debug_mode\n          end\n          uret_dec_i: begin\n              //uret\n              pc_mux_o              = debug_mode_q ? PC_EXCEPTION : PC_URET;\n              pc_set_o              = 1'b1;\n              exc_pc_mux_o          = EXC_PC_DBE; // only used if in debug_mode\n          end\n          dret_dec_i: begin\n              //dret\n              // this case is only reachable while in debug_mode\n              pc_mux_o              = PC_DRET;\n              pc_set_o              = 1'b1;\n              debug_mode_n          = 1'b0;\n          end\n          default:;\n        endcase\n\n        if (debug_single_step_i && ~debug_mode_q) begin\n          ctrl_fsm_ns = DBG_TAKEN_IF;\n        end\n      end\n\n      // a branch was in ID when trying to go to debug rom. Wait until we can\n      // determine branch target address (for saving into dpc) before proceeding\n      DBG_WAIT_BRANCH:\n      begin\n        is_decoding_o = 1'b0;\n        halt_if_o = 1'b1;\n\n        if (branch_taken_ex_i) begin\n          // there is a branch in the EX stage that is taken\n          pc_mux_o = PC_BRANCH;\n          pc_set_o = 1'b1;\n        end\n\n        ctrl_fsm_ns = DBG_FLUSH;\n      end\n\n      // We enter this state when we encounter\n      // 1. ebreak during debug mode\n      // 2. trigger match\n      // 3. ebreak with forced entry into debug mode (ebreakm or ebreaku set).\n      // 4. halt request during decode\n      // Regular ebreak's go through FLUSH_EX and FLUSH_WB.\n      // For 1. we don't update dcsr and dpc while for 2., 3., & 4. we do\n      // dpc is set to the address of ebreak and trigger match\n      // not to the next instruction's (which is why we save the pc in id).\n      DBG_TAKEN_ID:\n      begin\n        is_decoding_o     = 1'b0;\n        pc_set_o          = 1'b1;\n        pc_mux_o          = PC_EXCEPTION;\n        exc_pc_mux_o      = EXC_PC_DBD;\n        // If not in debug mode then save cause and dpc csrs\n        // else it was an ebreak in debug mode, so don't update csrs\n        if (~debug_mode_q) begin\n            csr_save_cause_o = 1'b1;\n            csr_save_id_o    = 1'b1;\n            debug_csr_save_o = 1'b1;\n            if (trigger_match_i)\n                debug_cause_o = DBG_CAUSE_TRIGGER; // pri 4 (highest)\n            else if (ebrk_force_debug_mode & ebrk_insn_i)\n                debug_cause_o = DBG_CAUSE_EBREAK; // pri 3\n            else if (debug_req_entry_q)\n                debug_cause_o = DBG_CAUSE_HALTREQ;// pri 2 and 1\n\n        end\n        debug_req_entry_n  = 1'b0;\n        ctrl_fsm_ns        = DECODE;\n        debug_mode_n       = 1'b1;\n      end\n\n      // We enter this state for single stepping\n      // DPC is set the next instruction to be executed/fetched\n      DBG_TAKEN_IF:\n      begin\n        is_decoding_o     = 1'b0;\n        pc_set_o          = 1'b1;\n        pc_mux_o          = PC_EXCEPTION;\n        exc_pc_mux_o      = EXC_PC_DBD;\n        csr_save_cause_o  = 1'b1;\n        debug_csr_save_o  = 1'b1;\n        if (debug_force_wakeup_q) \n            debug_cause_o = DBG_CAUSE_HALTREQ;\n        else if (debug_single_step_i)\n            debug_cause_o = DBG_CAUSE_STEP; // pri 0\n        csr_save_if_o   = 1'b1;\n        ctrl_fsm_ns     = DECODE;\n        debug_mode_n    = 1'b1;\n        debug_force_wakeup_n = 1'b0;\n      end\n\n\n      DBG_FLUSH:\n      begin\n        is_decoding_o = 1'b0;\n\n        halt_if_o   = 1'b1;\n        halt_id_o   = 1'b1;\n\n        perf_pipeline_stall_o = data_load_event_i;\n\n        if (data_err_i)\n        begin //data error\n            // the current LW or SW have been blocked by the PMP\n            csr_save_ex_o     = 1'b1;\n            csr_save_cause_o  = 1'b1;\n            data_err_ack_o    = 1'b1;\n            //no jump in this stage as we have to wait one cycle to go to Machine Mode\n            csr_cause_o       = {1'b0, data_we_ex_i ? EXC_CAUSE_STORE_FAULT : EXC_CAUSE_LOAD_FAULT};\n            ctrl_fsm_ns       = FLUSH_WB;\n        end  //data error\n        else begin\n          if(debug_mode_q                          |\n             trigger_match_i                       |\n             (ebrk_force_debug_mode & ebrk_insn_i) |\n             data_load_event_i                     |\n             debug_req_entry_q                     )\n            begin\n              ctrl_fsm_ns = DBG_TAKEN_ID;\n            end else\n            begin\n              // else must be debug_single_step_i\n              ctrl_fsm_ns = DBG_TAKEN_IF;\n            end\n        end\n      end\n      // Debug end\n\n      default: begin\n        is_decoding_o = 1'b0;\n        instr_req_o = 1'b0;\n        ctrl_fsm_ns = RESET;\n      end\n    endcase\n  end\n\n\n\ngenerate\n  if(COREV_PULP) begin : gen_hwlp\n    //////////////////////////////////////////////////////////////////////////////\n    // Convert hwlp_jump_o to a pulse\n    //////////////////////////////////////////////////////////////////////////////\n\n    // hwlp_jump_o should last one cycle only, as the prefetcher\n    // reacts immediately. If it last more cycles, the prefetcher\n    // goes on requesting HWLP_BEGIN more than one time (wrong!).\n    // This signal is not controlled by id_ready because otherwise,\n    // in case of stall, the jump would happen at the end of the stall.\n\n    // Make hwlp_jump_o last only one cycle\n    assign hwlp_jump_o = (hwlp_end_4_id_d && !hwlp_end_4_id_q) ? 1'b1 : 1'b0;\n\n    always_ff @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        hwlp_end_4_id_q <= 1'b0;\n      end else begin\n        hwlp_end_4_id_q <= hwlp_end_4_id_d;\n      end\n    end\n\n    assign hwlp_end0_eq_pc         = hwlp_end_addr_i[0] == pc_id_i + 4;   // Equivalent to hwlp_end_addr_i[0] - 4 == pc_id_i\n    assign hwlp_end1_eq_pc         = hwlp_end_addr_i[1] == pc_id_i + 4;   // Equivalent to hwlp_end_addr_i[1] - 4 == pc_id_i\n    assign hwlp_counter0_gt_1      = hwlp_counter_i[0] > 1;\n    assign hwlp_counter1_gt_1      = hwlp_counter_i[1] > 1;\n    assign hwlp_counter0_eq_1      = hwlp_counter_i[0] == 1;\n    assign hwlp_counter1_eq_1      = hwlp_counter_i[1] == 1;\n    assign hwlp_counter0_eq_0      = hwlp_counter_i[0] == 0;\n    assign hwlp_counter1_eq_0      = hwlp_counter_i[1] == 0;\n    assign hwlp_end0_eq_pc_plus4   = hwlp_end_addr_i[0] == pc_id_i + 8;   // Equivalent to hwlp_end_addr_i[0] - 4 == pc_id_i + 4\n    assign hwlp_end1_eq_pc_plus4   = hwlp_end_addr_i[1] == pc_id_i + 8;   // Equivalent to hwlp_end_addr_i[1] - 4 == pc_id_i + 4\n    assign hwlp_start0_leq_pc      = hwlp_start_addr_i[0] <= pc_id_i;\n    assign hwlp_start1_leq_pc      = hwlp_start_addr_i[1] <= pc_id_i;\n    assign hwlp_end0_geq_pc        = hwlp_end_addr_i[0] >= pc_id_i + 4;   // Equivalent to hwlp_end_addr_i[0] - 4 >= pc_id_i\n    assign hwlp_end1_geq_pc        = hwlp_end_addr_i[1] >= pc_id_i + 4;   // Equivalent to hwlp_end_addr_i[1] - 4 >= pc_id_i;\n    assign is_hwlp_body            = ((hwlp_start0_leq_pc && hwlp_end0_geq_pc) && hwlp_counter0_gt_1) ||  ((hwlp_start1_leq_pc && hwlp_end1_geq_pc) && hwlp_counter1_gt_1);\n\n  end else begin : gen_no_hwlp\n\n    assign hwlp_jump_o             = 1'b0;\n    assign hwlp_end_4_id_q         = 1'b0;\n    assign hwlp_end0_eq_pc         = 1'b0;\n    assign hwlp_end1_eq_pc         = 1'b0;\n    assign hwlp_counter0_gt_1      = 1'b0;\n    assign hwlp_counter1_gt_1      = 1'b0;\n    assign hwlp_counter0_eq_1      = 1'b0;\n    assign hwlp_counter1_eq_1      = 1'b0;\n    assign hwlp_counter0_eq_0      = 1'b0;\n    assign hwlp_counter1_eq_0      = 1'b0;\n    assign hwlp_end0_eq_pc_plus4   = 1'b0;\n    assign hwlp_end1_eq_pc_plus4   = 1'b0;\n    assign hwlp_start0_leq_pc      = 1'b0;\n    assign hwlp_start1_leq_pc      = 1'b0;\n    assign hwlp_end0_geq_pc        = 1'b0;\n    assign hwlp_end1_geq_pc        = 1'b0;\n    assign is_hwlp_body            = 1'b0;\n\n  end\n\nendgenerate\n\n  /////////////////////////////////////////////////////////////\n  //  ____  _        _ _    ____            _             _  //\n  // / ___|| |_ __ _| | |  / ___|___  _ __ | |_ _ __ ___ | | //\n  // \\___ \\| __/ _` | | | | |   / _ \\| '_ \\| __| '__/ _ \\| | //\n  //  ___) | || (_| | | | | |__| (_) | | | | |_| | | (_) | | //\n  // |____/ \\__\\__,_|_|_|  \\____\\___/|_| |_|\\__|_|  \\___/|_| //\n  //                                                         //\n  /////////////////////////////////////////////////////////////\n  always_comb\n  begin\n    load_stall_o   = 1'b0;\n    deassert_we_o  = 1'b0;\n\n    // deassert WE when the core is not decoding instructions\n    if (~is_decoding_o)\n      deassert_we_o = 1'b1;\n\n    // deassert WE in case of illegal instruction\n    if (illegal_insn_i)\n      deassert_we_o = 1'b1;\n\n    // Stall because of load operation\n    if (\n          ( (data_req_ex_i == 1'b1) && (regfile_we_ex_i == 1'b1) ||\n           (wb_ready_i == 1'b0) && (regfile_we_wb_i == 1'b1)\n          ) &&\n          ( (reg_d_ex_is_reg_a_i == 1'b1) || (reg_d_ex_is_reg_b_i == 1'b1) || (reg_d_ex_is_reg_c_i == 1'b1) ||\n            (is_decoding_o && (regfile_we_id_i && !data_misaligned_i) && (regfile_waddr_ex_i == regfile_alu_waddr_id_i)) )\n       )\n    begin\n      deassert_we_o   = 1'b1;\n      load_stall_o    = 1'b1;\n    end\n\n    // Stall because of jr path\n    // - always stall if a result is to be forwarded to the PC\n    // we don't care about in which state the ctrl_fsm is as we deassert_we\n    // anyway when we are not in DECODE\n    if ((ctrl_transfer_insn_in_dec_i == BRANCH_JALR) &&\n        (((regfile_we_wb_i == 1'b1) && (reg_d_wb_is_reg_a_i == 1'b1)) ||\n         ((regfile_we_ex_i == 1'b1) && (reg_d_ex_is_reg_a_i == 1'b1)) ||\n         ((regfile_alu_we_fw_i == 1'b1) && (reg_d_alu_is_reg_a_i == 1'b1)) ||\n         (FPU && (apu_read_dep_for_jalr_i == 1'b1))\n        )\n       )\n    begin\n      jr_stall_o      = 1'b1;\n      deassert_we_o   = 1'b1;\n    end\n    else\n    begin\n      jr_stall_o     = 1'b0;\n    end\n  end\n\n\n  // stall because of misaligned data access\n  assign misaligned_stall_o = data_misaligned_i;\n\n  // APU dependency stalls (data hazards)\n  assign apu_stall_o = apu_read_dep_i | (apu_write_dep_i & ~apu_en_i);\n\n  // Forwarding control unit\n  always_comb\n  begin\n    // default assignements\n    operand_a_fw_mux_sel_o = SEL_REGFILE;\n    operand_b_fw_mux_sel_o = SEL_REGFILE;\n    operand_c_fw_mux_sel_o = SEL_REGFILE;\n\n    // Forwarding WB -> ID\n    if (regfile_we_wb_i == 1'b1)\n    begin\n      if (reg_d_wb_is_reg_a_i == 1'b1)\n        operand_a_fw_mux_sel_o = SEL_FW_WB;\n      if (reg_d_wb_is_reg_b_i == 1'b1)\n        operand_b_fw_mux_sel_o = SEL_FW_WB;\n      if (reg_d_wb_is_reg_c_i == 1'b1)\n        operand_c_fw_mux_sel_o = SEL_FW_WB;\n    end\n\n    // Forwarding EX -> ID\n    if (regfile_alu_we_fw_i == 1'b1)\n    begin\n     if (reg_d_alu_is_reg_a_i == 1'b1)\n       operand_a_fw_mux_sel_o = SEL_FW_EX;\n     if (reg_d_alu_is_reg_b_i == 1'b1)\n       operand_b_fw_mux_sel_o = SEL_FW_EX;\n     if (reg_d_alu_is_reg_c_i == 1'b1)\n       operand_c_fw_mux_sel_o = SEL_FW_EX;\n    end\n\n    // for misaligned memory accesses\n    if (data_misaligned_i)\n    begin\n      operand_a_fw_mux_sel_o  = SEL_FW_EX;\n      operand_b_fw_mux_sel_o  = SEL_REGFILE;\n    end else if (mult_multicycle_i) begin\n      operand_c_fw_mux_sel_o  = SEL_FW_EX;\n    end\n  end\n\n  // update registers\n  always_ff @(posedge clk , negedge rst_n)\n  begin : UPDATE_REGS\n    if ( rst_n == 1'b0 )\n    begin\n      ctrl_fsm_cs        <= RESET;\n      jump_done_q        <= 1'b0;\n      data_err_q         <= 1'b0;\n\n      debug_mode_q       <= 1'b0;\n      illegal_insn_q     <= 1'b0;\n\n      debug_req_entry_q  <= 1'b0;\n      debug_force_wakeup_q <= 1'b0;\n    end\n    else\n    begin\n      ctrl_fsm_cs        <= ctrl_fsm_ns;\n\n      // clear when id is valid (no instruction incoming)\n      jump_done_q        <= jump_done & (~id_ready_i);\n\n      data_err_q         <= data_err_i;\n\n      debug_mode_q       <= debug_mode_n;\n\n      illegal_insn_q     <= illegal_insn_n;\n\n      debug_req_entry_q  <= debug_req_entry_n;\n      debug_force_wakeup_q <= debug_force_wakeup_n;\n    end\n  end\n\n  // wakeup from sleep conditions\n  assign wake_from_sleep_o = irq_wu_ctrl_i || debug_req_pending || debug_mode_q;\n\n  // debug mode\n  assign debug_mode_o = debug_mode_q;\n  assign debug_req_pending = debug_req_i || debug_req_q;\n\n  // Do not let cv.elw cause core_sleep_o during debug\n  assign debug_p_elw_no_sleep_o = debug_mode_q || debug_req_q || debug_single_step_i || trigger_match_i;\n\n  // Do not let WFI cause core_sleep_o (but treat as NOP):\n  //\n  // - During debug\n  // - For PULP Cluster (only cv.elw can trigger sleep)\n\n  assign debug_wfi_no_sleep_o = debug_mode_q || debug_req_pending || debug_single_step_i || trigger_match_i || COREV_CLUSTER;\n\n  // Gate off wfi \n  assign wfi_active = wfi_i & ~debug_wfi_no_sleep_o;\n\n  // sticky version of debug_req (must be on clk_ungated_i such that incoming pulse before core is enabled is not missed)\n  always_ff @(posedge clk_ungated_i, negedge rst_n)\n    if ( !rst_n )\n      debug_req_q <= 1'b0;\n    else\n      if( debug_req_i )\n        debug_req_q <= 1'b1;\n      else if( debug_mode_q )\n        debug_req_q <= 1'b0;\n\n  // Debug state FSM\n  always_ff @(posedge clk , negedge rst_n)\n  begin\n    if ( rst_n == 1'b0 )\n    begin\n      debug_fsm_cs <= HAVERESET;\n    end\n    else\n    begin\n      debug_fsm_cs <= debug_fsm_ns;\n    end\n  end\n\n  always_comb\n  begin\n    debug_fsm_ns = debug_fsm_cs;\n\n    case (debug_fsm_cs)\n      HAVERESET:\n      begin\n        if (debug_mode_n || (ctrl_fsm_ns == FIRST_FETCH)) begin\n          if (debug_mode_n) begin\n            debug_fsm_ns = HALTED;\n          end else begin\n            debug_fsm_ns = RUNNING;\n          end\n        end\n      end\n\n      RUNNING:\n      begin\n        if (debug_mode_n) begin\n          debug_fsm_ns = HALTED;\n        end\n      end\n\n      HALTED:\n      begin\n        if (!debug_mode_n) begin\n          debug_fsm_ns = RUNNING;\n        end\n      end\n\n      default: begin\n        debug_fsm_ns = HAVERESET;\n      end\n    endcase\n  end\n\n  assign debug_havereset_o = debug_fsm_cs[HAVERESET_INDEX];\n  assign debug_running_o = debug_fsm_cs[RUNNING_INDEX];\n  assign debug_halted_o = debug_fsm_cs[HALTED_INDEX];\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n`ifdef CV32E40P_ASSERT_ON\n\n  // make sure that taken branches do not happen back-to-back, as this is not\n  // possible without branch prediction in the IF stage\n  assert property (\n    @(posedge clk) (branch_taken_ex_i) |=> (~branch_taken_ex_i) ) else $warning(\"Two branches back-to-back are taken\");\n\n  // ELW_EXE and IRQ_FLUSH_ELW states are only used for COREV_CLUSTER = 1\n  property p_pulp_cluster_only_states;\n     @(posedge clk) (1'b1) |-> ( !((COREV_CLUSTER == 1'b0) && ((ctrl_fsm_cs == ELW_EXE) || (ctrl_fsm_cs == IRQ_FLUSH_ELW))) );\n  endproperty\n\n  a_pulp_cluster_only_states : assert property(p_pulp_cluster_only_states);\n\n  // WAIT_SLEEP and SLEEP states are never used for COREV_CLUSTER = 1\n  property p_pulp_cluster_excluded_states;\n     @(posedge clk) (1'b1) |-> ( !((COREV_CLUSTER == 1'b1) && ((ctrl_fsm_cs == SLEEP) || (ctrl_fsm_cs == WAIT_SLEEP))) );\n  endproperty\n\n  a_pulp_cluster_excluded_states : assert property(p_pulp_cluster_excluded_states);\n\n  generate\n  if (COREV_PULP) begin : gen_pulp_xpulp_assertions\n\n    // HWLoop 0 and 1 having target address constraints\n    property p_hwlp_same_target_address;\n       @(posedge clk) (hwlp_counter_i[1] > 1 && hwlp_counter_i[0] > 1 && pc_id_i >= hwlp_start_addr_i[0] && pc_id_i <= hwlp_end_addr_i[0] - 4) |-> ( hwlp_end_addr_i[1] - 4 >= hwlp_end_addr_i[0] - 4 + 8 );\n    endproperty\n\n    a_hwlp_same_target_address : assert property(p_hwlp_same_target_address) else $warning(\"%t, HWLoops target address do not respect constraints\", $time);\n\n  end else begin : gen_no_pulp_xpulp_assertions\n\n    property p_no_hwlp;\n       @(posedge clk) (1'b1) |-> ((pc_mux_o != PC_HWLOOP) && (ctrl_fsm_cs != DECODE_HWLOOP) &&\n                                  (hwlp_mask_o == 1'b0) && (is_hwlp_body == 'b0) &&\n                                  (hwlp_start_addr_i == 'b0) && (hwlp_end_addr_i == 'b0) && (hwlp_counter_i[1] == 32'b0) && (hwlp_counter_i[0] == 32'b0) &&\n                                  (hwlp_dec_cnt_o == 2'b0) && (hwlp_jump_o == 1'b0) && (hwlp_targ_addr_o == 32'b0) &&\n                                  (hwlp_end0_eq_pc == 1'b0) && (hwlp_end1_eq_pc == 1'b0) && (hwlp_counter0_gt_1 == 1'b0) && (hwlp_counter1_gt_1 == 1'b0) &&\n                                  (hwlp_counter0_eq_1 == 1'b0) && (hwlp_counter1_eq_1 == 1'b0) &&\n                                  (hwlp_end0_eq_pc_plus4 == 1'b0) && (hwlp_end1_eq_pc_plus4 == 1'b0) && (hwlp_start0_leq_pc == 0) && (hwlp_start1_leq_pc == 0) &&\n                                  (hwlp_end0_geq_pc == 1'b0) && (hwlp_end1_geq_pc == 1'b0) && (hwlp_end_4_id_d == 1'b0) && (hwlp_end_4_id_q == 1'b0));\n    endproperty\n\n    a_no_hwlp : assert property(p_no_hwlp);\n\n  end\n  endgenerate\n\n  // Ensure DBG_TAKEN_IF can only be enterred if in single step mode or woken\n  // up from sleep by debug_req_i\n         \n  a_single_step_dbg_taken_if : assert property (@(posedge clk)  disable iff (!rst_n)  (ctrl_fsm_ns==DBG_TAKEN_IF) |-> ((~debug_mode_q && debug_single_step_i) || debug_force_wakeup_n));\n\n  // Ensure DBG_FLUSH state is only one cycle. This implies that cause is either trigger, debug_req_entry, or ebreak\n  a_dbg_flush : assert property (@(posedge clk)  disable iff (!rst_n)  (ctrl_fsm_cs==DBG_FLUSH) |-> (ctrl_fsm_ns!=DBG_FLUSH) );\n\n  // Ensure that debug state outputs are one-hot\n  a_debug_state_onehot : assert property (@(posedge clk) $onehot({debug_havereset_o, debug_running_o, debug_halted_o}));\n\n  // Ensure that debug_halted_o equals debug_mode_q\n  a_debug_halted_equals_debug_mode : assert property (@(posedge clk) disable iff (!rst_n) (1'b1) |-> (debug_mode_q == debug_halted_o));\n\n  // Ensure ID always ready in FIRST_FETCH state\n  a_first_fetch_id_ready : assert property (@(posedge clk) disable iff (!rst_n) (ctrl_fsm_cs == FIRST_FETCH) |-> (id_ready_i == 1'b1));\n\n  // Ensure that the only way to get to DBG_TAKEN_IF from DBG_FLUSH is if debug_single_step_i is asserted\n  a_dbg_flush_to_taken_if : assert property (@(posedge clk) disable iff (!rst_n) (ctrl_fsm_cs == DBG_FLUSH) && (ctrl_fsm_ns == DBG_TAKEN_IF) |-> debug_single_step_i);\n\n`endif\n\nendmodule // cv32e40p_controller\n","lang":"verilog"};
processSrcData(g_data);