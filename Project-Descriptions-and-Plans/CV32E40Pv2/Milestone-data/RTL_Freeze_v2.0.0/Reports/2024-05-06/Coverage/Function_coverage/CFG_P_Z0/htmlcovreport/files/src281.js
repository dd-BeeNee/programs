var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/lib/uvm_agents/uvma_obi_memory/src/uvma_obi_memory_assert_if_wrp.sv","src":"// Copyright 2020 OpenHW Group\n// Copyright 2020 Datum Technology Corporation\n// Copyright 2020 Silicon Labs, Inc.\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://solderpad.org/licenses/\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This module facilitates easy connection of a uvma_obi_memory_if instance to the assertion module,\n// which has individual wire ports\n\nmodule uvma_obi_memory_assert_if_wrp\n  import uvm_pkg::*;\n  #(\n    parameter int unsigned ADDR_WIDTH  = 32,\n    parameter int unsigned DATA_WIDTH  = 32,\n    parameter int unsigned AUSER_WIDTH = 0,\n    parameter int unsigned WUSER_WIDTH = 0,\n    parameter int unsigned RUSER_WIDTH = 0,\n    parameter int unsigned ID_WIDTH    = 0,\n    parameter int unsigned ACHK_WIDTH  = 0,\n    parameter int unsigned RCHK_WIDTH  = 0,\n    parameter bit          IS_1P2      = 0\n  )\n  (\n    uvma_obi_memory_if obi\n  );\n\n\n  // ---------------------------------------------------------------------------\n  // Local parameters\n  // ---------------------------------------------------------------------------\n\n  // Some \"WIDTHs\" may be zero, set these to 1 to avoid negative bit-vector indices\n  localparam EFF_ID_WIDTH    = ID_WIDTH == 0 ? 1 : ID_WIDTH;\n  localparam EFF_AUSER_WIDTH = AUSER_WIDTH == 0 ? 1 : AUSER_WIDTH;\n  localparam EFF_RUSER_WIDTH = RUSER_WIDTH == 0 ? 1 : RUSER_WIDTH;\n  localparam EFF_WUSER_WIDTH = WUSER_WIDTH == 0 ? 1 : WUSER_WIDTH;\n  localparam EFF_ACHK_WIDTH  = ACHK_WIDTH == 0 ? 1 : ACHK_WIDTH;\n  localparam EFF_RCHK_WIDTH  = RCHK_WIDTH == 0 ? 1 : RCHK_WIDTH;\n\n  // ---------------------------------------------------------------------------\n  // Begin module code\n  // ---------------------------------------------------------------------------\n\n  uvma_obi_memory_assert#(\n    .ADDR_WIDTH(ADDR_WIDTH),\n    .DATA_WIDTH(DATA_WIDTH),\n    .AUSER_WIDTH(AUSER_WIDTH),\n    .WUSER_WIDTH(WUSER_WIDTH),\n    .RUSER_WIDTH(RUSER_WIDTH),\n    .ID_WIDTH(ID_WIDTH),\n    .ACHK_WIDTH(ACHK_WIDTH),\n    .RCHK_WIDTH(RCHK_WIDTH),\n    .IS_1P2(IS_1P2)\n  ) u_assert(\n    .clk(obi.clk),\n    .reset_n(obi.reset_n),\n    .req(obi.req),\n    .gnt(obi.gnt),\n    .addr(obi.addr[ADDR_WIDTH-1:0]),\n    .we(obi.we),\n    .be(obi.be),\n    .wdata(obi.wdata[DATA_WIDTH-1:0]),\n    .auser(obi.auser[EFF_AUSER_WIDTH-1:0]),\n    .wuser(obi.wuser[EFF_WUSER_WIDTH-1:0]),\n    .aid(obi.aid[EFF_ID_WIDTH-1:0]),\n    .atop(obi.atop),\n    .memtype(obi.memtype),\n    .prot(obi.prot),\n    .reqpar(obi.reqpar),\n    .gntpar(obi.gntpar),\n    .achk(obi.achk[EFF_ACHK_WIDTH-1:0]),\n    .rdata(obi.rdata[DATA_WIDTH-1:0]),\n    .rvalid(obi.rvalid),\n    .rready(obi.rready),\n    .err(obi.err),\n    .ruser(obi.ruser[EFF_RUSER_WIDTH-1:0]),\n    .rid(obi.rid[EFF_ID_WIDTH-1:0]),\n    .exokay(obi.exokay),\n    .rvalidpar(obi.rvalidpar),\n    .rreadypar(obi.rreadypar),\n    .rchk(obi.rchk[EFF_RCHK_WIDTH-1:0])\n  );\n\nendmodule : uvma_obi_memory_assert_if_wrp\n","lang":"verilog"};
processSrcData(g_data);