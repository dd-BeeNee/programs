var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_cs_registers.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Sven Stucki - svstucki@student.ethz.ch                     //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                 Andrea Bettati - andrea.bettati@studenti.unipr.it          //\n//                                                                            //\n// Design Name:    Control and Status Registers                               //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Control and Status Registers (CSRs) loosely following the  //\n//                 RiscV draft priviledged instruction set spec (v1.9)        //\n//                 Added Floating point support                               //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_cs_registers\n  import cv32e40p_pkg::*;\n#(\n    parameter N_HWLP           = 2,\n    parameter APU              = 0,\n    parameter A_EXTENSION      = 0,\n    parameter FPU              = 0,\n    parameter ZFINX            = 0,\n    parameter PULP_SECURE      = 0,\n    parameter USE_PMP          = 0,\n    parameter N_PMP_ENTRIES    = 16,\n    parameter NUM_MHPMCOUNTERS = 1,\n    parameter COREV_PULP       = 0,\n    parameter COREV_CLUSTER    = 0,\n    parameter DEBUG_TRIGGER_EN = 1\n) (\n    // Clock and Reset\n    input logic clk,\n    input logic rst_n,\n\n    // Hart ID\n    input  logic [31:0] hart_id_i,\n    output logic [23:0] mtvec_o,\n    output logic [23:0] utvec_o,\n    output logic [ 1:0] mtvec_mode_o,\n    output logic [ 1:0] utvec_mode_o,\n\n    // Used for mtvec address\n    input logic [31:0] mtvec_addr_i,\n    input logic        csr_mtvec_init_i,\n\n    // Interface to registers (SRAM like)\n    input  csr_num_e           csr_addr_i,\n    input  logic        [31:0] csr_wdata_i,\n    input  csr_opcode_e        csr_op_i,\n    output logic        [31:0] csr_rdata_o,\n\n    output logic               fs_off_o,\n    output logic [        2:0] frm_o,\n    input  logic [C_FFLAG-1:0] fflags_i,\n    input  logic               fflags_we_i,\n    input  logic               fregs_we_i,\n\n    // Interrupts\n    output logic [31:0] mie_bypass_o,\n    input  logic [31:0] mip_i,\n    output logic        m_irq_enable_o,\n    output logic        u_irq_enable_o,\n\n    //csr_irq_sec_i is always 0 if PULP_SECURE is zero\n    input  logic        csr_irq_sec_i,\n    output logic        sec_lvl_o,\n    output logic [31:0] mepc_o,\n    output logic [31:0] uepc_o,\n    //mcounteren_o is always 0 if PULP_SECURE is zero\n    output logic [31:0] mcounteren_o,\n\n    // debug\n    input  logic        debug_mode_i,\n    input  logic [ 2:0] debug_cause_i,\n    input  logic        debug_csr_save_i,\n    output logic [31:0] depc_o,\n    output logic        debug_single_step_o,\n    output logic        debug_ebreakm_o,\n    output logic        debug_ebreaku_o,\n    output logic        trigger_match_o,\n\n\n    output logic [N_PMP_ENTRIES-1:0][31:0] pmp_addr_o,\n    output logic [N_PMP_ENTRIES-1:0][ 7:0] pmp_cfg_o,\n\n    output PrivLvl_t priv_lvl_o,\n\n    input logic [31:0] pc_if_i,\n    input logic [31:0] pc_id_i,\n    input logic [31:0] pc_ex_i,\n\n    input logic csr_save_if_i,\n    input logic csr_save_id_i,\n    input logic csr_save_ex_i,\n\n    input logic csr_restore_mret_i,\n    input logic csr_restore_uret_i,\n\n    input logic                    csr_restore_dret_i,\n    //coming from controller\n    input logic [       5:0]       csr_cause_i,\n    //coming from controller\n    input logic                    csr_save_cause_i,\n    // Hardware loops\n    input logic [N_HWLP-1:0][31:0] hwlp_start_i,\n    input logic [N_HWLP-1:0][31:0] hwlp_end_i,\n    input logic [N_HWLP-1:0][31:0] hwlp_cnt_i,\n\n    // Performance Counters\n    input logic mhpmevent_minstret_i,\n    input logic mhpmevent_load_i,\n    input logic mhpmevent_store_i,\n    input logic mhpmevent_jump_i,  // Jump instruction retired (j, jr, jal, jalr)\n    input logic mhpmevent_branch_i,  // Branch instruction retired (beq, bne, etc.)\n    input logic mhpmevent_branch_taken_i,  // Branch instruction taken\n    input logic mhpmevent_compressed_i,\n    input logic mhpmevent_jr_stall_i,\n    input logic mhpmevent_imiss_i,\n    input logic mhpmevent_ld_stall_i,\n    input logic mhpmevent_pipe_stall_i,\n    input logic apu_typeconflict_i,\n    input logic apu_contention_i,\n    input logic apu_dep_i,\n    input logic apu_wb_i\n);\n\n  localparam NUM_HPM_EVENTS = 16;\n\n  localparam MTVEC_MODE = 2'b01;\n\n  localparam MAX_N_PMP_ENTRIES = 16;\n  localparam MAX_N_PMP_CFG = 4;\n  localparam N_PMP_CFG = N_PMP_ENTRIES % 4 == 0 ? N_PMP_ENTRIES / 4 : N_PMP_ENTRIES / 4 + 1;\n\n  localparam MSTATUS_UIE_BIT = 0;\n  localparam MSTATUS_SIE_BIT = 1;\n  localparam MSTATUS_MIE_BIT = 3;\n  localparam MSTATUS_UPIE_BIT = 4;\n  localparam MSTATUS_SPIE_BIT = 5;\n  localparam MSTATUS_MPIE_BIT = 7;\n  localparam MSTATUS_SPP_BIT = 8;\n  localparam MSTATUS_MPP_BIT_LOW = 11;\n  localparam MSTATUS_MPP_BIT_HIGH = 12;\n  localparam MSTATUS_FS_BIT_LOW = 13;\n  localparam MSTATUS_FS_BIT_HIGH = 14;\n  localparam MSTATUS_MPRV_BIT = 17;\n  localparam MSTATUS_SD_BIT = 31;\n\n  // misa\n  localparam logic [1:0] MXL = 2'd1;  // M-XLEN: XLEN in M-Mode for RV32\n  localparam logic [31:0] MISA_VALUE = (32'(A_EXTENSION) << 0)  // A - Atomic Instructions extension\n  | (1 << 2)  // C - Compressed extension\n  | (0 << 3)  // D - Double precision floating-point extension\n  | (0 << 4)  // E - RV32E base ISA\n  | (32'(FPU == 1 && ZFINX == 0) << 5)  // F - Single precision floating-point extension\n  | (1 << 8)  // I - RV32I/64I/128I base ISA\n  | (1 << 12)  // M - Integer Multiply/Divide extension\n  | (0 << 13)  // N - User level interrupts supported\n  | (0 << 18)  // S - Supervisor mode implemented\n  | (32'(PULP_SECURE) << 20)  // U - User mode implemented\n  | (32'(COREV_PULP || COREV_CLUSTER) << 23)  // X - Non-standard extensions present\n  | (32'(MXL) << 30);  // M-XLEN\n\n  // This local parameter when set to 1 makes the Perf Counters not compliant with RISC-V\n  // as it does not implement mcycle and minstret\n  // but only HPMCOUNTERs (depending on NUM_MHPMCOUNTERS)\n  localparam PULP_PERF_COUNTERS = 0;\n\n  typedef struct packed {\n    logic [MAX_N_PMP_ENTRIES-1:0][31:0] pmpaddr;\n    logic [MAX_N_PMP_CFG-1:0][31:0] pmpcfg_packed;\n    logic [MAX_N_PMP_ENTRIES-1:0][7:0] pmpcfg;\n  } Pmp_t;\n\n  // CSR update logic\n  logic [31:0] csr_wdata_int;\n  logic [31:0] csr_rdata_int;\n  logic        csr_we_int;\n\n  // FPU \n  logic [C_RM-1:0] frm_q, frm_n;\n  logic [C_FFLAG-1:0] fflags_q, fflags_n;\n  logic fcsr_update;\n\n  // Interrupt control signals\n  logic [31:0] mepc_q, mepc_n;\n  logic [31:0] uepc_q, uepc_n;\n  // Trigger\n  logic [31:0] tmatch_control_rdata;\n  logic [31:0] tmatch_value_rdata;\n  logic [15:0] tinfo_types;\n  // Debug\n  Dcsr_t dcsr_q, dcsr_n;\n  logic [31:0] depc_q, depc_n;\n  logic [31:0] dscratch0_q, dscratch0_n;\n  logic [31:0] dscratch1_q, dscratch1_n;\n  logic [31:0] mscratch_q, mscratch_n;\n\n  logic [31:0] exception_pc;\n  Status_t mstatus_q, mstatus_n;\n  logic mstatus_we_int;\n  FS_t mstatus_fs_q, mstatus_fs_n;\n  logic [5:0] mcause_q, mcause_n;\n  logic [5:0] ucause_q, ucause_n;\n  logic [23:0] mtvec_n, mtvec_q;\n  logic [23:0] utvec_n, utvec_q;\n  logic [1:0] mtvec_mode_n, mtvec_mode_q;\n  logic [1:0] utvec_mode_n, utvec_mode_q;\n\n  logic [31:0] mip;  // Bits are masked according to IRQ_MASK\n  logic [31:0] mie_q, mie_n;  // Bits are masked according to IRQ_MASK\n\n  logic [31:0] csr_mie_wdata;\n  logic        csr_mie_we;\n\n  logic        is_irq;\n  PrivLvl_t priv_lvl_n, priv_lvl_q;\n  Pmp_t pmp_reg_q, pmp_reg_n;\n  //clock gating for pmp regs\n  logic [MAX_N_PMP_ENTRIES-1:0]                        pmpaddr_we;\n  logic [MAX_N_PMP_ENTRIES-1:0]                        pmpcfg_we;\n\n  // Performance Counter Signals\n  logic [                 31:0][MHPMCOUNTER_WIDTH-1:0] mhpmcounter_q;  // performance counters\n  logic [31:0][31:0] mhpmevent_q, mhpmevent_n;  // event enable\n  logic [31:0] mcounteren_q, mcounteren_n;  // user mode counter enable\n  logic [31:0] mcountinhibit_q, mcountinhibit_n;  // performance counter enable\n  logic [NUM_HPM_EVENTS-1:0] hpm_events;  // events for performance counters\n  logic [31:0][MHPMCOUNTER_WIDTH-1:0] mhpmcounter_increment;  // increment of mhpmcounter_q\n  logic [31:0] mhpmcounter_write_lower;  // write 32 lower bits of mhpmcounter_q\n  logic [31:0] mhpmcounter_write_upper;  // write 32 upper bits mhpmcounter_q\n  logic [31:0] mhpmcounter_write_increment;  // write increment of mhpmcounter_q\n\n  assign is_irq = csr_cause_i[5];\n\n  // mip CSR\n  assign mip = mip_i;\n\n  // mie_n is used instead of mie_q such that a CSR write to the MIE register can\n  // affect the instruction immediately following it.\n\n  // MIE CSR operation logic\n  always_comb begin\n    csr_mie_wdata = csr_wdata_i;\n    csr_mie_we    = 1'b1;\n\n    case (csr_op_i)\n      CSR_OP_WRITE: csr_mie_wdata = csr_wdata_i;\n      CSR_OP_SET:   csr_mie_wdata = csr_wdata_i | mie_q;\n      CSR_OP_CLEAR: csr_mie_wdata = (~csr_wdata_i) & mie_q;\n      CSR_OP_READ: begin\n        csr_mie_wdata = csr_wdata_i;\n        csr_mie_we    = 1'b0;\n      end\n    endcase\n  end\n\n  assign mie_bypass_o = ((csr_addr_i == CSR_MIE) && csr_mie_we) ? csr_mie_wdata & IRQ_MASK : mie_q;\n\n  ////////////////////////////////////////////\n  //   ____ ____  ____    ____              //\n  //  / ___/ ___||  _ \\  |  _ \\ ___  __ _   //\n  // | |   \\___ \\| |_) | | |_) / _ \\/ _` |  //\n  // | |___ ___) |  _ <  |  _ <  __/ (_| |  //\n  //  \\____|____/|_| \\_\\ |_| \\_\\___|\\__, |  //\n  //                                |___/   //\n  ////////////////////////////////////////////\n\n  // NOTE!!!: Any new CSR register added in this file must also be\n  //   added to the valid CSR register list cv32e40p_decoder.v\n\n  genvar j;\n\n\n  if (PULP_SECURE == 1) begin : gen_pulp_secure_read_logic\n    // read logic\n    always_comb begin\n      case (csr_addr_i)\n        // fcsr: Floating-Point Control and Status Register (frm + fflags).\n        CSR_FFLAGS: csr_rdata_int = (FPU == 1) ? {27'b0, fflags_q} : '0;\n        CSR_FRM:    csr_rdata_int = (FPU == 1) ? {29'b0, frm_q} : '0;\n        CSR_FCSR:   csr_rdata_int = (FPU == 1) ? {24'b0, frm_q, fflags_q} : '0;\n\n        // mstatus\n        CSR_MSTATUS:\n        csr_rdata_int = {\n          14'b0,\n          mstatus_q.mprv,\n          4'b0,\n          mstatus_q.mpp,\n          3'b0,\n          mstatus_q.mpie,\n          2'h0,\n          mstatus_q.upie,\n          mstatus_q.mie,\n          2'h0,\n          mstatus_q.uie\n        };\n\n        // misa: machine isa register\n        CSR_MISA: csr_rdata_int = MISA_VALUE;\n\n        // mie: machine interrupt enable\n        CSR_MIE: begin\n          csr_rdata_int = mie_q;\n        end\n\n        // mtvec: machine trap-handler base address\n        CSR_MTVEC: csr_rdata_int = {mtvec_q, 6'h0, mtvec_mode_q};\n        // mscratch: machine scratch\n        CSR_MSCRATCH: csr_rdata_int = mscratch_q;\n        // mepc: exception program counter\n        CSR_MEPC: csr_rdata_int = mepc_q;\n        // mcause: exception cause\n        CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};\n        // mip: interrupt pending\n        CSR_MIP: begin\n          csr_rdata_int = mip;\n        end\n\n        // mhartid: unique hardware thread id\n        CSR_MHARTID: csr_rdata_int = hart_id_i;\n\n        // mvendorid: Machine Vendor ID\n        CSR_MVENDORID: csr_rdata_int = {MVENDORID_BANK, MVENDORID_OFFSET};\n\n        // marchid: Machine Architecture ID\n        CSR_MARCHID: csr_rdata_int = MARCHID;\n\n        // unimplemented, read 0 CSRs\n        CSR_MIMPID, CSR_MTVAL: csr_rdata_int = 'b0;\n\n        // mcounteren: Machine Counter-Enable\n        CSR_MCOUNTEREN: csr_rdata_int = mcounteren_q;\n\n        CSR_TSELECT, CSR_TDATA3, CSR_MCONTEXT, CSR_SCONTEXT: csr_rdata_int = 'b0;  // Always read 0\n        CSR_TDATA1: csr_rdata_int = tmatch_control_rdata;\n        CSR_TDATA2: csr_rdata_int = tmatch_value_rdata;\n        CSR_TINFO: csr_rdata_int = tinfo_types;\n\n        CSR_DCSR: csr_rdata_int = dcsr_q;  //\n        CSR_DPC: csr_rdata_int = depc_q;\n        CSR_DSCRATCH0: csr_rdata_int = dscratch0_q;  //\n        CSR_DSCRATCH1: csr_rdata_int = dscratch1_q;  //\n\n        // Hardware Performance Monitor\n        CSR_MCYCLE,\n      CSR_MINSTRET,\n      CSR_MHPMCOUNTER3,\n      CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,\n      CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,\n      CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,\n      CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,\n      CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,\n      CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,\n      CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31,\n      CSR_CYCLE,\n      CSR_INSTRET,\n      CSR_HPMCOUNTER3,\n      CSR_HPMCOUNTER4,  CSR_HPMCOUNTER5,  CSR_HPMCOUNTER6,  CSR_HPMCOUNTER7,\n      CSR_HPMCOUNTER8,  CSR_HPMCOUNTER9,  CSR_HPMCOUNTER10, CSR_HPMCOUNTER11,\n      CSR_HPMCOUNTER12, CSR_HPMCOUNTER13, CSR_HPMCOUNTER14, CSR_HPMCOUNTER15,\n      CSR_HPMCOUNTER16, CSR_HPMCOUNTER17, CSR_HPMCOUNTER18, CSR_HPMCOUNTER19,\n      CSR_HPMCOUNTER20, CSR_HPMCOUNTER21, CSR_HPMCOUNTER22, CSR_HPMCOUNTER23,\n      CSR_HPMCOUNTER24, CSR_HPMCOUNTER25, CSR_HPMCOUNTER26, CSR_HPMCOUNTER27,\n      CSR_HPMCOUNTER28, CSR_HPMCOUNTER29, CSR_HPMCOUNTER30, CSR_HPMCOUNTER31:\n        csr_rdata_int = mhpmcounter_q[csr_addr_i[4:0]][31:0];\n\n        CSR_MCYCLEH,\n      CSR_MINSTRETH,\n      CSR_MHPMCOUNTER3H,\n      CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,\n      CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,\n      CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,\n      CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,\n      CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,\n      CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,\n      CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H,\n      CSR_CYCLEH,\n      CSR_INSTRETH,\n      CSR_HPMCOUNTER3H,\n      CSR_HPMCOUNTER4H,  CSR_HPMCOUNTER5H,  CSR_HPMCOUNTER6H,  CSR_HPMCOUNTER7H,\n      CSR_HPMCOUNTER8H,  CSR_HPMCOUNTER9H,  CSR_HPMCOUNTER10H, CSR_HPMCOUNTER11H,\n      CSR_HPMCOUNTER12H, CSR_HPMCOUNTER13H, CSR_HPMCOUNTER14H, CSR_HPMCOUNTER15H,\n      CSR_HPMCOUNTER16H, CSR_HPMCOUNTER17H, CSR_HPMCOUNTER18H, CSR_HPMCOUNTER19H,\n      CSR_HPMCOUNTER20H, CSR_HPMCOUNTER21H, CSR_HPMCOUNTER22H, CSR_HPMCOUNTER23H,\n      CSR_HPMCOUNTER24H, CSR_HPMCOUNTER25H, CSR_HPMCOUNTER26H, CSR_HPMCOUNTER27H,\n      CSR_HPMCOUNTER28H, CSR_HPMCOUNTER29H, CSR_HPMCOUNTER30H, CSR_HPMCOUNTER31H:\n        csr_rdata_int = mhpmcounter_q[csr_addr_i[4:0]][63:32];\n\n        CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit_q;\n\n        CSR_MHPMEVENT3,\n      CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,\n      CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,\n      CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,\n      CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,\n      CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,\n      CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,\n      CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31:\n        csr_rdata_int = mhpmevent_q[csr_addr_i[4:0]];\n\n        // hardware loops  (not official)\n        CSR_LPSTART0: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_start_i[0];\n        CSR_LPEND0:   csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_end_i[0];\n        CSR_LPCOUNT0: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_cnt_i[0];\n        CSR_LPSTART1: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_start_i[1];\n        CSR_LPEND1:   csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_end_i[1];\n        CSR_LPCOUNT1: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_cnt_i[1];\n\n        // PMP config registers\n        CSR_PMPCFG0: csr_rdata_int = USE_PMP ? pmp_reg_q.pmpcfg_packed[0] : '0;\n        CSR_PMPCFG1: csr_rdata_int = USE_PMP ? pmp_reg_q.pmpcfg_packed[1] : '0;\n        CSR_PMPCFG2: csr_rdata_int = USE_PMP ? pmp_reg_q.pmpcfg_packed[2] : '0;\n        CSR_PMPCFG3: csr_rdata_int = USE_PMP ? pmp_reg_q.pmpcfg_packed[3] : '0;\n\n        CSR_PMPADDR0, CSR_PMPADDR1, CSR_PMPADDR2, CSR_PMPADDR3,\n      CSR_PMPADDR4, CSR_PMPADDR5, CSR_PMPADDR6, CSR_PMPADDR7,\n      CSR_PMPADDR8, CSR_PMPADDR9, CSR_PMPADDR10, CSR_PMPADDR11,\n      CSR_PMPADDR12, CSR_PMPADDR13, CSR_PMPADDR14, CSR_PMPADDR15 :\n        csr_rdata_int = USE_PMP ? pmp_reg_q.pmpaddr[csr_addr_i[3:0]] : '0;\n\n        /* USER CSR */\n        // ustatus\n        CSR_USTATUS: csr_rdata_int = {27'b0, mstatus_q.upie, 3'h0, mstatus_q.uie};\n        // utvec: user trap-handler base address\n        CSR_UTVEC: csr_rdata_int = {utvec_q, 6'h0, utvec_mode_q};\n        // duplicated mhartid: unique hardware thread id (not official)\n        CSR_UHARTID: csr_rdata_int = !COREV_PULP ? 'b0 : hart_id_i;\n        // uepc: exception program counter\n        CSR_UEPC: csr_rdata_int = uepc_q;\n        // ucause: exception cause\n        CSR_UCAUSE: csr_rdata_int = {ucause_q[5], 26'h0, ucause_q[4:0]};\n\n        // current priv level (not official)\n        CSR_PRIVLV: csr_rdata_int = !COREV_PULP ? 'b0 : {30'h0, priv_lvl_q};\n\n        default: csr_rdata_int = '0;\n      endcase\n    end\n  end else begin : gen_no_pulp_secure_read_logic  // PULP_SECURE == 0\n    // read logic\n    always_comb begin\n\n      case (csr_addr_i)\n        // fcsr: Floating-Point Control and Status Register (frm + fflags).\n        CSR_FFLAGS: csr_rdata_int = (FPU == 1) ? {27'b0, fflags_q} : '0;\n        CSR_FRM: csr_rdata_int = (FPU == 1) ? {29'b0, frm_q} : '0;\n        CSR_FCSR: csr_rdata_int = (FPU == 1) ? {24'b0, frm_q, fflags_q} : '0;\n        // mstatus: always M-mode, contains IE bit\n        CSR_MSTATUS:\n        csr_rdata_int = {\n          (FPU == 1 && ZFINX == 0) ? (mstatus_fs_q == FS_DIRTY ? 1'b1 : 1'b0) : 1'b0,\n          13'b0,\n          mstatus_q.mprv,\n          2'b0,\n          (FPU == 1 && ZFINX == 0) ? mstatus_fs_q : FS_OFF,\n          mstatus_q.mpp,\n          3'b0,\n          mstatus_q.mpie,\n          2'h0,\n          mstatus_q.upie,\n          mstatus_q.mie,\n          2'h0,\n          mstatus_q.uie\n        };\n        // misa: machine isa register\n        CSR_MISA: csr_rdata_int = MISA_VALUE;\n        // mie: machine interrupt enable\n        CSR_MIE: begin\n          csr_rdata_int = mie_q;\n        end\n\n        // mtvec: machine trap-handler base address\n        CSR_MTVEC: csr_rdata_int = {mtvec_q, 6'h0, mtvec_mode_q};\n        // mscratch: machine scratch\n        CSR_MSCRATCH: csr_rdata_int = mscratch_q;\n        // mepc: exception program counter\n        CSR_MEPC: csr_rdata_int = mepc_q;\n        // mcause: exception cause\n        CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};\n        // mip: interrupt pending\n        CSR_MIP: begin\n          csr_rdata_int = mip;\n        end\n        // mhartid: unique hardware thread id\n        CSR_MHARTID: csr_rdata_int = hart_id_i;\n\n        // mvendorid: Machine Vendor ID\n        CSR_MVENDORID: csr_rdata_int = {MVENDORID_BANK, MVENDORID_OFFSET};\n\n        // marchid: Machine Architecture ID\n        CSR_MARCHID: csr_rdata_int = MARCHID;\n\n        // mimpid, Machine Implementation ID\n        CSR_MIMPID: begin\n          csr_rdata_int = (FPU == 1 || COREV_PULP == 1 || COREV_CLUSTER == 1) ? 32'h1 : 'b0;\n        end\n\n        // unimplemented, read 0 CSRs\n        CSR_MTVAL: csr_rdata_int = 'b0;\n\n        CSR_TSELECT, CSR_TDATA3, CSR_MCONTEXT, CSR_SCONTEXT: csr_rdata_int = 'b0;  // Always read 0\n        CSR_TDATA1: csr_rdata_int = tmatch_control_rdata;\n        CSR_TDATA2: csr_rdata_int = tmatch_value_rdata;\n        CSR_TINFO: csr_rdata_int = tinfo_types;\n\n        CSR_DCSR: csr_rdata_int = dcsr_q;  //\n        CSR_DPC: csr_rdata_int = depc_q;\n        CSR_DSCRATCH0: csr_rdata_int = dscratch0_q;  //\n        CSR_DSCRATCH1: csr_rdata_int = dscratch1_q;  //\n\n        // Hardware Performance Monitor\n        CSR_MCYCLE,\n      CSR_MINSTRET,\n      CSR_MHPMCOUNTER3,\n      CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,\n      CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,\n      CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,\n      CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,\n      CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,\n      CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,\n      CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31,\n      CSR_CYCLE,\n      CSR_INSTRET,\n      CSR_HPMCOUNTER3,\n      CSR_HPMCOUNTER4,  CSR_HPMCOUNTER5,  CSR_HPMCOUNTER6,  CSR_HPMCOUNTER7,\n      CSR_HPMCOUNTER8,  CSR_HPMCOUNTER9,  CSR_HPMCOUNTER10, CSR_HPMCOUNTER11,\n      CSR_HPMCOUNTER12, CSR_HPMCOUNTER13, CSR_HPMCOUNTER14, CSR_HPMCOUNTER15,\n      CSR_HPMCOUNTER16, CSR_HPMCOUNTER17, CSR_HPMCOUNTER18, CSR_HPMCOUNTER19,\n      CSR_HPMCOUNTER20, CSR_HPMCOUNTER21, CSR_HPMCOUNTER22, CSR_HPMCOUNTER23,\n      CSR_HPMCOUNTER24, CSR_HPMCOUNTER25, CSR_HPMCOUNTER26, CSR_HPMCOUNTER27,\n      CSR_HPMCOUNTER28, CSR_HPMCOUNTER29, CSR_HPMCOUNTER30, CSR_HPMCOUNTER31:\n        csr_rdata_int = mhpmcounter_q[csr_addr_i[4:0]][31:0];\n\n        CSR_MCYCLEH,\n      CSR_MINSTRETH,\n      CSR_MHPMCOUNTER3H,\n      CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,\n      CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,\n      CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,\n      CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,\n      CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,\n      CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,\n      CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H,\n      CSR_CYCLEH,\n      CSR_INSTRETH,\n      CSR_HPMCOUNTER3H,\n      CSR_HPMCOUNTER4H,  CSR_HPMCOUNTER5H,  CSR_HPMCOUNTER6H,  CSR_HPMCOUNTER7H,\n      CSR_HPMCOUNTER8H,  CSR_HPMCOUNTER9H,  CSR_HPMCOUNTER10H, CSR_HPMCOUNTER11H,\n      CSR_HPMCOUNTER12H, CSR_HPMCOUNTER13H, CSR_HPMCOUNTER14H, CSR_HPMCOUNTER15H,\n      CSR_HPMCOUNTER16H, CSR_HPMCOUNTER17H, CSR_HPMCOUNTER18H, CSR_HPMCOUNTER19H,\n      CSR_HPMCOUNTER20H, CSR_HPMCOUNTER21H, CSR_HPMCOUNTER22H, CSR_HPMCOUNTER23H,\n      CSR_HPMCOUNTER24H, CSR_HPMCOUNTER25H, CSR_HPMCOUNTER26H, CSR_HPMCOUNTER27H,\n      CSR_HPMCOUNTER28H, CSR_HPMCOUNTER29H, CSR_HPMCOUNTER30H, CSR_HPMCOUNTER31H:\n        csr_rdata_int = (MHPMCOUNTER_WIDTH == 64) ? mhpmcounter_q[csr_addr_i[4:0]][63:32] : '0;\n\n        CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit_q;\n\n        CSR_MHPMEVENT3,\n      CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,\n      CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,\n      CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,\n      CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,\n      CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,\n      CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,\n      CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31:\n        csr_rdata_int = mhpmevent_q[csr_addr_i[4:0]];\n\n        // hardware loops  (not official)\n        CSR_LPSTART0: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_start_i[0];\n        CSR_LPEND0:   csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_end_i[0];\n        CSR_LPCOUNT0: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_cnt_i[0];\n        CSR_LPSTART1: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_start_i[1];\n        CSR_LPEND1:   csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_end_i[1];\n        CSR_LPCOUNT1: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_cnt_i[1];\n\n        /* USER CSR */\n        // dublicated mhartid: unique hardware thread id (not official)\n        CSR_UHARTID: csr_rdata_int = !COREV_PULP ? 'b0 : hart_id_i;\n        // current priv level (not official)\n        CSR_PRIVLV: csr_rdata_int = !COREV_PULP ? 'b0 : {30'h0, priv_lvl_q};\n        // Zfinx (not official)\n        CSR_ZFINX: csr_rdata_int = (FPU == 1 && ZFINX == 1) ? 32'h1 : 32'h0;\n        default: csr_rdata_int = '0;\n      endcase\n    end\n  end  //PULP_SECURE\n\n  if (PULP_SECURE == 1) begin : gen_pulp_secure_write_logic\n    // write logic\n    always_comb begin\n      fflags_n                = fflags_q;\n      frm_n                   = frm_q;\n      mscratch_n              = mscratch_q;\n      mepc_n                  = mepc_q;\n      uepc_n                  = uepc_q;\n      depc_n                  = depc_q;\n      dcsr_n                  = dcsr_q;\n      dscratch0_n             = dscratch0_q;\n      dscratch1_n             = dscratch1_q;\n\n      mstatus_n               = mstatus_q;\n      mcause_n                = mcause_q;\n      ucause_n                = ucause_q;\n      exception_pc            = pc_id_i;\n      priv_lvl_n              = priv_lvl_q;\n      mtvec_n                 = csr_mtvec_init_i ? mtvec_addr_i[31:8] : mtvec_q;\n      utvec_n                 = utvec_q;\n      mtvec_mode_n            = mtvec_mode_q;\n      utvec_mode_n            = utvec_mode_q;\n      pmp_reg_n.pmpaddr       = pmp_reg_q.pmpaddr;\n      pmp_reg_n.pmpcfg_packed = pmp_reg_q.pmpcfg_packed;\n      pmpaddr_we              = '0;\n      pmpcfg_we               = '0;\n\n      mie_n                   = mie_q;\n\n      if (FPU == 1) if (fflags_we_i) fflags_n = fflags_i | fflags_q;\n\n      case (csr_addr_i)\n        // fcsr: Floating-Point Control and Status Register (frm, fflags, fprec).\n        CSR_FFLAGS: if (csr_we_int) fflags_n = (FPU == 1) ? csr_wdata_int[C_FFLAG-1:0] : '0;\n        CSR_FRM:    if (csr_we_int) frm_n = (FPU == 1) ? csr_wdata_int[C_RM-1:0] : '0;\n        CSR_FCSR:\n        if (csr_we_int) begin\n          fflags_n = (FPU == 1) ? csr_wdata_int[C_FFLAG-1:0] : '0;\n          frm_n    = (FPU == 1) ? csr_wdata_int[C_RM+C_FFLAG-1:C_FFLAG] : '0;\n        end\n\n        // mstatus: IE bit\n        CSR_MSTATUS:\n        if (csr_we_int) begin\n          mstatus_n = '{\n              uie: csr_wdata_int[MSTATUS_UIE_BIT],\n              mie: csr_wdata_int[MSTATUS_MIE_BIT],\n              upie: csr_wdata_int[MSTATUS_UPIE_BIT],\n              mpie: csr_wdata_int[MSTATUS_MPIE_BIT],\n              mpp: PrivLvl_t'(csr_wdata_int[MSTATUS_MPP_BIT_HIGH:MSTATUS_MPP_BIT_LOW]),\n              mprv: csr_wdata_int[MSTATUS_MPRV_BIT]\n          };\n        end\n        // mie: machine interrupt enable\n        CSR_MIE:\n        if (csr_we_int) begin\n          mie_n = csr_wdata_int & IRQ_MASK;\n        end\n        // mtvec: machine trap-handler base address\n        CSR_MTVEC:\n        if (csr_we_int) begin\n          mtvec_n      = csr_wdata_int[31:8];\n          mtvec_mode_n = {1'b0, csr_wdata_int[0]};  // Only direct and vectored mode are supported\n        end\n        // mscratch: machine scratch\n        CSR_MSCRATCH:\n        if (csr_we_int) begin\n          mscratch_n = csr_wdata_int;\n        end\n        // mepc: exception program counter\n        CSR_MEPC:\n        if (csr_we_int) begin\n          mepc_n = csr_wdata_int & ~32'b1;  // force 16-bit alignment\n        end\n        // mcause\n        CSR_MCAUSE: if (csr_we_int) mcause_n = {csr_wdata_int[31], csr_wdata_int[4:0]};\n\n        // Debug\n        CSR_DCSR:\n        if (csr_we_int) begin\n          // Following are read-only and never assigned here (dcsr_q value is used):\n          //\n          // - xdebugver\n          // - cause\n          // - nmip\n\n          dcsr_n.ebreakm = csr_wdata_int[15];\n          dcsr_n.ebreaks = 1'b0;  // ebreaks (implemented as WARL)\n          dcsr_n.ebreaku = csr_wdata_int[12];\n          dcsr_n.stepie = csr_wdata_int[11];  // stepie\n          dcsr_n.stopcount = 1'b0;  // stopcount\n          dcsr_n.stoptime = 1'b0;  // stoptime\n          dcsr_n.mprven = 1'b0;  // mprven\n          dcsr_n.step = csr_wdata_int[2];\n          dcsr_n.prv       = (PrivLvl_t'(csr_wdata_int[1:0]) == PRIV_LVL_M) ? PRIV_LVL_M : PRIV_LVL_U; // prv (implemented as WARL)\n        end\n\n        CSR_DPC:\n        if (csr_we_int) begin\n          depc_n = csr_wdata_int & ~32'b1;  // force 16-bit alignment\n        end\n\n        CSR_DSCRATCH0:\n        if (csr_we_int) begin\n          dscratch0_n = csr_wdata_int;\n        end\n\n        CSR_DSCRATCH1:\n        if (csr_we_int) begin\n          dscratch1_n = csr_wdata_int;\n        end\n\n        // PMP config registers\n        CSR_PMPCFG0:\n        if (csr_we_int) begin\n          pmp_reg_n.pmpcfg_packed[0] = csr_wdata_int;\n          pmpcfg_we[3:0] = 4'b1111;\n        end\n        CSR_PMPCFG1:\n        if (csr_we_int) begin\n          pmp_reg_n.pmpcfg_packed[1] = csr_wdata_int;\n          pmpcfg_we[7:4] = 4'b1111;\n        end\n        CSR_PMPCFG2:\n        if (csr_we_int) begin\n          pmp_reg_n.pmpcfg_packed[2] = csr_wdata_int;\n          pmpcfg_we[11:8] = 4'b1111;\n        end\n        CSR_PMPCFG3:\n        if (csr_we_int) begin\n          pmp_reg_n.pmpcfg_packed[3] = csr_wdata_int;\n          pmpcfg_we[15:12] = 4'b1111;\n        end\n\n        CSR_PMPADDR0, CSR_PMPADDR1, CSR_PMPADDR2, CSR_PMPADDR3,\n      CSR_PMPADDR4, CSR_PMPADDR5, CSR_PMPADDR6, CSR_PMPADDR7,\n      CSR_PMPADDR8, CSR_PMPADDR9, CSR_PMPADDR10, CSR_PMPADDR11,\n      CSR_PMPADDR12, CSR_PMPADDR13, CSR_PMPADDR14, CSR_PMPADDR15 :\n        if (csr_we_int) begin\n          pmp_reg_n.pmpaddr[csr_addr_i[3:0]] = csr_wdata_int;\n          pmpaddr_we[csr_addr_i[3:0]] = 1'b1;\n        end\n\n\n        /* USER CSR */\n        // ucause: exception cause\n        CSR_USTATUS:\n        if (csr_we_int) begin\n          mstatus_n = '{\n              uie: csr_wdata_int[MSTATUS_UIE_BIT],\n              mie: mstatus_q.mie,\n              upie: csr_wdata_int[MSTATUS_UPIE_BIT],\n              mpie: mstatus_q.mpie,\n              mpp: mstatus_q.mpp,\n              mprv: mstatus_q.mprv\n          };\n        end\n        // utvec: user trap-handler base address\n        CSR_UTVEC:\n        if (csr_we_int) begin\n          utvec_n      = csr_wdata_int[31:8];\n          utvec_mode_n = {1'b0, csr_wdata_int[0]};  // Only direct and vectored mode are supported\n        end\n        // uepc: exception program counter\n        CSR_UEPC:\n        if (csr_we_int) begin\n          uepc_n = csr_wdata_int;\n        end\n        // ucause: exception cause\n        CSR_UCAUSE: if (csr_we_int) ucause_n = {csr_wdata_int[31], csr_wdata_int[4:0]};\n      endcase\n\n      // exception controller gets priority over other writes\n      unique case (1'b1)\n\n        csr_save_cause_i: begin\n\n          unique case (1'b1)\n            csr_save_if_i: exception_pc = pc_if_i;\n            csr_save_id_i: exception_pc = pc_id_i;\n            csr_save_ex_i: exception_pc = pc_ex_i;\n            default: ;\n          endcase\n\n          unique case (priv_lvl_q)\n\n            PRIV_LVL_U: begin\n              if (~is_irq) begin\n                //Exceptions, Ecall U --> M\n                priv_lvl_n     = PRIV_LVL_M;\n                mstatus_n.mpie = mstatus_q.uie;\n                mstatus_n.mie  = 1'b0;\n                mstatus_n.mpp  = PRIV_LVL_U;\n                if (debug_csr_save_i) depc_n = exception_pc;\n                else mepc_n = exception_pc;\n                mcause_n = csr_cause_i;\n\n              end else begin\n                if (~csr_irq_sec_i) begin\n                  //U --> U\n                  priv_lvl_n     = PRIV_LVL_U;\n                  mstatus_n.upie = mstatus_q.uie;\n                  mstatus_n.uie  = 1'b0;\n                  if (debug_csr_save_i) depc_n = exception_pc;\n                  else uepc_n = exception_pc;\n                  ucause_n = csr_cause_i;\n\n                end else begin\n                  //U --> M\n                  priv_lvl_n     = PRIV_LVL_M;\n                  mstatus_n.mpie = mstatus_q.uie;\n                  mstatus_n.mie  = 1'b0;\n                  mstatus_n.mpp  = PRIV_LVL_U;\n                  if (debug_csr_save_i) depc_n = exception_pc;\n                  else mepc_n = exception_pc;\n                  mcause_n = csr_cause_i;\n                end\n              end\n            end  //PRIV_LVL_U\n\n            PRIV_LVL_M: begin\n              if (debug_csr_save_i) begin\n                // all interrupts are masked, don't update cause, epc, tval dpc\n                // and mpstatus\n                dcsr_n.prv   = PRIV_LVL_M;\n                dcsr_n.cause = debug_cause_i;\n                depc_n       = exception_pc;\n              end else begin\n                //Exceptions or Interrupts from PRIV_LVL_M always do M --> M\n                priv_lvl_n     = PRIV_LVL_M;\n                mstatus_n.mpie = mstatus_q.mie;\n                mstatus_n.mie  = 1'b0;\n                mstatus_n.mpp  = PRIV_LVL_M;\n                mepc_n         = exception_pc;\n                mcause_n       = csr_cause_i;\n              end\n            end  //PRIV_LVL_M\n            default: ;\n\n          endcase\n\n        end  //csr_save_cause_i\n\n        csr_restore_uret_i: begin  //URET\n          //mstatus_q.upp is implicitly 0, i.e PRIV_LVL_U\n          mstatus_n.uie  = mstatus_q.upie;\n          priv_lvl_n     = PRIV_LVL_U;\n          mstatus_n.upie = 1'b1;\n        end  //csr_restore_uret_i\n\n        csr_restore_mret_i: begin  //MRET\n          unique case (mstatus_q.mpp)\n            PRIV_LVL_U: begin\n              mstatus_n.uie  = mstatus_q.mpie;\n              priv_lvl_n     = PRIV_LVL_U;\n              mstatus_n.mpie = 1'b1;\n              mstatus_n.mpp  = PRIV_LVL_U;\n            end\n            PRIV_LVL_M: begin\n              mstatus_n.mie  = mstatus_q.mpie;\n              priv_lvl_n     = PRIV_LVL_M;\n              mstatus_n.mpie = 1'b1;\n              mstatus_n.mpp  = PRIV_LVL_U;\n            end\n            default: ;\n          endcase\n        end  //csr_restore_mret_i\n\n\n        csr_restore_dret_i: begin  //DRET\n          // Restore to the recorded privilege level\n          priv_lvl_n = dcsr_q.prv;\n\n        end  //csr_restore_dret_i\n\n        default: ;\n      endcase\n    end\n  end else begin : gen_no_pulp_secure_write_logic  //PULP_SECURE == 0\n    // write logic\n    always_comb begin\n      if (FPU == 1) begin\n        fflags_n = fflags_q;\n        frm_n = frm_q;\n        if (ZFINX == 0) begin\n          mstatus_fs_n = mstatus_fs_q;\n          fcsr_update  = 1'b0;\n        end\n      end\n      mscratch_n = mscratch_q;\n      mepc_n = mepc_q;\n      uepc_n = 'b0;  // Not used if PULP_SECURE == 0\n      depc_n = depc_q;\n      dcsr_n = dcsr_q;\n      dscratch0_n = dscratch0_q;\n      dscratch1_n = dscratch1_q;\n\n      mstatus_we_int = 1'b0;\n      mstatus_n = mstatus_q;\n      mcause_n = mcause_q;\n      ucause_n = '0;  // Not used if PULP_SECURE == 0\n      exception_pc = pc_id_i;\n      priv_lvl_n = priv_lvl_q;\n      mtvec_n = csr_mtvec_init_i ? mtvec_addr_i[31:8] : mtvec_q;\n      utvec_n = '0;  // Not used if PULP_SECURE == 0\n      pmp_reg_n.pmpaddr = '0;  // Not used if PULP_SECURE == 0\n      pmp_reg_n.pmpcfg_packed = '0;  // Not used if PULP_SECURE == 0\n      pmp_reg_n.pmpcfg = '0;  // Not used if PULP_SECURE == 0\n      pmpaddr_we = '0;\n      pmpcfg_we = '0;\n\n      mie_n = mie_q;\n      mtvec_mode_n = mtvec_mode_q;\n      utvec_mode_n = '0;  // Not used if PULP_SECURE == 0\n\n      case (csr_addr_i)\n        // fcsr: Floating-Point Control and Status Register (frm, fflags, fprec).\n        CSR_FFLAGS:\n        if (FPU == 1) begin\n          if (csr_we_int) begin\n            fflags_n = csr_wdata_int[C_FFLAG-1:0];\n            if (ZFINX == 0) begin\n              fcsr_update = 1'b1;\n            end\n          end\n        end\n        CSR_FRM:\n        if (FPU == 1) begin\n          if (csr_we_int) begin\n            frm_n = csr_wdata_int[C_RM-1:0];\n            if (ZFINX == 0) begin\n              fcsr_update = 1'b1;\n            end\n          end\n        end\n        CSR_FCSR:\n        if (FPU == 1) begin\n          if (csr_we_int) begin\n            fflags_n = csr_wdata_int[C_FFLAG-1:0];\n            frm_n    = csr_wdata_int[C_RM+C_FFLAG-1:C_FFLAG];\n            if (ZFINX == 0) begin\n              fcsr_update = 1'b1;\n            end\n          end\n        end\n\n        // mstatus\n        CSR_MSTATUS:\n        if (csr_we_int) begin\n          mstatus_n = '{\n              uie: csr_wdata_int[MSTATUS_UIE_BIT],\n              mie: csr_wdata_int[MSTATUS_MIE_BIT],\n              upie: csr_wdata_int[MSTATUS_UPIE_BIT],\n              mpie: csr_wdata_int[MSTATUS_MPIE_BIT],\n              mpp: PrivLvl_t'(csr_wdata_int[MSTATUS_MPP_BIT_HIGH:MSTATUS_MPP_BIT_LOW]),\n              mprv: csr_wdata_int[MSTATUS_MPRV_BIT]\n          };\n          if (FPU == 1 && ZFINX == 0) begin\n            mstatus_we_int = 1'b1;\n            mstatus_fs_n   = FS_t'(csr_wdata_int[MSTATUS_FS_BIT_HIGH:MSTATUS_FS_BIT_LOW]);\n          end\n        end\n        // mie: machine interrupt enable\n        CSR_MIE:\n        if (csr_we_int) begin\n          mie_n = csr_wdata_int & IRQ_MASK;\n        end\n        // mtvec: machine trap-handler base address\n        CSR_MTVEC:\n        if (csr_we_int) begin\n          mtvec_n      = csr_wdata_int[31:8];\n          mtvec_mode_n = {1'b0, csr_wdata_int[0]};  // Only direct and vectored mode are supported\n        end\n        // mscratch: machine scratch\n        CSR_MSCRATCH:\n        if (csr_we_int) begin\n          mscratch_n = csr_wdata_int;\n        end\n        // mepc: exception program counter\n        CSR_MEPC:\n        if (csr_we_int) begin\n          mepc_n = csr_wdata_int & ~32'b1;  // force 16-bit alignment\n        end\n        // mcause\n        CSR_MCAUSE: if (csr_we_int) mcause_n = {csr_wdata_int[31], csr_wdata_int[4:0]};\n\n        CSR_DCSR:\n        if (csr_we_int) begin\n          // Following are read-only and never assigned here (dcsr_q value is used):\n          //\n          // - xdebugver\n          // - cause\n          // - nmip\n\n          dcsr_n.ebreakm   = csr_wdata_int[15];\n          dcsr_n.ebreaks   = 1'b0;  // ebreaks (implemented as WARL)\n          dcsr_n.ebreaku   = 1'b0;  // ebreaku (implemented as WARL)\n          dcsr_n.stepie    = csr_wdata_int[11];  // stepie\n          dcsr_n.stopcount = 1'b0;  // stopcount\n          dcsr_n.stoptime  = 1'b0;  // stoptime\n          dcsr_n.mprven    = 1'b0;  // mprven\n          dcsr_n.step      = csr_wdata_int[2];\n          dcsr_n.prv       = PRIV_LVL_M;  // prv (implemendted as WARL)\n        end\n\n        CSR_DPC:\n        if (csr_we_int) begin\n          depc_n = csr_wdata_int & ~32'b1;  // force 16-bit alignment\n        end\n\n        CSR_DSCRATCH0:\n        if (csr_we_int) begin\n          dscratch0_n = csr_wdata_int;\n        end\n\n        CSR_DSCRATCH1:\n        if (csr_we_int) begin\n          dscratch1_n = csr_wdata_int;\n        end\n\n      endcase\n\n      if (FPU == 1) begin\n        if (fflags_we_i) begin\n          fflags_n = fflags_i | fflags_q;\n        end\n\n        if (ZFINX == 0) begin\n          // FPU Register File/Flags implicit update or modified by CSR instructions\n          if ((fregs_we_i && !(mstatus_we_int && mstatus_fs_n != FS_DIRTY)) || fflags_we_i || fcsr_update) begin\n            mstatus_fs_n = FS_DIRTY;\n          end\n        end\n      end\n\n      // exception controller gets priority over other writes\n      unique case (1'b1)\n\n        csr_save_cause_i: begin\n          unique case (1'b1)\n            csr_save_if_i: exception_pc = pc_if_i;\n            csr_save_id_i: exception_pc = pc_id_i;\n            csr_save_ex_i: exception_pc = pc_ex_i;\n            default: ;\n          endcase\n\n          if (debug_csr_save_i) begin\n            // all interrupts are masked, don't update cause, epc, tval dpc and\n            // mpstatus\n            dcsr_n.prv   = PRIV_LVL_M;\n            dcsr_n.cause = debug_cause_i;\n            depc_n       = exception_pc;\n          end else begin\n            priv_lvl_n     = PRIV_LVL_M;\n            mstatus_n.mpie = mstatus_q.mie;\n            mstatus_n.mie  = 1'b0;\n            mstatus_n.mpp  = PRIV_LVL_M;\n            mepc_n         = exception_pc;\n            mcause_n       = csr_cause_i;\n          end\n        end  //csr_save_cause_i\n\n        csr_restore_mret_i: begin  //MRET\n          mstatus_n.mie  = mstatus_q.mpie;\n          priv_lvl_n     = PRIV_LVL_M;\n          mstatus_n.mpie = 1'b1;\n          mstatus_n.mpp  = PRIV_LVL_M;\n        end  //csr_restore_mret_i\n\n        csr_restore_dret_i: begin  //DRET\n          // Restore to the recorded privilege level\n          priv_lvl_n = dcsr_q.prv;\n        end  //csr_restore_dret_i\n\n        default: ;\n      endcase\n    end\n  end  //PULP_SECURE\n\n  // CSR operation logic\n  always_comb begin\n    csr_wdata_int = csr_wdata_i;\n    csr_we_int    = 1'b1;\n\n    case (csr_op_i)\n      CSR_OP_WRITE: csr_wdata_int = csr_wdata_i;\n      CSR_OP_SET:   csr_wdata_int = csr_wdata_i | csr_rdata_o;\n      CSR_OP_CLEAR: csr_wdata_int = (~csr_wdata_i) & csr_rdata_o;\n\n      CSR_OP_READ: begin\n        csr_wdata_int = csr_wdata_i;\n        csr_we_int    = 1'b0;\n      end\n    endcase\n  end\n\n  assign csr_rdata_o = csr_rdata_int;\n\n  // directly output some registers\n  assign m_irq_enable_o = mstatus_q.mie && !(dcsr_q.step && !dcsr_q.stepie);\n  assign u_irq_enable_o = mstatus_q.uie && !(dcsr_q.step && !dcsr_q.stepie);\n  assign priv_lvl_o = priv_lvl_q;\n  assign sec_lvl_o = priv_lvl_q[0];\n\n  // mstatus_fs_q = FS_OFF, FPU not enabled\n  assign fs_off_o = (FPU == 1 && ZFINX == 0) ? (mstatus_fs_q == FS_OFF ? 1'b1 : 1'b0) : 1'b0;\n  assign frm_o = (FPU == 1) ? frm_q : '0;\n\n  assign mtvec_o = mtvec_q;\n  assign utvec_o = utvec_q;\n  assign mtvec_mode_o = mtvec_mode_q;\n  assign utvec_mode_o = utvec_mode_q;\n\n  assign mepc_o = mepc_q;\n  assign uepc_o = uepc_q;\n\n  assign mcounteren_o = PULP_SECURE ? mcounteren_q : '0;\n\n  assign depc_o = depc_q;\n\n  assign pmp_addr_o = pmp_reg_q.pmpaddr;\n  assign pmp_cfg_o = pmp_reg_q.pmpcfg;\n\n  assign debug_single_step_o = dcsr_q.step;\n  assign debug_ebreakm_o = dcsr_q.ebreakm;\n  assign debug_ebreaku_o = dcsr_q.ebreaku;\n\n  generate\n    if (PULP_SECURE == 1) begin : gen_pmp_user\n\n      for (j = 0; j < N_PMP_ENTRIES; j++) begin : CS_PMP_CFG\n        assign pmp_reg_n.pmpcfg[j] = pmp_reg_n.pmpcfg_packed[j/4][8*((j%4)+1)-1:8*(j%4)];\n        assign pmp_reg_q.pmpcfg_packed[j/4][8*((j%4)+1)-1:8*(j%4)] = pmp_reg_q.pmpcfg[j];\n      end\n\n      for (j = 0; j < N_PMP_ENTRIES; j++) begin : CS_PMP_REGS_FF\n        always_ff @(posedge clk, negedge rst_n) begin\n          if (rst_n == 1'b0) begin\n            pmp_reg_q.pmpcfg[j]  <= '0;\n            pmp_reg_q.pmpaddr[j] <= '0;\n          end else begin\n            if (pmpcfg_we[j]) pmp_reg_q.pmpcfg[j] <= USE_PMP ? pmp_reg_n.pmpcfg[j] : '0;\n            if (pmpaddr_we[j]) pmp_reg_q.pmpaddr[j] <= USE_PMP ? pmp_reg_n.pmpaddr[j] : '0;\n          end\n        end\n      end  //CS_PMP_REGS_FF\n\n      always_ff @(posedge clk, negedge rst_n) begin\n        if (rst_n == 1'b0) begin\n          uepc_q       <= '0;\n          ucause_q     <= '0;\n          utvec_q      <= '0;\n          utvec_mode_q <= MTVEC_MODE;\n          priv_lvl_q   <= PRIV_LVL_M;\n        end else begin\n          uepc_q       <= uepc_n;\n          ucause_q     <= ucause_n;\n          utvec_q      <= utvec_n;\n          utvec_mode_q <= utvec_mode_n;\n          priv_lvl_q   <= priv_lvl_n;\n        end\n      end\n    end else begin : gen_no_pmp_user\n      assign pmp_reg_q    = '0;\n      assign uepc_q       = '0;\n      assign ucause_q     = '0;\n      assign utvec_q      = '0;\n      assign utvec_mode_q = '0;\n      assign priv_lvl_q   = PRIV_LVL_M;\n    end\n  endgenerate\n\n  // actual registers\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      if (FPU == 1) begin\n        frm_q <= '0;\n        fflags_q <= '0;\n        if (ZFINX == 0) begin\n          mstatus_fs_q <= FS_OFF;\n        end\n      end\n      mstatus_q <= '{\n          uie: 1'b0,\n          mie: 1'b0,\n          upie: 1'b0,\n          mpie: 1'b0,\n          mpp: PRIV_LVL_M,\n          mprv: 1'b0\n      };\n      mepc_q <= '0;\n      mcause_q <= '0;\n\n      depc_q <= '0;\n      dcsr_q <= '{\n          xdebugver: XDEBUGVER_STD,\n          cause: DBG_CAUSE_NONE,  // 3'h0\n          prv: PRIV_LVL_M,\n          default: '0\n      };\n      dscratch0_q <= '0;\n      dscratch1_q <= '0;\n      mscratch_q <= '0;\n      mie_q <= '0;\n      mtvec_q <= '0;\n      mtvec_mode_q <= MTVEC_MODE;\n    end else begin\n      // update CSRs\n      if (FPU == 1) begin\n        frm_q    <= frm_n;\n        fflags_q <= fflags_n;\n        if (ZFINX == 0) begin\n          mstatus_fs_q <= mstatus_fs_n;\n        end\n      end\n      if (PULP_SECURE == 1) begin\n        mstatus_q <= mstatus_n;\n      end else begin\n        mstatus_q <= '{\n            uie: 1'b0,\n            mie: mstatus_n.mie,\n            upie: 1'b0,\n            mpie: mstatus_n.mpie,\n            mpp: PRIV_LVL_M,\n            mprv: 1'b0\n        };\n      end\n      mepc_q       <= mepc_n;\n      mcause_q     <= mcause_n;\n      depc_q       <= depc_n;\n      dcsr_q       <= dcsr_n;\n      dscratch0_q  <= dscratch0_n;\n      dscratch1_q  <= dscratch1_n;\n      mscratch_q   <= mscratch_n;\n      mie_q        <= mie_n;\n      mtvec_q      <= mtvec_n;\n      mtvec_mode_q <= mtvec_mode_n;\n    end\n  end\n  ////////////////////////////////////////////////////////////////////////\n  //  ____       _                   _____     _                        //\n  // |  _ \\  ___| |__  _   _  __ _  |_   _| __(_) __ _  __ _  ___ _ __  //\n  // | | | |/ _ \\ '_ \\| | | |/ _` |   | || '__| |/ _` |/ _` |/ _ \\ '__| //\n  // | |_| |  __/ |_) | |_| | (_| |   | || |  | | (_| | (_| |  __/ |    //\n  // |____/ \\___|_.__/ \\__,_|\\__, |   |_||_|  |_|\\__, |\\__, |\\___|_|    //\n  //                         |___/               |___/ |___/            //\n  ////////////////////////////////////////////////////////////////////////\n\n  if (DEBUG_TRIGGER_EN) begin : gen_trigger_regs\n    // Register values\n    logic        tmatch_control_exec_q;\n    logic [31:0] tmatch_value_q;\n    // Write enables\n    logic        tmatch_control_we;\n    logic        tmatch_value_we;\n\n    // Write select\n    assign tmatch_control_we = csr_we_int & debug_mode_i & (csr_addr_i == CSR_TDATA1);\n    assign tmatch_value_we   = csr_we_int & debug_mode_i & (csr_addr_i == CSR_TDATA2);\n\n\n    // Registers\n    always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n        tmatch_control_exec_q <= 'b0;\n        tmatch_value_q        <= 'b0;\n      end else begin\n        if (tmatch_control_we) tmatch_control_exec_q <= csr_wdata_int[2];\n        if (tmatch_value_we) tmatch_value_q <= csr_wdata_int[31:0];\n      end\n    end\n\n    // All supported trigger types\n    assign tinfo_types = 1 << TTYPE_MCONTROL;\n\n    // Assign read data\n    // TDATA0 - only support simple address matching\n    assign tmatch_control_rdata = {\n      TTYPE_MCONTROL,  // type    : address/data match\n      1'b1,  // dmode   : access from D mode only\n      6'h00,  // maskmax : exact match only\n      1'b0,  // hit     : not supported\n      1'b0,  // select  : address match only\n      1'b0,  // timing  : match before execution\n      2'b00,  // sizelo  : match any access\n      4'h1,  // action  : enter debug mode\n      1'b0,  // chain   : not supported\n      4'h0,  // match   : simple match\n      1'b1,  // m       : match in m-mode\n      1'b0,  // 0       : zero\n      1'b0,  // s       : not supported\n      PULP_SECURE == 1,  // u       : match in u-mode\n      tmatch_control_exec_q,  // execute : match instruction address\n      1'b0,  // store   : not supported\n      1'b0\n    };  // load    : not supported\n\n    // TDATA1 - address match value only\n    assign tmatch_value_rdata = tmatch_value_q;\n\n    // Breakpoint matching\n    // We match against the next address, as the breakpoint must be taken before execution\n    assign trigger_match_o = tmatch_control_exec_q & (pc_id_i[31:0] == tmatch_value_q[31:0]);\n\n  end else begin : gen_no_trigger_regs\n    assign tinfo_types          = 'b0;\n    assign tmatch_control_rdata = 'b0;\n    assign tmatch_value_rdata   = 'b0;\n    assign trigger_match_o      = 'b0;\n  end\n\n  /////////////////////////////////////////////////////////////////\n  //   ____            __     ____                  _            //\n  // |  _ \\ ___ _ __ / _|   / ___|___  _   _ _ __ | |_ ___ _ __  //\n  // | |_) / _ \\ '__| |_   | |   / _ \\| | | | '_ \\| __/ _ \\ '__| //\n  // |  __/  __/ |  |  _|  | |__| (_) | |_| | | | | ||  __/ |    //\n  // |_|   \\___|_|  |_|(_)  \\____\\___/ \\__,_|_| |_|\\__\\___|_|    //\n  //                                                             //\n  /////////////////////////////////////////////////////////////////\n\n  // ------------------------\n  // Events to count\n  assign hpm_events[0] = 1'b1;  // cycle counter\n  assign hpm_events[1] = mhpmevent_minstret_i;  // instruction counter\n  assign hpm_events[2] = mhpmevent_ld_stall_i;  // nr of load use hazards\n  assign hpm_events[3] = mhpmevent_jr_stall_i;  // nr of jump register hazards\n  assign hpm_events[4]  = mhpmevent_imiss_i;                             // cycles waiting for instruction fetches, excluding jumps and branches\n  assign hpm_events[5] = mhpmevent_load_i;  // nr of loads\n  assign hpm_events[6] = mhpmevent_store_i;  // nr of stores\n  assign hpm_events[7] = mhpmevent_jump_i;  // nr of jumps (unconditional)\n  assign hpm_events[8] = mhpmevent_branch_i;  // nr of branches (conditional)\n  assign hpm_events[9] = mhpmevent_branch_taken_i;  // nr of taken branches (conditional)\n  assign hpm_events[10] = mhpmevent_compressed_i;  // compressed instruction counter\n  assign hpm_events[11] = COREV_CLUSTER ? mhpmevent_pipe_stall_i : 1'b0;  // extra cycles from ELW\n  assign hpm_events[12] = !APU ? 1'b0 : apu_typeconflict_i && !apu_dep_i;\n  assign hpm_events[13] = !APU ? 1'b0 : apu_contention_i;\n  assign hpm_events[14] = !APU ? 1'b0 : apu_dep_i && !apu_contention_i;\n  assign hpm_events[15] = !APU ? 1'b0 : apu_wb_i;\n\n  // ------------------------\n  // address decoder for performance counter registers\n  logic mcounteren_we;\n  logic mcountinhibit_we;\n  logic mhpmevent_we;\n\n  assign mcounteren_we = csr_we_int & (csr_addr_i == CSR_MCOUNTEREN);\n  assign mcountinhibit_we = csr_we_int & (csr_addr_i == CSR_MCOUNTINHIBIT);\n  assign mhpmevent_we     = csr_we_int & ( (csr_addr_i == CSR_MHPMEVENT3  )||\n                                           (csr_addr_i == CSR_MHPMEVENT4  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT5  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT6  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT7  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT8  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT9  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT10 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT11 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT12 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT13 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT14 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT15 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT16 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT17 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT18 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT19 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT20 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT21 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT22 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT23 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT24 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT25 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT26 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT27 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT28 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT29 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT30 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT31 ) );\n\n  // ------------------------\n  // Increment value for performance counters\n  genvar incr_gidx;\n  generate\n    for (incr_gidx = 0; incr_gidx < 32; incr_gidx++) begin : gen_mhpmcounter_increment\n      assign mhpmcounter_increment[incr_gidx] = mhpmcounter_q[incr_gidx] + 1;\n    end\n  endgenerate\n\n  // ------------------------\n  // next value for performance counters and control registers\n  always_comb begin\n    mcounteren_n    = mcounteren_q;\n    mcountinhibit_n = mcountinhibit_q;\n    mhpmevent_n     = mhpmevent_q;\n\n    // User Mode Enable\n    if (PULP_SECURE && mcounteren_we) mcounteren_n = csr_wdata_int;\n\n    // Inhibit Control\n    if (mcountinhibit_we) mcountinhibit_n = csr_wdata_int;\n\n    // Event Control\n    if (mhpmevent_we) mhpmevent_n[csr_addr_i[4:0]] = csr_wdata_int;\n  end\n\n  genvar wcnt_gidx;\n  generate\n    for (wcnt_gidx = 0; wcnt_gidx < 32; wcnt_gidx++) begin : gen_mhpmcounter_write\n\n      // Write lower counter bits\n      assign mhpmcounter_write_lower[wcnt_gidx] = csr_we_int && (csr_addr_i == (CSR_MCYCLE + wcnt_gidx));\n\n      // Write upper counter bits\n      assign mhpmcounter_write_upper[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                  csr_we_int && (csr_addr_i == (CSR_MCYCLEH + wcnt_gidx)) && (MHPMCOUNTER_WIDTH == 64);\n\n      // Increment counter\n      if (!PULP_PERF_COUNTERS) begin : gen_no_pulp_perf_counters\n        if (wcnt_gidx == 0) begin : gen_mhpmcounter_mcycle\n          // mcycle = mhpmcounter[0] : count every cycle (if not inhibited)\n          assign mhpmcounter_write_increment[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                          !mhpmcounter_write_upper[wcnt_gidx] &&\n                                                          !mcountinhibit_q[wcnt_gidx];\n        end else if (wcnt_gidx == 2) begin : gen_mhpmcounter_minstret\n          // minstret = mhpmcounter[2]  : count every retired instruction (if not inhibited)\n          assign mhpmcounter_write_increment[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                          !mhpmcounter_write_upper[wcnt_gidx] &&\n                                                          !mcountinhibit_q[wcnt_gidx] &&\n                                                          hpm_events[1];\n        end else if( (wcnt_gidx>2) && (wcnt_gidx<(NUM_MHPMCOUNTERS+3))) begin : gen_mhpmcounter\n          // add +1 if any event is enabled and active\n          assign mhpmcounter_write_increment[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                          !mhpmcounter_write_upper[wcnt_gidx] &&\n                                                          !mcountinhibit_q[wcnt_gidx] &&\n                                                          |(hpm_events & mhpmevent_q[wcnt_gidx][NUM_HPM_EVENTS-1:0]);\n        end else begin : gen_mhpmcounter_not_implemented\n          assign mhpmcounter_write_increment[wcnt_gidx] = 1'b0;\n        end\n      end else begin : gen_pulp_perf_counters\n        // PULP PERF COUNTERS share all events in one register (not compliant with RISC-V)\n        assign mhpmcounter_write_increment[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                        !mhpmcounter_write_upper[wcnt_gidx] &&\n                                                        !mcountinhibit_q[wcnt_gidx] &&\n                                                        |(hpm_events & mhpmevent_q[wcnt_gidx][NUM_HPM_EVENTS-1:0]);\n      end\n    end\n  endgenerate\n\n  // ------------------------\n  // HPM Registers\n  //  Counter Registers: mhpcounter_q[]\n  genvar cnt_gidx;\n  generate\n    for (cnt_gidx = 0; cnt_gidx < 32; cnt_gidx++) begin : gen_mhpmcounter\n      // mcyclce  is located at index 0\n      // there is no counter at index 1\n      // minstret is located at index 2\n      // Programable HPM counters start at index 3\n      if ((cnt_gidx == 1) || (cnt_gidx >= (NUM_MHPMCOUNTERS + 3))) begin : gen_non_implemented\n        assign mhpmcounter_q[cnt_gidx] = 'b0;\n      end else begin : gen_implemented\n        always_ff @(posedge clk, negedge rst_n)\n          if (!rst_n) begin\n            mhpmcounter_q[cnt_gidx] <= 'b0;\n          end else begin\n            if (PULP_PERF_COUNTERS && (cnt_gidx == 2 || cnt_gidx == 0)) begin\n              mhpmcounter_q[cnt_gidx] <= 'b0;\n            end else begin\n              if (mhpmcounter_write_lower[cnt_gidx]) begin\n                mhpmcounter_q[cnt_gidx][31:0] <= csr_wdata_int;\n              end else if (mhpmcounter_write_upper[cnt_gidx]) begin\n                mhpmcounter_q[cnt_gidx][63:32] <= csr_wdata_int;\n              end else if (mhpmcounter_write_increment[cnt_gidx]) begin\n                mhpmcounter_q[cnt_gidx] <= mhpmcounter_increment[cnt_gidx];\n              end\n            end\n          end\n      end\n    end\n  endgenerate\n\n  //  Event Register: mhpevent_q[]\n  genvar evt_gidx;\n  generate\n    for (evt_gidx = 0; evt_gidx < 32; evt_gidx++) begin : gen_mhpmevent\n      // programable HPM events start at index3\n      if ((evt_gidx < 3) || (evt_gidx >= (NUM_MHPMCOUNTERS + 3))) begin : gen_non_implemented\n        assign mhpmevent_q[evt_gidx] = 'b0;\n      end else begin : gen_implemented\n        if (NUM_HPM_EVENTS < 32) begin : gen_tie_off\n          assign mhpmevent_q[evt_gidx][31:NUM_HPM_EVENTS] = 'b0;\n        end\n        always_ff @(posedge clk, negedge rst_n)\n          if (!rst_n) mhpmevent_q[evt_gidx][NUM_HPM_EVENTS-1:0] <= 'b0;\n          else\n            mhpmevent_q[evt_gidx][NUM_HPM_EVENTS-1:0] <= mhpmevent_n[evt_gidx][NUM_HPM_EVENTS-1:0];\n      end\n    end\n  endgenerate\n\n  //  Enable Regsiter: mcounteren_q\n  genvar en_gidx;\n  generate\n    for (en_gidx = 0; en_gidx < 32; en_gidx++) begin : gen_mcounteren\n      if( (PULP_SECURE == 0) ||\n          (en_gidx == 1) ||\n          (en_gidx >= (NUM_MHPMCOUNTERS+3) ) )\n        begin : gen_non_implemented\n        assign mcounteren_q[en_gidx] = 'b0;\n      end else begin : gen_implemented\n        always_ff @(posedge clk, negedge rst_n)\n          if (!rst_n) mcounteren_q[en_gidx] <= 'b0;  // default disable\n          else mcounteren_q[en_gidx] <= mcounteren_n[en_gidx];\n      end\n    end\n  endgenerate\n\n  //  Inhibit Regsiter: mcountinhibit_q\n  //  Note: implemented counters are disabled out of reset to save power\n  genvar inh_gidx;\n  generate\n    for (inh_gidx = 0; inh_gidx < 32; inh_gidx++) begin : gen_mcountinhibit\n      if ((inh_gidx == 1) || (inh_gidx >= (NUM_MHPMCOUNTERS + 3))) begin : gen_non_implemented\n        assign mcountinhibit_q[inh_gidx] = 'b0;\n      end else begin : gen_implemented\n        always_ff @(posedge clk, negedge rst_n)\n          if (!rst_n) mcountinhibit_q[inh_gidx] <= 'b1;  // default disable\n          else mcountinhibit_q[inh_gidx] <= mcountinhibit_n[inh_gidx];\n      end\n    end\n  endgenerate\n\n`ifdef CV32E40P_ASSERT_ON\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n  // Check that mie_bypass_o equals mie_n\n  a_mie_bypass :\n  assert property (@(posedge clk) disable iff (!rst_n) (1'b1) |-> (mie_bypass_o == mie_n));\n\n`endif\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);