var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_prefetch_buffer.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                                                                            //\n// Design Name:    Prefetcher Buffer for 32 bit memory interface              //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Prefetch Buffer that caches instructions. This cuts overly //\n//                 long critical paths to the instruction cache               //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\n// input port: send address one cycle before the data\n// clear_i clears the FIFO for the following cycle. in_addr_i can be sent in\n// this cycle already\n\nmodule cv32e40p_prefetch_buffer #(\n    parameter PULP_OBI = 0,  // Legacy PULP OBI behavior\n    parameter COREV_PULP = 1  // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding p.elw)\n) (\n    input logic clk,\n    input logic rst_n,\n\n    input logic        req_i,\n    input logic        branch_i,\n    input logic [31:0] branch_addr_i,\n\n    input logic        hwlp_jump_i,\n    input logic [31:0] hwlp_target_i,\n\n    input  logic        fetch_ready_i,\n    output logic        fetch_valid_o,\n    output logic [31:0] fetch_rdata_o,\n\n    // goes to instruction memory / instruction cache\n    output logic        instr_req_o,\n    input  logic        instr_gnt_i,\n    output logic [31:0] instr_addr_o,\n    input  logic [31:0] instr_rdata_i,\n    input  logic        instr_rvalid_i,\n    input  logic        instr_err_i,  // Not used yet (future addition)\n    input  logic        instr_err_pmp_i,  // Not used yet (future addition)\n\n    // Prefetch Buffer Status\n    output logic busy_o\n);\n  // FIFO_DEPTH controls also the number of outstanding memory requests\n  // FIFO_DEPTH must be greater than 1 to respect assertion in prefetch controller\n  // FIFO_DEPTH must be a power of 2 (because of the FIFO implementation)\n  localparam FIFO_DEPTH                     = 2; //must be greater or equal to 2 //Set at least to 3 to avoid stalls compared to the master branch\n  localparam int unsigned FIFO_ADDR_DEPTH = $clog2(FIFO_DEPTH);\n\n  // Transaction request (between cv32e40p_prefetch_controller and cv32e40p_obi_interface)\n  logic                     trans_valid;\n  logic                     trans_ready;\n  logic [             31:0] trans_addr;\n\n  logic                     fifo_flush;\n  logic                     fifo_flush_but_first;\n  logic [FIFO_ADDR_DEPTH:0] fifo_cnt;  // fifo_cnt should count from 0 to FIFO_DEPTH!\n\n  logic [             31:0] fifo_rdata;\n  logic                     fifo_push;\n  logic                     fifo_pop;\n  logic                     fifo_empty;\n\n  // Transaction response interface (between cv32e40p_obi_interface and cv32e40p_fetch_fifo)\n  logic                     resp_valid;\n  logic [             31:0] resp_rdata;\n  logic                     resp_err;  // Unused for now\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Prefetch Controller\n  //////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_prefetch_controller #(\n      .DEPTH     (FIFO_DEPTH),\n      .PULP_OBI  (PULP_OBI),\n      .COREV_PULP(COREV_PULP)\n  ) prefetch_controller_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .req_i        (req_i),\n      .branch_i     (branch_i),\n      .branch_addr_i(branch_addr_i),\n      .busy_o       (busy_o),\n\n      .hwlp_jump_i  (hwlp_jump_i),\n      .hwlp_target_i(hwlp_target_i),\n\n      .trans_valid_o(trans_valid),\n      .trans_ready_i(trans_ready),\n      .trans_addr_o (trans_addr),\n\n      .resp_valid_i(resp_valid),\n\n      .fetch_ready_i(fetch_ready_i),\n      .fetch_valid_o(fetch_valid_o),\n\n      .fifo_push_o           (fifo_push),\n      .fifo_pop_o            (fifo_pop),\n      .fifo_flush_o          (fifo_flush),\n      .fifo_flush_but_first_o(fifo_flush_but_first),\n      .fifo_cnt_i            (fifo_cnt),\n      .fifo_empty_i          (fifo_empty)\n  );\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Fetch FIFO && fall-through path\n  //////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_fifo #(\n      .FALL_THROUGH(1'b0),\n      .DATA_WIDTH  (32),\n      .DEPTH       (FIFO_DEPTH)\n  ) fifo_i (\n      .clk_i            (clk),\n      .rst_ni           (rst_n),\n      .flush_i          (fifo_flush),\n      .flush_but_first_i(fifo_flush_but_first),\n      .testmode_i       (1'b0),\n      .full_o           (),\n      .empty_o          (fifo_empty),\n      .cnt_o            (fifo_cnt),\n      .data_i           (resp_rdata),\n      .push_i           (fifo_push),\n      .data_o           (fifo_rdata),\n      .pop_i            (fifo_pop)\n  );\n\n  // First POP from the FIFO if it is not empty.\n  // Otherwise, try to fall-through it.\n  assign fetch_rdata_o = fifo_empty ? resp_rdata : fifo_rdata;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // OBI interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_obi_interface #(\n      .TRANS_STABLE(0)  // trans_* is NOT guaranteed stable during waited transfers;\n      // this is ignored for legacy PULP behavior (not compliant to OBI)\n  )                                                     // Keep this parameter stuck to 0 to make HWLP work\n\n  instruction_obi_i\n  (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .trans_valid_i(trans_valid),\n      .trans_ready_o(trans_ready),\n      .trans_addr_i ({trans_addr[31:2], 2'b00}),\n      .trans_we_i   (1'b0),  // Instruction interface (never write)\n      .trans_be_i   (4'b1111),  // Corresponding obi_be_o not used\n      .trans_wdata_i(32'b0),  // Corresponding obi_wdata_o not used\n      .trans_atop_i (6'b0),  // Atomics not used on instruction bus\n\n      .resp_valid_o(resp_valid),\n      .resp_rdata_o(resp_rdata),\n      .resp_err_o  (resp_err),  // Unused for now\n\n      .obi_req_o   (instr_req_o),\n      .obi_gnt_i   (instr_gnt_i),\n      .obi_addr_o  (instr_addr_o),\n      .obi_we_o    (),  // Left unconnected on purpose\n      .obi_be_o    (),  // Left unconnected on purpose\n      .obi_wdata_o (),  // Left unconnected on purpose\n      .obi_atop_o  (),  // Left unconnected on purpose\n      .obi_rdata_i (instr_rdata_i),\n      .obi_rvalid_i(instr_rvalid_i),\n      .obi_err_i   (instr_err_i)\n  );\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n`ifdef CV32E40P_ASSERT_ON\n\n  // FIFO_DEPTH must be greater than 1. Otherwise, the property\n  // p_hwlp_end_already_gnt_when_hwlp_branch in cv32e40p_prefetch_controller\n  // is not verified, since the prefetcher cannot ask for HWLP_END the cycle\n  // in which HWLP_END-4 is being absorbed by ID.\n  property p_fifo_depth_gt_1;\n    @(posedge clk) (FIFO_DEPTH > 1);\n  endproperty\n\n  a_fifo_depth_gt_1 :\n  assert property (p_fifo_depth_gt_1);\n\n  // Check that branch target address is half-word aligned (RV32-C)\n  property p_branch_halfword_aligned;\n    @(posedge clk) (branch_i) |-> (branch_addr_i[0] == 1'b0);\n  endproperty\n\n  a_branch_halfword_aligned :\n  assert property (p_branch_halfword_aligned);\n\n  // Check that bus interface transactions are word aligned\n  property p_instr_addr_word_aligned;\n    @(posedge clk) (1'b1) |-> (instr_addr_o[1:0] == 2'b00);\n  endproperty\n\n  a_instr_addr_word_aligned :\n  assert property (p_instr_addr_word_aligned);\n\n  // Check that a taken branch can only occur if fetching is requested\n  property p_branch_implies_req;\n    @(posedge clk) (branch_i) |-> (req_i);\n  endproperty\n\n  a_branch_implies_req :\n  assert property (p_branch_implies_req);\n\n  // Check that after a taken branch the initial FIFO output is not accepted\n  property p_branch_invalidates_fifo;\n    @(posedge clk) (branch_i) |-> (!(fetch_valid_o && fetch_ready_i));\n  endproperty\n\n  a_branch_invalidates_fifo :\n  assert property (p_branch_invalidates_fifo);\n\n  // External instruction bus errors are not supported yet. PMP errors are not supported yet.\n  //\n  // Note: Once PMP is re-introduced please consider to make instr_err_pmp_i a 'data' signal\n  // that is qualified with instr_req_o && instr_gnt_i (instead of suppressing instr_gnt_i\n  // as is currently done. This will keep the instr_req_o/instr_gnt_i protocol intact.\n  //\n  // JUST RE-ENABLING the PMP VIA ITS USE_PMP LOCALPARAM WILL NOT WORK BECAUSE OF THE\n  // GRANT SUPPRESSION IN THE PMP.\n\n  property p_no_error;\n    @(posedge clk) (1'b1) |-> ((instr_err_i == 1'b0) && (instr_err_pmp_i == 1'b0));\n  endproperty\n\n  a_no_error :\n  assert property (p_no_error);\n\n\n\n\n`endif\n\nendmodule  // cv32e40p_prefetch_buffer\n","lang":"verilog"};
processSrcData(g_data);