var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/cv32e40p/tb/uvmt/uvmt_cv32e40p_tb.sv","src":"//\n// Copyright 2020 OpenHW Group\n// Copyright 2020 Datum Technology Corporation\n// Copyright 2020 Silicon Labs, Inc.\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://solderpad.org/licenses/\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n//\n\n\n`ifndef __UVMT_CV32E40P_TB_SV__\n`define __UVMT_CV32E40P_TB_SV__\n\n\n/**\n * Module encapsulating the CV32E40P DUT wrapper, and associated SV interfaces.\n * Also provide UVM environment entry and exit points.\n */\n`default_nettype none\nmodule uvmt_cv32e40p_tb;\n\n   import uvm_pkg::*;\n   import cv32e40p_pkg::*;\n   import uvmt_cv32e40p_pkg::*;\n   import uvme_cv32e40p_pkg::*;\n   `ifdef USE_ISS\n   `ifndef FORMAL\n   import rvviApiPkg::*;\n   `endif\n   `endif\n   // DUT (core) parameters: refer to the CV32E40P User Manual.\n`ifdef NO_PULP\n   parameter int CORE_PARAM_COREV_PULP           = 0;\n   parameter int CORE_PARAM_COREV_CLUSTER        = 0;\n   parameter int CORE_PARAM_FPU                  = 0;\n   parameter int CORE_PARAM_FPU_ADDMUL_LAT       = 0;\n   parameter int CORE_PARAM_FPU_OTHERS_LAT       = 0;\n   parameter int CORE_PARAM_ZFINX                = 0;\n`else\n   `ifdef PULP\n      parameter int CORE_PARAM_COREV_PULP        = 1;\n\n      `ifdef CLUSTER\n         parameter int CORE_PARAM_COREV_CLUSTER  = 1;\n      `else\n         parameter int CORE_PARAM_COREV_CLUSTER  = 0;\n      `endif\n\n      `ifdef FPU\n         parameter int CORE_PARAM_FPU            = 1;\n         `ifdef FPU_ADDMUL_LAT\n            parameter int CORE_PARAM_FPU_ADDMUL_LAT = `FPU_ADDMUL_LAT;\n         `else\n            parameter int CORE_PARAM_FPU_ADDMUL_LAT = 0;\n         `endif\n         `ifdef FPU_OTHERS_LAT\n            parameter int CORE_PARAM_FPU_OTHERS_LAT = `FPU_OTHERS_LAT;\n         `else\n            parameter int CORE_PARAM_FPU_OTHERS_LAT = 0;\n         `endif\n         `ifdef ZFINX\n            parameter int CORE_PARAM_ZFINX       = 1;\n         `else\n            parameter int CORE_PARAM_ZFINX       = 0;\n         `endif\n      `else\n         parameter int CORE_PARAM_FPU            = 0;\n         parameter int CORE_PARAM_FPU_ADDMUL_LAT = 0;\n         parameter int CORE_PARAM_FPU_OTHERS_LAT = 0;\n         parameter int CORE_PARAM_ZFINX          = 0;\n      `endif\n\n   `else\n      // If you don't explicitly specify either NO_PULP or PULP, you get NO_PULP\n      parameter int CORE_PARAM_COREV_PULP        = 0;\n      parameter int CORE_PARAM_COREV_CLUSTER     = 0;\n      parameter int CORE_PARAM_FPU               = 0;\n      parameter int CORE_PARAM_FPU_ADDMUL_LAT    = 0;\n      parameter int CORE_PARAM_FPU_OTHERS_LAT    = 0;\n      parameter int CORE_PARAM_ZFINX             = 0;\n   `endif\n`endif\n\n`ifdef SET_NUM_MHPMCOUNTERS\n   parameter int CORE_PARAM_NUM_MHPMCOUNTERS = `SET_NUM_MHPMCOUNTERS;\n`else\n   parameter int CORE_PARAM_NUM_MHPMCOUNTERS = 1;\n`endif\n\n   // ENV (testbench) parameters\n   parameter int ENV_PARAM_INSTR_ADDR_WIDTH  = 32;\n   parameter int ENV_PARAM_INSTR_DATA_WIDTH  = 32;\n   parameter int ENV_PARAM_RAM_ADDR_WIDTH    = 22;\n\n`ifndef IDV_RECONVERGE\n   parameter int SET_IDV_RECONVERGE = 0;\n`else\n   parameter int SET_IDV_RECONVERGE = 1;\n`endif\n\n   // Capture regs for test status from Virtual Peripheral in dut_wrap.mem_i\n   bit        tp;\n   bit        tf;\n   bit        evalid;\n   bit [31:0] evalue;\n\n   // Agent interfaces\n   uvma_clknrst_if     clknrst_if          (); // clock and resets from the clknrst agent\n   uvma_clknrst_if     clknrst_if_iss      ();\n   uvma_debug_if       debug_if            ();\n   uvma_interrupt_if   interrupt_if        (); // Single interrupt interface driven by both the Interrupt Agent and Virtual Peripheral\n   //uvma_interrupt_if   agt_interrupt_if    (); // Interrupts sourced by Interrupt Agent\n   //uvma_interrupt_if   vp_interrupt_if     (); // Interrupts sourced by Virtual Peripheral\n   uvma_obi_memory_if  obi_memory_instr_if (.clk(clknrst_if.clk),\n                                            .reset_n(clknrst_if.reset_n));\n   uvma_obi_memory_if  obi_memory_data_if  (.clk(clknrst_if.clk),\n                                            .reset_n(clknrst_if.reset_n));\n\n   // DUT Wrapper Interfaces\n   uvmt_cv32e40p_vp_status_if       vp_status_if(.tests_passed(),\n                                                 .tests_failed(),\n                                                 .exit_valid(),\n                                                 .exit_value()); // Status information generated by the Virtual Peripherals in the DUT WRAPPER memory.\n   uvme_cv32e40p_core_cntrl_if      core_cntrl_if();\n   uvmt_cv32e40p_core_status_if     core_status_if(.core_busy(),\n                                                   .sec_lvl());     // Core status outputs\n\n   // Step and compare interface\n\n   uvmt_cv32e40p_isa_covg_if     isa_covg_if();\n\n\n   // RVVI SystemVerilog Interface\n   `ifndef FORMAL\n   `ifdef USE_ISS\n      rvviTrace #( .NHART(1), .RETIRE(1)) rvvi_if();\n   `endif\n   `endif\n\n  /**\n   * DUT WRAPPER instance:\n   * This is an update of the riscv_wrapper.sv from PULP-Platform RI5CY project with\n   * a few mods to bring unused ports from the CORE to this level using SV interfaces.\n   */\n   uvmt_cv32e40p_dut_wrap  #(\n                             .COREV_PULP        (CORE_PARAM_COREV_PULP),\n                             .COREV_CLUSTER     (CORE_PARAM_COREV_CLUSTER),\n                             .FPU               (CORE_PARAM_FPU),\n                             .FPU_ADDMUL_LAT    (CORE_PARAM_FPU_ADDMUL_LAT),\n                             .FPU_OTHERS_LAT    (CORE_PARAM_FPU_OTHERS_LAT),\n                             .ZFINX             (CORE_PARAM_ZFINX),\n                             .NUM_MHPMCOUNTERS  (CORE_PARAM_NUM_MHPMCOUNTERS),\n                             .INSTR_ADDR_WIDTH  (ENV_PARAM_INSTR_ADDR_WIDTH),\n                             .INSTR_RDATA_WIDTH (ENV_PARAM_INSTR_DATA_WIDTH),\n                             .RAM_ADDR_WIDTH    (ENV_PARAM_RAM_ADDR_WIDTH)\n                            )\n                            dut_wrap (\n                              .clknrst_if          (clknrst_if),\n                              .interrupt_if        (interrupt_if),\n                              //.agt_interrupt_if    (agt_interrupt_if),\n                              //.vp_interrupt_if     (vp_interrupt_if),\n                              //.vp_status_if        (vp_status_if),\n                              .core_cntrl_if       (core_cntrl_if),\n                              .core_status_if      (core_status_if),\n                              .obi_memory_instr_if (obi_memory_instr_if),\n                              .obi_memory_data_if  (obi_memory_data_if),\n                              .*);\n\n  bind cv32e40p_tb_wrapper\n    uvma_rvfi_instr_if#(uvme_cv32e40p_pkg::ILEN,\n                        uvme_cv32e40p_pkg::XLEN) rvfi_instr_if_0_i(.clk(clk_i),\n                                                                   .reset_n(rst_ni),\n\n                                                                   .rvfi_valid(rvfi_i.rvfi_valid[0]),\n                                                                   .rvfi_order(rvfi_i.rvfi_order[uvma_rvfi_pkg::ORDER_WL*0+:uvma_rvfi_pkg::ORDER_WL]),\n                                                                   .rvfi_insn(rvfi_i.rvfi_insn[uvme_cv32e40p_pkg::ILEN*0+:uvme_cv32e40p_pkg::ILEN]),\n                                                                   .rvfi_trap(rvfi_i.rvfi_trap/*[11:0]*/),\n                                                                   .rvfi_halt(rvfi_i.rvfi_halt[0]),\n                                                                   .rvfi_intr(rvfi_i.rvfi_intr.intr),\n                                                                   .rvfi_dbg(rvfi_i.rvfi_dbg),\n                                                                   .rvfi_dbg_mode(rvfi_i.rvfi_dbg_mode),\n                                                                   //.rvfi_nmip(rvfi_i.rvfi_nmip),\n                                                                   .rvfi_mode(rvfi_i.rvfi_mode[uvma_rvfi_pkg::MODE_WL*0+:uvma_rvfi_pkg::MODE_WL]),\n                                                                   .rvfi_ixl(rvfi_i.rvfi_ixl[uvma_rvfi_pkg::IXL_WL*0+:uvma_rvfi_pkg::IXL_WL]),\n                                                                   .rvfi_pc_rdata(rvfi_i.rvfi_pc_rdata[uvme_cv32e40p_pkg::XLEN*0+:uvme_cv32e40p_pkg::XLEN]),\n                                                                   .rvfi_pc_wdata(rvfi_i.rvfi_pc_wdata[uvme_cv32e40p_pkg::XLEN*0+:uvme_cv32e40p_pkg::XLEN]),\n                                                                   .rvfi_rs1_addr(rvfi_i.rvfi_rs1_addr[uvma_rvfi_pkg::GPR_ADDR_WL*0+:uvma_rvfi_pkg::GPR_ADDR_WL]),\n                                                                   .rvfi_rs1_rdata(rvfi_i.rvfi_rs1_rdata[uvme_cv32e40p_pkg::XLEN*0+:uvme_cv32e40p_pkg::XLEN]),\n                                                                   .rvfi_rs2_addr(rvfi_i.rvfi_rs2_addr[uvma_rvfi_pkg::GPR_ADDR_WL*0+:uvma_rvfi_pkg::GPR_ADDR_WL]),\n                                                                   .rvfi_rs2_rdata(rvfi_i.rvfi_rs2_rdata[uvme_cv32e40p_pkg::XLEN*0+:uvme_cv32e40p_pkg::XLEN]),\n                                                                   .rvfi_rs3_addr('0),\n                                                                   .rvfi_rs3_rdata('0),\n                                                                   .rvfi_rd1_addr(rvfi_i.rvfi_rd_addr[0][uvma_rvfi_pkg::GPR_ADDR_WL*0+:uvma_rvfi_pkg::GPR_ADDR_WL]),\n                                                                   .rvfi_rd1_wdata(rvfi_i.rvfi_rd_wdata[0][uvme_cv32e40p_pkg::XLEN*0+:uvme_cv32e40p_pkg::XLEN]),\n                                                                   .rvfi_rd2_addr('0),\n                                                                   .rvfi_rd2_wdata('0),\n                                                                   .rvfi_mem_addr(rvfi_i.rvfi_mem_addr[uvme_cv32e40p_pkg::XLEN*0+:uvme_cv32e40p_pkg::XLEN]),\n                                                                   .rvfi_mem_rdata(rvfi_i.rvfi_mem_rdata[uvme_cv32e40p_pkg::XLEN*0+:uvme_cv32e40p_pkg::XLEN]),\n                                                                   .rvfi_mem_rmask(rvfi_i.rvfi_mem_rmask[uvme_cv32e40p_pkg::XLEN/8*0+:uvme_cv32e40p_pkg::XLEN/8]),\n                                                                   .rvfi_mem_wdata(rvfi_i.rvfi_mem_wdata[uvme_cv32e40p_pkg::XLEN*0+:uvme_cv32e40p_pkg::XLEN]),\n                                                                   .rvfi_mem_wmask(rvfi_i.rvfi_mem_wmask[uvme_cv32e40p_pkg::XLEN/8*0+:uvme_cv32e40p_pkg::XLEN/8])\n                                                                   );\n\n  // RVFI CSR binds\n  `RVFI_CSR_BIND(fflags)\n  `RVFI_CSR_BIND(frm)\n  `RVFI_CSR_BIND(fcsr)\n  `RVFI_CSR_BIND(marchid)\n  `RVFI_CSR_BIND(mcountinhibit)\n  `RVFI_CSR_BIND(mstatus)\n  `RVFI_CSR_BIND(mstatush)\n  `RVFI_CSR_BIND(mvendorid)\n  `RVFI_CSR_BIND(misa)\n  `RVFI_CSR_BIND(mtvec)\n  `RVFI_CSR_BIND(mtval)\n  `RVFI_CSR_BIND(mscratch)\n  `RVFI_CSR_BIND(mepc)\n  `RVFI_CSR_BIND(mcause)\n  `RVFI_CSR_BIND(mip)\n  `RVFI_CSR_BIND(mie)\n  `RVFI_CSR_BIND(mhartid)\n  `RVFI_CSR_BIND(mcontext)\n  `RVFI_CSR_BIND(scontext)\n  `RVFI_CSR_BIND(mimpid)\n  `RVFI_CSR_BIND(minstret)\n  `RVFI_CSR_BIND(minstreth)\n  `RVFI_CSR_BIND(mcycle)\n  `RVFI_CSR_BIND(mcycleh)\n\n  `RVFI_CSR_BIND(dcsr)\n  `RVFI_CSR_BIND(dpc)\n  `RVFI_CSR_BIND(tselect)\n  `RVFI_CSR_BIND(tinfo)\n\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,3)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,4)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,5)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,6)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,7)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,8)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,9)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,10)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,11)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,12)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,13)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,14)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,15)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,16)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,17)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,18)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,19)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,20)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,21)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,22)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,23)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,24)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,25)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,26)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,27)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,28)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,29)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,30)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,,31)\n\n  `RVFI_CSR_IDX_BIND(mhpmevent,,3)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,4)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,5)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,6)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,7)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,8)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,9)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,10)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,11)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,12)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,13)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,14)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,15)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,16)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,17)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,18)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,19)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,20)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,21)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,22)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,23)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,24)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,25)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,26)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,27)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,28)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,29)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,30)\n  `RVFI_CSR_IDX_BIND(mhpmevent,,31)\n\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,3)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,4)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,5)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,6)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,7)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,8)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,9)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,10)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,11)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,12)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,13)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,14)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,15)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,16)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,17)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,18)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,19)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,20)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,21)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,22)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,23)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,24)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,25)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,26)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,27)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,28)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,29)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,30)\n  `RVFI_CSR_IDX_BIND(mhpmcounter,h,31)\n\n  //`RVFI_CSR_BIND(mconfigptr)\n\n\n  // dscratch0\n  bind cv32e40p_tb_wrapper\n    uvma_rvfi_csr_if#(uvme_cv32e40p_pkg::XLEN) rvfi_csr_dscratch0_if_0_i(.clk(clk_i),\n                                                                         .reset_n(rst_ni),\n                                                                         .rvfi_csr_rmask(rvfi_i.rvfi_csr_dscratch_rmask[0]),\n                                                                         .rvfi_csr_wmask(rvfi_i.rvfi_csr_dscratch_wmask[0]),\n                                                                         .rvfi_csr_rdata(rvfi_i.rvfi_csr_dscratch_rdata[0]),\n                                                                         .rvfi_csr_wdata(rvfi_i.rvfi_csr_dscratch_wdata[0])\n    );\n\n  // dscratch1\n  bind cv32e40p_tb_wrapper\n    uvma_rvfi_csr_if#(uvme_cv32e40p_pkg::XLEN) rvfi_csr_dscratch1_if_0_i(.clk(clk_i),\n                                                                         .reset_n(rst_ni),\n                                                                         .rvfi_csr_rmask(rvfi_i.rvfi_csr_dscratch_rmask[1]),\n                                                                         .rvfi_csr_wmask(rvfi_i.rvfi_csr_dscratch_wmask[1]),\n                                                                         .rvfi_csr_rdata(rvfi_i.rvfi_csr_dscratch_rdata[1]),\n                                                                         .rvfi_csr_wdata(rvfi_i.rvfi_csr_dscratch_wdata[1])\n    );\n\n  // tdata1\n  bind cv32e40p_tb_wrapper\n    uvma_rvfi_csr_if#(uvme_cv32e40p_pkg::XLEN) rvfi_csr_tdata1_if_0_i(.clk(clk_i),\n                                                                     .reset_n(rst_ni),\n                                                                     .rvfi_csr_rmask(rvfi_i.rvfi_csr_tdata_rmask[1]),\n                                                                     .rvfi_csr_wmask(rvfi_i.rvfi_csr_tdata_wmask[1]),\n                                                                     .rvfi_csr_rdata(rvfi_i.rvfi_csr_tdata_rdata[1]),\n                                                                     .rvfi_csr_wdata(rvfi_i.rvfi_csr_tdata_wdata[1])\n    );\n\n  // tdata2\n  bind cv32e40p_tb_wrapper\n    uvma_rvfi_csr_if#(uvme_cv32e40p_pkg::XLEN) rvfi_csr_tdata2_if_0_i(.clk(clk_i),\n                                                                     .reset_n(rst_ni),\n                                                                     .rvfi_csr_rmask(rvfi_i.rvfi_csr_tdata_rmask[2]),\n                                                                     .rvfi_csr_wmask(rvfi_i.rvfi_csr_tdata_wmask[2]),\n                                                                     .rvfi_csr_rdata(rvfi_i.rvfi_csr_tdata_rdata[2]),\n                                                                     .rvfi_csr_wdata(rvfi_i.rvfi_csr_tdata_wdata[2])\n    );\n\n  // tdata3\n  bind cv32e40p_tb_wrapper\n    uvma_rvfi_csr_if#(uvme_cv32e40p_pkg::XLEN) rvfi_csr_tdata3_if_0_i(.clk(clk_i),\n                                                                     .reset_n(rst_ni),\n                                                                     .rvfi_csr_rmask(rvfi_i.rvfi_csr_tdata_rmask[3]),\n                                                                     .rvfi_csr_wmask(rvfi_i.rvfi_csr_tdata_wmask[3]),\n                                                                     .rvfi_csr_rdata(rvfi_i.rvfi_csr_tdata_rdata[3]),\n                                                                     .rvfi_csr_wdata(rvfi_i.rvfi_csr_tdata_wdata[3])\n    );\n\n  bind uvmt_cv32e40p_dut_wrap\n    uvma_obi_memory_assert_if_wrp#(\n      .ADDR_WIDTH(32),\n      .DATA_WIDTH(32),\n      .AUSER_WIDTH(0),\n      .WUSER_WIDTH(0),\n      .RUSER_WIDTH(0),\n      .ID_WIDTH(0),\n      .ACHK_WIDTH(0),\n      .RCHK_WIDTH(0),\n      .IS_1P2(0)\n    ) obi_instr_memory_assert_i(.obi(obi_memory_instr_if));\n\n  bind uvmt_cv32e40p_dut_wrap\n    uvma_obi_memory_assert_if_wrp#(\n      .ADDR_WIDTH(32),\n      .DATA_WIDTH(32),\n      .AUSER_WIDTH(0),\n      .WUSER_WIDTH(0),\n      .RUSER_WIDTH(0),\n      .ID_WIDTH(0),\n      .ACHK_WIDTH(0),\n      .RCHK_WIDTH(0),\n      .IS_1P2(0)\n    ) obi_data_memory_assert_i(.obi(obi_memory_data_if));\n\n  // Bind in verification modules to the design\n  bind cv32e40p_core\n    uvmt_cv32e40p_interrupt_assert interrupt_assert_i(.mcause_n(cs_registers_i.mcause_n),\n                                                      .mip(cs_registers_i.mip),\n                                                      .mie_q(cs_registers_i.mie_q),\n                                                      .mie_n(cs_registers_i.mie_n),\n                                                      .mstatus_mie(cs_registers_i.mstatus_q.mie),\n                                                      .mtvec_mode_q(cs_registers_i.mtvec_mode_q),\n                                                      .if_stage_instr_rvalid_i(if_stage_i.instr_rvalid_i),\n                                                      .if_stage_instr_rdata_i(if_stage_i.instr_rdata_i),\n                                                      .id_stage_instr_valid_i(id_stage_i.instr_valid_i),\n                                                      .id_stage_instr_rdata_i(id_stage_i.instr_rdata_i),\n                                                      .branch_taken_ex(id_stage_i.branch_taken_ex),\n                                                      .ctrl_fsm_cs(id_stage_i.controller_i.ctrl_fsm_cs),\n                                                      .debug_mode_q(id_stage_i.controller_i.debug_mode_q),\n                                                      .*);\n\n   // Debug assertion and coverage interface\n   uvmt_cv32e40p_debug_cov_assert_if debug_cov_assert_if(\n    .clk_i(clknrst_if.clk),\n    .rst_ni(clknrst_if.reset_n),\n    .fetch_enable_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.fetch_enable_i),\n    .if_stage_instr_rvalid_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.if_stage_i.instr_rvalid_i),\n    .if_stage_instr_rdata_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.if_stage_i.instr_rdata_i),\n    .id_stage_instr_valid_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.instr_valid_i),\n    .id_stage_instr_rdata_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.instr_rdata_i),\n    .id_stage_is_compressed(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.is_compressed_i),\n    .id_valid(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.id_valid_i),\n    .is_decoding(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.is_decoding_o),\n    .branch_taken_ex_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.branch_taken_ex_i),\n    .data_err_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.data_err_i),\n    .is_fetch_failed_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.is_fetch_failed_i),\n    .id_stage_pc(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.pc_id_i),\n    .if_stage_pc(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.if_stage_i.pc_if_o),\n    .mie_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mie_q),\n    .ctrl_fsm_cs(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.ctrl_fsm_cs),\n    .illegal_insn_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.illegal_insn_i),\n    .illegal_insn_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.illegal_insn_q),\n    .ecall_insn_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.ecall_insn_i),\n    .debug_req_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.debug_req_pending),\n    .debug_mode_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.debug_mode_q),\n    .dcsr_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.dcsr_q),\n    .depc_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.depc_q),\n    .depc_n(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.depc_n),\n    .mcause_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mcause_q),\n    .mtvec({dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mtvec_q, 8'h00}),\n    .mepc_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mepc_q),\n    .tdata1(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.tmatch_control_rdata),\n    .tdata2(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.tmatch_value_rdata),\n    .trigger_match_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.trigger_match_i),\n    .mcountinhibit_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mcountinhibit_q),\n    .mcycle(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mhpmcounter_q[0]),\n    .minstret(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mhpmcounter_q[2]),\n    .fence_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.decoder_i.fencei_insn_o),\n\n    // TODO: review this change from CV32E40P_HASH f6196bf to a26b194. It should be logically equivalent.\n    //assign debug_cov_assert_if.inst_ret = dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.inst_ret;\n    // First attempt: this causes unexpected failures of a_minstret_count\n    //assign debug_cov_assert_if.inst_ret = (dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_valid &\n    //                                       dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.is_decoding);\n    // Second attempt: (based on OK input).  This passes, but maybe only because p_minstret_count\n    //                                       is the only property sensitive to inst_ret. Will\n    //                                       this work in the general case?\n    .inst_ret(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mhpmevent_minstret_i),\n    .csr_access(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.csr_access),\n    .csr_op(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.csr_op),\n    .csr_op_dec(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.decoder_i.csr_op),\n    .csr_addr(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.csr_addr),\n    .csr_we_int(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.csr_we_int),\n    .irq_ack_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.irq_ack_o),\n    .irq_id_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.irq_id_o),\n    .dm_halt_addr_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.dm_halt_addr_i),\n    .dm_exception_addr_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.dm_exception_addr_i),\n    .core_sleep_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.core_sleep_o),\n    .irq_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.irq_i),\n    .pc_set(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.pc_set_o),\n    .boot_addr_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.boot_addr_i),\n    .branch_in_decode(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.branch_in_id),\n    .rvfi_valid(dut_wrap.cv32e40p_tb_wrapper_i.rvfi_instr_if_0_i.rvfi_valid),\n    .rvfi_insn(dut_wrap.cv32e40p_tb_wrapper_i.rvfi_instr_if_0_i.rvfi_insn),\n    .apu_req(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.apu_req_o),\n    .apu_gnt(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.apu_gnt_i),\n    .apu_busy(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.apu_busy_i),\n\n    .is_wfi(),\n    .in_wfi(),\n    .dpc_will_hit(),\n    .addr_match(),\n    .is_ebreak(),\n    .is_cebreak(),\n    .is_dret(),\n    .is_mulhsu(),\n    .pending_enabled_irq()\n  );\n\n  //Interface for coverage components\n  uvmt_cv32e40p_cov_if cov_if(\n    .clk_i(clknrst_if.clk),\n    .rst_ni(clknrst_if.reset_n),\n\n    .if_stage_instr_rvalid_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.if_stage_i.instr_rvalid_i),\n    .if_stage_instr_rdata_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.if_stage_i.instr_rdata_i),\n\n    .id_stage_instr_valid_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.instr_valid_i),\n    .id_stage_instr_rdata_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.instr_rdata_i),\n    .id_stage_id_valid_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.id_valid_o),\n    .id_stage_apu_op_ex_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.apu_op_ex_o),\n    .id_stage_apu_en_ex_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.apu_en_ex_o),\n\n    .apu_req(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.apu_req_o),\n    .apu_gnt(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.apu_gnt_i),\n    .apu_busy(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.apu_busy_i),\n    .apu_op(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.apu_op_o),\n    .apu_rvalid_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.apu_rvalid_i),\n    .apu_perf_wb_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.apu_perf_wb_o),\n\n    .regfile_waddr_wb_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.regfile_waddr_wb_o),\n    .regfile_we_wb_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.regfile_we_wb_o),\n    .regfile_alu_waddr_ex_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.regfile_alu_waddr_fw_o),\n    .regfile_alu_we_ex_o(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.regfile_alu_we_fw_o),\n\n    .ex_mulh_active(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.mulh_active),\n    .ex_mult_op_ex(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.mult_operator_i),\n    .ex_data_misaligned_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.data_misaligned_i),\n    .ex_data_misaligned_ex_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.data_misaligned_ex_i),\n    .ex_data_req_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.data_req_i),\n    .ex_data_rvalid_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.data_rvalid_i),\n    .ex_regfile_alu_we_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.regfile_alu_we_i),\n    .ex_apu_valid(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.apu_valid),\n    .ex_apu_rvalid_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.ex_stage_i.apu_rvalid_q),\n\n    .debug_req_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.debug_req_pending),\n    .debug_mode_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.debug_mode_q),\n    .dcsr_q(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.dcsr_q),\n    .trigger_match_i(dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.id_stage_i.controller_i.trigger_match_i)\n  );\n\n  // Instantiate debug assertions\n  uvmt_cv32e40p_debug_assert u_debug_assert(.cov_assert_if(debug_cov_assert_if));\n\n\n  // simplify rvvi for coverage\n  uvmt_cv32e40p_rvvi_if cv32e40p_rvvi (\n    .clk                    (clknrst_if.clk),\n    .valid                  (dut_wrap.cv32e40p_tb_wrapper_i.rvfi_i.rvfi_valid[0]),\n    .insn                   (dut_wrap.cv32e40p_tb_wrapper_i.rvfi_i.rvfi_insn[uvme_cv32e40p_pkg::ILEN*0+:uvme_cv32e40p_pkg::ILEN]),\n    .trap                   (dut_wrap.cv32e40p_tb_wrapper_i.rvfi_i.rvfi_trap.trap),\n    .pc_rdata               (dut_wrap.cv32e40p_tb_wrapper_i.rvfi_i.rvfi_pc_rdata),\n    .interrupt_if           (interrupt_if),\n    .debug_if               (debug_if),\n    .wa_csr_mip             (dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.cs_registers_i.mip),\n    `PORTMAP_CSR_RVFI_2_RVVI(lpstart0)\n    `PORTMAP_CSR_RVFI_2_RVVI(lpend0)\n    `PORTMAP_CSR_RVFI_2_RVVI(lpcount0)\n    `PORTMAP_CSR_RVFI_2_RVVI(lpstart1)\n    `PORTMAP_CSR_RVFI_2_RVVI(lpend1)\n    `PORTMAP_CSR_RVFI_2_RVVI(lpcount1)\n    `PORTMAP_CSR_RVFI_2_RVVI(mstatus)\n    `PORTMAP_CSR_RVFI_2_RVVI(mie)\n    `PORTMAP_CSR_RVFI_2_RVVI(mtvec)\n    `PORTMAP_CSR_RVFI_2_RVVI(mcause)\n    `PORTMAP_CSR_RVFI_2_RVVI(mip)\n    `PORTMAP_CSR_RVFI_2_RVVI(dcsr)\n    `PORTMAP_CSR_RVFI_2_RVVI(tdata)\n    .dm_halt_addr           (dut_wrap.cv32e40p_tb_wrapper_i.cv32e40p_top_i.core_i.dm_halt_addr_i)\n  );\n\n    // IMPERAS DV\n    `ifndef FORMAL\n    `ifdef USE_ISS\n      uvmt_cv32e40p_imperas_dv_wrap #(\n        .FPU                    (CORE_PARAM_FPU),\n        .ZFINX                  (CORE_PARAM_ZFINX),\n        .SET_IDV_RECONVERGE     (SET_IDV_RECONVERGE)\n      ) imperas_dv (rvvi_if);\n    `endif\n    `endif\n   /**\n    * Test bench entry point.\n    */\n   initial begin : test_bench_entry_point\n\n     `ifdef PULP\n       `ifdef NO_PULP\n         `uvm_fatal(\"CV32E40P TB\", \"PULP and NO_PULP macros are mutually exclusive.\")\n       `endif\n     `endif\n\n     // Specify time format for simulation (units_number, precision_number, suffix_string, minimum_field_width)\n     $timeformat(-9, 3, \" ns\", 8);\n\n\n    // Pass rvvi_if handle to cov_model\n    uvm_config_db#(virtual uvmt_cv32e40p_rvvi_if)::set(\n      .cntxt(null),\n      .inst_name(\"uvm_test_top.env.cov_model*\"),\n      .field_name(\"cv32e40p_rvvi_vif\"),\n      .value(cv32e40p_rvvi)\n    );\n\n     // Add interfaces handles to uvm_config_db\n     uvm_config_db#(virtual uvma_debug_if                    )::set(.cntxt(null), .inst_name(\"*.env.debug_agent\"),            .field_name(\"vif\"),              .value(debug_if)                                        );\n     uvm_config_db#(virtual uvma_clknrst_if                  )::set(.cntxt(null), .inst_name(\"*.env.clknrst_agent\"),          .field_name(\"vif\"),              .value(clknrst_if)                                      );\n\n     uvm_config_db#(virtual uvma_interrupt_if)::set( .cntxt      (null),\n                                                     .inst_name  (\"uvm_test_top.env\"),\n                                                     .field_name (\"intr_vif\"),\n                                                     .value      (interrupt_if)\n                                                   );\n     uvm_config_db#(virtual uvma_interrupt_if)::set( .cntxt      (null),\n                                                    .inst_name  (\"uvm_test_top.env.interrupt_agent\"),\n                                                    .field_name (\"vif\"),\n                                                    .value      (interrupt_if)\n                                                  );\n    //  uvm_config_db#(virtual uvma_interrupt_if                )::set(.cntxt(null), .inst_name(\"*.env.interrupt_agent\"),        .field_name(\"vif\"),              .value(interrupt_if)); //Was remove from TB, added here to keep compatibility with e40x and e40s uvma\n\n     uvm_config_db#(virtual uvma_interrupt_if)::set( .cntxt      (null),\n                                                     .inst_name  (\"uvm_test_top.env\"),\n                                                     .field_name (\"vif\"),\n                                                     .value      (interrupt_if)\n                                                   );\n\n     uvm_config_db#(virtual uvma_obi_memory_if               )::set(.cntxt(null), .inst_name(\"*.env.obi_memory_instr_agent\"), .field_name(\"vif\"),              .value(obi_memory_instr_if)                             );\n     uvm_config_db#(virtual uvma_obi_memory_if               )::set(.cntxt(null), .inst_name(\"*.env.obi_memory_data_agent\"),  .field_name(\"vif\"),              .value(obi_memory_data_if)                              );\n     uvm_config_db#(virtual uvma_rvfi_instr_if               )::set(.cntxt(null), .inst_name(\"*.env.rvfi_agent\"),             .field_name(\"instr_vif0\"),       .value(dut_wrap.cv32e40p_tb_wrapper_i.rvfi_instr_if_0_i));\n\n     // Picked up by both the cv32e40p_base_test and cv32e40p_env\n     uvm_config_db#(virtual uvmt_cv32e40p_vp_status_if       )::set(.cntxt(null), .inst_name(\"*\"),                            .field_name(\"vp_status_vif\"),    .value(vp_status_if)                                    );\n     // Not needed?\n     //uvm_config_db#(virtual uvmt_cv32e40p_vp_status_if       )::set(.cntxt(null), .inst_name(\"*.env\"),                        .field_name(\"vp_status_vif\"),    .value(vp_status_if)                                    );\n\n     uvm_config_db#(virtual uvme_cv32e40p_core_cntrl_if      )::set(.cntxt(null), .inst_name(\"*\"),                            .field_name(\"core_cntrl_vif\"),   .value(core_cntrl_if)                                   );\n     uvm_config_db#(virtual uvmt_cv32e40p_core_status_if     )::set(.cntxt(null), .inst_name(\"*\"),                            .field_name(\"core_status_vif\"),  .value(core_status_if)                                  );\n     uvm_config_db#(virtual uvmt_cv32e40p_isa_covg_if        )::set(.cntxt(null), .inst_name(\"*\"),                            .field_name(\"isa_covg_vif\"),     .value(isa_covg_if)                                     );\n     uvm_config_db#(virtual uvmt_cv32e40p_debug_cov_assert_if)::set(.cntxt(null), .inst_name(\"*.env\"),                        .field_name(\"debug_cov_vif\"),    .value(debug_cov_assert_if)                             );\n     uvm_config_db#(virtual uvmt_cv32e40p_isa_covg_if        )::set(.cntxt(null), .inst_name(\"*.env\"),                        .field_name(\"isa_covg_vif\"),     .value(isa_covg_if)                                     );\n     uvm_config_db#(virtual uvma_debug_if                    )::set(.cntxt(null), .inst_name(\"*.env\"),                        .field_name(\"debug_vif\"),        .value(debug_if)                                        );\n     uvm_config_db#(virtual uvmt_cv32e40p_cov_if             )::set(.cntxt(null), .inst_name(\"*.env\"),                        .field_name(\"cov_vif\"),          .value(cov_if)                                          );\n\n     `RVFI_CSR_UVM_CONFIG_DB_SET(fflags)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(frm)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(fcsr)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(marchid)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mcountinhibit)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mstatus)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mstatush)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(misa)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mtvec)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mtval)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mvendorid)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mscratch)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mepc)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mcause)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mip)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mie)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhartid)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mimpid)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(minstret)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(minstreth)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mcontext)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mcycle)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mcycleh)\n\n     `RVFI_CSR_UVM_CONFIG_DB_SET(dcsr)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(dpc)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(dscratch0)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(dscratch1)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(scontext)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(tselect)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(tdata1)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(tdata2)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(tdata3)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(tinfo)\n\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent3)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent4)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent5)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent6)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent7)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent8)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent9)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent10)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent11)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent12)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent13)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent14)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent15)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent16)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent17)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent18)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent19)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent20)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent21)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent22)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent23)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent24)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent25)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent26)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent27)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent28)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent29)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent30)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmevent31)\n\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter3)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter4)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter5)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter6)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter7)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter8)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter9)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter10)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter11)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter12)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter13)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter14)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter15)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter16)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter17)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter18)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter19)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter20)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter21)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter22)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter23)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter24)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter25)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter26)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter27)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter28)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter29)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter30)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter31)\n\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter3h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter4h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter5h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter6h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter7h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter8h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter9h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter10h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter11h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter12h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter13h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter14h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter15h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter16h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter17h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter18h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter19h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter20h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter21h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter22h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter23h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter24h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter25h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter26h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter27h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter28h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter29h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter30h)\n     `RVFI_CSR_UVM_CONFIG_DB_SET(mhpmcounter31h)\n     //`RVFI_CSR_UVM_CONFIG_DB_SET(mconfigptr)\n\n     // Make the DUT Wrapper Virtual Peripheral's status outputs available to the base_test\n     uvm_config_db#(bit      )::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"tp\"),     .value(1'b0)        );\n     uvm_config_db#(bit      )::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"tf\"),     .value(1'b0)        );\n     uvm_config_db#(bit      )::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"evalid\"), .value(1'b0)        );\n     uvm_config_db#(bit[31:0])::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"evalue\"), .value(32'h00000000));\n\n     // DUT and ENV parameters\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"CORE_PARAM_COREV_PULP\"),       .value(CORE_PARAM_COREV_PULP)      );\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"CORE_PARAM_COREV_CLUSTER\"),    .value(CORE_PARAM_COREV_CLUSTER)   );\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"CORE_PARAM_FPU\"),              .value(CORE_PARAM_FPU)             );\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"CORE_PARAM_FPU_ADDMUL_LAT\"),   .value(CORE_PARAM_FPU_ADDMUL_LAT)  );\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"CORE_PARAM_FPU_OTHERS_LAT\"),   .value(CORE_PARAM_FPU_OTHERS_LAT)  );\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"CORE_PARAM_ZFINX\"),            .value(CORE_PARAM_ZFINX)           );\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"CORE_PARAM_NUM_MHPMCOUNTERS\"), .value(CORE_PARAM_NUM_MHPMCOUNTERS));\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"ENV_PARAM_INSTR_ADDR_WIDTH\"),  .value(ENV_PARAM_INSTR_ADDR_WIDTH) );\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"ENV_PARAM_INSTR_DATA_WIDTH\"),  .value(ENV_PARAM_INSTR_DATA_WIDTH) );\n     uvm_config_db#(int)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"ENV_PARAM_RAM_ADDR_WIDTH\"),    .value(ENV_PARAM_RAM_ADDR_WIDTH)   );\n\n     // Run test\n     uvm_top.enable_print_topology = 0; // ENV coders enable this as a debug aid\n     uvm_top.finish_on_completion  = 1;\n     uvm_top.run_test();\n   end : test_bench_entry_point\n\n   assign core_cntrl_if.clk = clknrst_if.clk;\n\n   // Informational print message on loading of OVPSIM ISS to benchmark some elf image loading times\n   // OVPSIM runs its initialization at the #1ns timestamp, and should dominate the initial startup time\n   `ifndef FORMAL // Formal ignores initial blocks, avoids unnecessary warning\n   // overcome race\n   `ifdef USE_ISS\n   initial begin\n     if ($test$plusargs(\"USE_ISS\")) begin\n       #0.9ns;\n       imperas_dv.ref_init();\n     end\n   end\n   `endif\n   `endif\n\n   //TODO verify these are correct with regards to isacov function\n   //always @(dut_wrap.cv32e40p_top_i.rvfi_instr_if_0_i.rvfi_valid) -> isacov_if.retire;\n   //assign isacov_if.instr = dut_wrap.cv32e40p_top_i.rvfi_instr_if_0_i.rvfi_insn;\n   //assign isacov_if.is_compressed = dut_wrap.cv32e40p_top_i.tracer_i.insn_compressed;\n\n   // Capture the test status and exit pulse flags\n   // TODO: put this logic in the vp_status_if (makes it easier to pass to ENV)\n   always @(posedge clknrst_if.clk) begin\n     if (!clknrst_if.reset_n) begin\n       tp     <= 1'b0;\n       tf     <= 1'b0;\n       evalid <= 1'b0;\n       evalue <= 32'h00000000;\n     end\n     else begin\n       if (vp_status_if.tests_passed) begin\n         tp <= 1'b1;\n         uvm_config_db#(bit)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"tp\"), .value(1'b1));\n       end\n       if (vp_status_if.tests_failed) begin\n         tf <= 1'b1;\n         uvm_config_db#(bit)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"tf\"), .value(1'b1));\n       end\n       if (vp_status_if.exit_valid) begin\n         evalid <= 1'b1;\n         uvm_config_db#(bit)::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"evalid\"), .value(1'b1));\n       end\n       if (vp_status_if.exit_valid) begin\n         evalue <= vp_status_if.exit_value;\n         uvm_config_db#(bit[31:0])::set(.cntxt(null), .inst_name(\"*\"), .field_name(\"evalue\"), .value(vp_status_if.exit_value));\n       end\n     end\n   end\n\n\n   /**\n    * End-of-test summary printout.\n    */\n   final begin: end_of_test\n      string             summary_string;\n      uvm_report_server  rs;\n      int                err_count;\n      int                warning_count;\n      int                fatal_count;\n      static bit         sim_finished = 0;\n      longint            rvvi_metric_retires;\n      longint            rvvi_metric_comparisons_pc;\n      longint            rvvi_metric_comparisons_gpr;\n      longint            rvvi_metric_comparisons_insbin;\n      longint            rvvi_metric_mismatches;\n\n      static string  red   = \"\\033[31m\\033[1m\";\n      static string  green = \"\\033[32m\\033[1m\";\n      static string  reset = \"\\033[0m\";\n\n      rs            = uvm_top.get_report_server();\n      err_count     = rs.get_severity_count(UVM_ERROR);\n      warning_count = rs.get_severity_count(UVM_WARNING);\n      fatal_count   = rs.get_severity_count(UVM_FATAL);\n\n      void'(uvm_config_db#(bit)::get(null, \"\", \"sim_finished\", sim_finished));\n\n      // Shutdown the Reference Model\n      `ifdef USE_ISS\n        //Check RVVI metrics at the end of the test\n        rvvi_metric_retires             = rvviRefMetricGet(RVVI_METRIC_RETIRES);\n        rvvi_metric_comparisons_pc      = rvviRefMetricGet(RVVI_METRIC_COMPARISONS_PC);\n        rvvi_metric_comparisons_gpr     = rvviRefMetricGet(RVVI_METRIC_COMPARISONS_GPR);\n        rvvi_metric_comparisons_insbin  = rvviRefMetricGet(RVVI_METRIC_COMPARISONS_INSBIN);\n        rvvi_metric_mismatches          = rvviRefMetricGet(RVVI_METRIC_MISMATCHES);\n\n        // Exit handler for ImperasDV\n        void'(rvviRefShutdown());\n\n        if(rvvi_metric_retires == 0) begin\n          err_count++;\n          $display(\"ERROR: SIM Run with reference model but no instruction retires sent to Reference model\");\n        end\n\n        if(rvvi_metric_comparisons_pc == 0) begin\n          err_count++;\n          $display(\"ERROR: SIM Run with reference model but no PC comparison done in model\");\n        end\n\n        if(rvvi_metric_comparisons_gpr == 0) begin\n          err_count++;\n          $display(\"ERROR: SIM Run with reference model but no GPR comparison done in model\");\n        end\n\n        if(rvvi_metric_comparisons_insbin == 0) begin\n          err_count++;\n          $display(\"ERROR: SIM Run with reference model but no Instruction comparison done in model\");\n        end\n\n        if(rvvi_metric_mismatches != 0) begin\n          err_count = err_count + rvvi_metric_mismatches;\n          $display(\"ERROR: Reference model mismatches found!\");\n          $display(\"ERROR: Total Reference model mismatches = %0d\", rvvi_metric_mismatches);\n        end\n\n      `endif\n\n      // In most other contexts, calls to $display() in a UVM environment are\n      // illegal. Here they are OK because the UVM environment has shut down\n      // and we are merely dumping a summary to stdout.\n      //@DVT_LINTER_WAIVER_START \"MT20210811_3\" disable SVTB.29.1.7\n      $display(\"\\n%m: *** Test Summary ***\\n\");\n\n      if (sim_finished && (err_count == 0) && (fatal_count == 0)) begin\n         $display(\"    PPPPPPP    AAAAAA    SSSSSS    SSSSSS   EEEEEEEE  DDDDDDD     \");\n         $display(\"    PP    PP  AA    AA  SS    SS  SS    SS  EE        DD    DD    \");\n         $display(\"    PP    PP  AA    AA  SS        SS        EE        DD    DD    \");\n         $display(\"    PPPPPPP   AAAAAAAA   SSSSSS    SSSSSS   EEEEE     DD    DD    \");\n         $display(\"    PP        AA    AA        SS        SS  EE        DD    DD    \");\n         $display(\"    PP        AA    AA  SS    SS  SS    SS  EE        DD    DD    \");\n         $display(\"    PP        AA    AA   SSSSSS    SSSSSS   EEEEEEEE  DDDDDDD     \");\n         $display(\"    ----------------------------------------------------------\");\n         if (warning_count == 0) begin\n           $display(\"                        SIMULATION PASSED                     \");\n         end\n         else begin\n           $display(\"                 SIMULATION PASSED with WARNINGS              \");\n         end\n         $display(\"    ----------------------------------------------------------\");\n      end\n      else begin\n         $display(\"    FFFFFFFF   AAAAAA   IIIIII  LL        EEEEEEEE  DDDDDDD       \");\n         $display(\"    FF        AA    AA    II    LL        EE        DD    DD      \");\n         $display(\"    FF        AA    AA    II    LL        EE        DD    DD      \");\n         $display(\"    FFFFF     AAAAAAAA    II    LL        EEEEE     DD    DD      \");\n         $display(\"    FF        AA    AA    II    LL        EE        DD    DD      \");\n         $display(\"    FF        AA    AA    II    LL        EE        DD    DD      \");\n         $display(\"    FF        AA    AA  IIIIII  LLLLLLLL  EEEEEEEE  DDDDDDD       \");\n\n         if (sim_finished == 0) begin\n            $display(\"    --------------------------------------------------------\");\n            $display(\"                   SIMULATION FAILED - ABORTED              \");\n            $display(\"    --------------------------------------------------------\");\n         end\n         else begin\n            $display(\"    --------------------------------------------------------\");\n            $display(\"                       SIMULATION FAILED                    \");\n            $display(\"    --------------------------------------------------------\");\n         end\n      end\n      //@DVT_LINTER_WAIVER_END \"MT20210811_3\"\n   end\n\n\n  // BELOW ARE USE FOR SPECIAL HACKS PURPOSE - START\n   \n    // 1 - To cover directives instr/data gnt assert-deassert when req is low\n    `TB_HACK_1_OBI_GNT(instr)\n    `TB_HACK_1_OBI_GNT(data)\n   \n  // BELOW ARE USE FOR SPECIAL HACKS PURPOSE - END\n\nendmodule : uvmt_cv32e40p_tb\n`default_nettype wire\n\n`endif // __UVMT_CV32E40P_TB_SV__\n","lang":"verilog"};
processSrcData(g_data);