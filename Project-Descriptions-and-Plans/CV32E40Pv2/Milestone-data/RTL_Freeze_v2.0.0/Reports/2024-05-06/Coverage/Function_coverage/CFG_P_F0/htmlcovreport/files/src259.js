var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_F0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_apu_disp.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Lukas Mueller - lukasmue@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Simple APU dispatcher                                      //\n// Project Name:   PULP                                                       //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Dispatcher for sending instructions to the Marx            //\n//                 interconnect.                                              //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_apu_disp (\n    input logic clk_i,\n    input logic rst_ni,\n\n    // request input\n    input logic       enable_i,\n    input logic [1:0] apu_lat_i,\n    input logic [5:0] apu_waddr_i,\n\n    // response output\n    output logic [5:0] apu_waddr_o,\n    output logic       apu_multicycle_o,\n    output logic       apu_singlecycle_o,\n\n    // active signal\n    output logic active_o,\n\n    // stall signals\n    output logic stall_o,\n\n    // dependency checks\n    input  logic            is_decoding_i,\n    input  logic [2:0][5:0] read_regs_i,\n    input  logic [2:0]      read_regs_valid_i,\n    output logic            read_dep_o,\n    output logic            read_dep_for_jalr_o,\n\n    input  logic [1:0][5:0] write_regs_i,\n    input  logic [1:0]      write_regs_valid_i,\n    output logic            write_dep_o,\n\n    // perf counter stuff\n    output logic perf_type_o,\n    output logic perf_cont_o,\n\n    // apu-interconnect\n    // handshake signals\n    output logic apu_req_o,\n    input  logic apu_gnt_i,\n    // response channel\n    input  logic apu_rvalid_i\n\n);\n\n  logic [5:0] addr_req, addr_inflight, addr_waiting;\n  logic [5:0] addr_inflight_dn, addr_waiting_dn;\n  logic valid_req, valid_inflight, valid_waiting;\n  logic valid_inflight_dn, valid_waiting_dn;\n  logic returned_req, returned_inflight, returned_waiting;\n\n  logic       req_accepted;\n  logic       active;\n  logic [1:0] apu_lat;\n\n\n  logic [2:0] read_deps_req, read_deps_inflight, read_deps_waiting;\n  logic [1:0] write_deps_req, write_deps_inflight, write_deps_waiting;\n  logic read_dep_req, read_dep_inflight, read_dep_waiting;\n  logic write_dep_req, write_dep_inflight, write_dep_waiting;\n\n  logic stall_full, stall_type, stall_nack;\n\n  // Generate request signal; do not generate request if stalled unless it's a nack stall\n  assign valid_req         = enable_i & !(stall_full | stall_type);\n  assign addr_req          = apu_waddr_i;\n\n  assign req_accepted      = valid_req & apu_gnt_i;\n\n  //\n  // In-flight instructions\n  //\n  // Check whether the instructions have returned\n  assign returned_req      = valid_req & apu_rvalid_i & !valid_inflight & !valid_waiting;\n  assign returned_inflight = valid_inflight & (apu_rvalid_i) & !valid_waiting;\n  assign returned_waiting  = valid_waiting & (apu_rvalid_i);\n\n  // Inflight and waiting registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      valid_inflight <= 1'b0;\n      valid_waiting  <= 1'b0;\n      addr_inflight  <= '0;\n      addr_waiting   <= '0;\n    end else begin\n      valid_inflight <= valid_inflight_dn;\n      valid_waiting  <= valid_waiting_dn;\n      addr_inflight  <= addr_inflight_dn;\n      addr_waiting   <= addr_waiting_dn;\n    end\n  end\n\n  always_comb begin\n    valid_inflight_dn = valid_inflight;\n    valid_waiting_dn  = valid_waiting;\n    addr_inflight_dn  = addr_inflight;\n    addr_waiting_dn   = addr_waiting;\n\n    if (req_accepted & !returned_req) begin  // this is a multicycle request\n      valid_inflight_dn = 1'b1;\n      addr_inflight_dn  = addr_req;\n      if (valid_inflight & !(returned_inflight)) begin  // we already have an inflight instruction!\n        valid_waiting_dn = 1'b1;\n        addr_waiting_dn  = addr_inflight;\n      end\n      if (returned_waiting) begin // we have received a new request and waiting goes out of the pipe but will be refilled\n        valid_waiting_dn = 1'b1;\n        addr_waiting_dn  = addr_inflight;\n      end\n    end // no new request\n     else if (returned_inflight) begin // multicycle request has returned\n      valid_inflight_dn = '0;\n      valid_waiting_dn  = '0;\n      addr_inflight_dn  = '0;\n      addr_waiting_dn   = '0;\n    end else if (returned_waiting) begin  // multicycle request has returned\n      valid_waiting_dn = '0;\n      addr_waiting_dn  = '0;\n    end\n  end\n\n  //\n  // Active type\n  //\n  // Dispatcher is active when there is an unreturned instruction\n  assign active = valid_inflight | valid_waiting;\n\n  // Store the latency type whenever there is a request\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      apu_lat <= '0;\n    end else begin\n      if (valid_req) begin\n        apu_lat <= apu_lat_i;\n      end\n    end\n  end\n\n  //\n  // Dependency checks\n  //\n  // There is a dependency if the register is equal to one of the instructions\n  generate\n    for (genvar i = 0; i < 3; i++) begin : gen_read_deps\n      assign read_deps_req[i]      = (read_regs_i[i] == addr_req) & read_regs_valid_i[i];\n      assign read_deps_inflight[i] = (read_regs_i[i] == addr_inflight) & read_regs_valid_i[i];\n      assign read_deps_waiting[i]  = (read_regs_i[i] == addr_waiting) & read_regs_valid_i[i];\n    end\n  endgenerate\n\n  generate\n    for (genvar i = 0; i < 2; i++) begin : gen_write_deps\n      assign write_deps_req[i]      = (write_regs_i[i] == addr_req) & write_regs_valid_i[i];\n      assign write_deps_inflight[i] = (write_regs_i[i] == addr_inflight) & write_regs_valid_i[i];\n      assign write_deps_waiting[i]  = (write_regs_i[i] == addr_waiting) & write_regs_valid_i[i];\n    end\n  endgenerate\n\n  // Reduce the individual dependency signals into one read and one write dependency\n  assign read_dep_req = |read_deps_req & valid_req & !returned_req;\n  assign read_dep_inflight = |read_deps_inflight & valid_inflight & !returned_inflight;\n  assign read_dep_waiting = |read_deps_waiting & valid_waiting & !returned_waiting;\n  assign write_dep_req = |write_deps_req & valid_req & !returned_req;\n  assign write_dep_inflight = |write_deps_inflight & valid_inflight & !returned_inflight;\n  assign write_dep_waiting = |write_deps_waiting & valid_waiting & !returned_waiting;\n\n  assign read_dep_o = (read_dep_req | read_dep_inflight | read_dep_waiting) & is_decoding_i;\n  assign write_dep_o = (write_dep_req | write_dep_inflight | write_dep_waiting) & is_decoding_i;\n\n  assign read_dep_for_jalr_o = is_decoding_i & ((|read_deps_req & enable_i) |\n                                                (|read_deps_inflight & valid_inflight) |\n                                                (|read_deps_waiting & valid_waiting));\n\n  //\n  // Stall signals\n  //\n  // Stall if we cannot store any more outstanding requests\n  assign stall_full = valid_inflight & valid_waiting;\n  // Stall if there is a type conflict. if apu is active we can only issue requests with a larger or equal latency\n  // than the latency of the inflight operation (apu_lat_i>=apu_lat). otherwise operations would overtake each other!\n  // so we stall if: (apu_lat_i = 1 & apu_lat = 2/3) | (apu_lat_i = 2 & apu_lat = 3) | (apu_lat_i = 3 (multicycle))\n  assign stall_type      = enable_i  & active & ((apu_lat_i==2'h1) | ((apu_lat_i==2'h2) & (apu_lat==2'h3)) | (apu_lat_i==2'h3));\n  assign stall_nack = valid_req & !apu_gnt_i;\n  assign stall_o = stall_full | stall_type | stall_nack;\n\n  //\n  // Generate Apu_master request\n  //\n  assign apu_req_o = valid_req;\n\n\n  // Determine write register based on where the instruction returned.\n  always_comb begin\n    apu_waddr_o = '0;\n    if (returned_req) apu_waddr_o = addr_req;\n    if (returned_inflight) apu_waddr_o = addr_inflight;\n    if (returned_waiting) apu_waddr_o = addr_waiting;\n  end\n\n  // Output active signal\n  assign active_o = active;\n\n  // Performance counter signals\n  assign perf_type_o = stall_type;\n  assign perf_cont_o = stall_nack;\n\n  assign apu_multicycle_o = (apu_lat == 2'h3);\n  assign apu_singlecycle_o = ~(valid_inflight | valid_waiting);\n\n  //\n  // Assertions\n  //\n\n`ifdef CV32E40P_ASSERT_ON\n  assert property (@(posedge clk_i) (apu_rvalid_i) |-> (valid_req | valid_inflight | valid_waiting))\n  else $warning(\"[APU Dispatcher] instruction returned while no instruction is in-flight\");\n`endif\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);