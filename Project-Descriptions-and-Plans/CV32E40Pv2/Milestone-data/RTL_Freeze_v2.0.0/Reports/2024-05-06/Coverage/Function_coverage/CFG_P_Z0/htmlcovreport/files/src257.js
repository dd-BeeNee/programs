var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/vendor/pulp_platform_fpnew/src/fpnew_opgroup_block.sv","src":"// Copyright 2019 ETH Zurich and University of Bologna.\n//\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// SPDX-License-Identifier: SHL-0.51\n\n// Author: Stefan Mach <smach@iis.ee.ethz.ch>\n\nmodule fpnew_opgroup_block #(\n  parameter fpnew_pkg::opgroup_e        OpGroup       = fpnew_pkg::ADDMUL,\n  // FPU configuration\n  parameter int unsigned                Width         = 32,\n  parameter logic                       EnableVectors = 1'b1,\n  parameter logic                       PulpDivsqrt   = 1'b1,\n  parameter fpnew_pkg::fmt_logic_t      FpFmtMask     = '1,\n  parameter fpnew_pkg::ifmt_logic_t     IntFmtMask    = '1,\n  parameter fpnew_pkg::fmt_unsigned_t   FmtPipeRegs   = '{default: 0},\n  parameter fpnew_pkg::fmt_unit_types_t FmtUnitTypes  = '{default: fpnew_pkg::PARALLEL},\n  parameter fpnew_pkg::pipe_config_t    PipeConfig    = fpnew_pkg::BEFORE,\n  parameter type                        TagType       = logic,\n  parameter int unsigned                TrueSIMDClass = 0,\n  // Do not change\n  localparam int unsigned NUM_FORMATS  = fpnew_pkg::NUM_FP_FORMATS,\n  localparam int unsigned NUM_OPERANDS = fpnew_pkg::num_operands(OpGroup),\n  localparam int unsigned NUM_LANES    = fpnew_pkg::max_num_lanes(Width, FpFmtMask, EnableVectors),\n  localparam type         MaskType     = logic [NUM_LANES-1:0]\n) (\n  input logic                                     clk_i,\n  input logic                                     rst_ni,\n  // Input signals\n  input logic [NUM_OPERANDS-1:0][Width-1:0]       operands_i,\n  input logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed_i,\n  input fpnew_pkg::roundmode_e                    rnd_mode_i,\n  input fpnew_pkg::operation_e                    op_i,\n  input logic                                     op_mod_i,\n  input fpnew_pkg::fp_format_e                    src_fmt_i,\n  input fpnew_pkg::fp_format_e                    dst_fmt_i,\n  input fpnew_pkg::int_format_e                   int_fmt_i,\n  input logic                                     vectorial_op_i,\n  input TagType                                   tag_i,\n  input MaskType                                  simd_mask_i,\n  // Input Handshake\n  input  logic                                    in_valid_i,\n  output logic                                    in_ready_o,\n  input  logic                                    flush_i,\n  // Output signals\n  output logic [Width-1:0]                        result_o,\n  output fpnew_pkg::status_t                      status_o,\n  output logic                                    extension_bit_o,\n  output TagType                                  tag_o,\n  // Output handshake\n  output logic                                    out_valid_o,\n  input  logic                                    out_ready_i,\n  // Indication of valid data in flight\n  output logic                                    busy_o\n);\n\n  // ----------------\n  // Type Definition\n  // ----------------\n  typedef struct packed {\n    logic [Width-1:0]   result;\n    fpnew_pkg::status_t status;\n    logic               ext_bit;\n    TagType             tag;\n  } output_t;\n\n  // Handshake signals for the slices\n  logic [NUM_FORMATS-1:0] fmt_in_ready, fmt_out_valid, fmt_out_ready, fmt_busy;\n  output_t [NUM_FORMATS-1:0] fmt_outputs;\n\n  // -----------\n  // Input Side\n  // -----------\n  assign in_ready_o = in_valid_i & fmt_in_ready[dst_fmt_i]; // Ready is given by selected format\n\n  // -------------------------\n  // Generate Parallel Slices\n  // -------------------------\n  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_parallel_slices\n    // Some constants for this format\n    localparam logic ANY_MERGED = fpnew_pkg::any_enabled_multi(FmtUnitTypes, FpFmtMask);\n    localparam logic IS_FIRST_MERGED =\n        fpnew_pkg::is_first_enabled_multi(fpnew_pkg::fp_format_e'(fmt), FmtUnitTypes, FpFmtMask);\n\n    // Generate slice only if format enabled\n    if (FpFmtMask[fmt] && (FmtUnitTypes[fmt] == fpnew_pkg::PARALLEL)) begin : active_format\n\n      logic in_valid;\n\n      assign in_valid = in_valid_i & (dst_fmt_i == fmt); // enable selected format\n\n      // Forward masks related to the right SIMD lane\n      localparam int unsigned INTERNAL_LANES = fpnew_pkg::num_lanes(Width, fpnew_pkg::fp_format_e'(fmt), EnableVectors);\n      logic [INTERNAL_LANES-1:0] mask_slice;\n      always_comb for (int b = 0; b < INTERNAL_LANES; b++) mask_slice[b] = simd_mask_i[(NUM_LANES/INTERNAL_LANES)*b];\n\n      fpnew_opgroup_fmt_slice #(\n        .OpGroup       ( OpGroup                      ),\n        .FpFormat      ( fpnew_pkg::fp_format_e'(fmt) ),\n        .Width         ( Width                        ),\n        .EnableVectors ( EnableVectors                ),\n        .NumPipeRegs   ( FmtPipeRegs[fmt]             ),\n        .PipeConfig    ( PipeConfig                   ),\n        .TagType       ( TagType                      ),\n        .TrueSIMDClass ( TrueSIMDClass                )\n      ) i_fmt_slice (\n        .clk_i,\n        .rst_ni,\n        .operands_i     ( operands_i               ),\n        .is_boxed_i     ( is_boxed_i[fmt]          ),\n        .rnd_mode_i,\n        .op_i,\n        .op_mod_i,\n        .vectorial_op_i,\n        .tag_i,\n        .simd_mask_i    ( mask_slice               ),\n        .in_valid_i     ( in_valid                 ),\n        .in_ready_o     ( fmt_in_ready[fmt]        ),\n        .flush_i,\n        .result_o       ( fmt_outputs[fmt].result  ),\n        .status_o       ( fmt_outputs[fmt].status  ),\n        .extension_bit_o( fmt_outputs[fmt].ext_bit ),\n        .tag_o          ( fmt_outputs[fmt].tag     ),\n        .out_valid_o    ( fmt_out_valid[fmt]       ),\n        .out_ready_i    ( fmt_out_ready[fmt]       ),\n        .busy_o         ( fmt_busy[fmt]            ),\n        .reg_ena_i      ( '0                       )\n      );\n    // If the format wants to use merged ops, tie off the dangling ones not used here\n    end else if (FpFmtMask[fmt] && ANY_MERGED && !IS_FIRST_MERGED) begin : merged_unused\n\n      localparam FMT = fpnew_pkg::get_first_enabled_multi(FmtUnitTypes, FpFmtMask);\n      // Ready is split up into formats\n      assign fmt_in_ready[fmt]  = fmt_in_ready[int'(FMT)];\n\n      assign fmt_out_valid[fmt] = 1'b0; // don't emit values\n      assign fmt_busy[fmt]      = 1'b0; // never busy\n      // Outputs are don't care\n      assign fmt_outputs[fmt].result  = '{default: fpnew_pkg::DONT_CARE};\n      assign fmt_outputs[fmt].status  = '{default: fpnew_pkg::DONT_CARE};\n      assign fmt_outputs[fmt].ext_bit = fpnew_pkg::DONT_CARE;\n      assign fmt_outputs[fmt].tag     = TagType'(fpnew_pkg::DONT_CARE);\n\n    // Tie off disabled formats\n    end else if (!FpFmtMask[fmt] || (FmtUnitTypes[fmt] == fpnew_pkg::DISABLED)) begin : disable_fmt\n      assign fmt_in_ready[fmt]  = 1'b0; // don't accept operations\n      assign fmt_out_valid[fmt] = 1'b0; // don't emit values\n      assign fmt_busy[fmt]      = 1'b0; // never busy\n      // Outputs are don't care\n      assign fmt_outputs[fmt].result  = '{default: fpnew_pkg::DONT_CARE};\n      assign fmt_outputs[fmt].status  = '{default: fpnew_pkg::DONT_CARE};\n      assign fmt_outputs[fmt].ext_bit = fpnew_pkg::DONT_CARE;\n      assign fmt_outputs[fmt].tag     = TagType'(fpnew_pkg::DONT_CARE);\n    end\n  end\n\n  // ----------------------\n  // Generate Merged Slice\n  // ----------------------\n  if (fpnew_pkg::any_enabled_multi(FmtUnitTypes, FpFmtMask)) begin : gen_merged_slice\n\n    localparam FMT = fpnew_pkg::get_first_enabled_multi(FmtUnitTypes, FpFmtMask);\n    localparam REG = fpnew_pkg::get_num_regs_multi(FmtPipeRegs, FmtUnitTypes, FpFmtMask);\n\n    logic in_valid;\n\n    assign in_valid = in_valid_i & (FmtUnitTypes[dst_fmt_i] == fpnew_pkg::MERGED);\n\n    fpnew_opgroup_multifmt_slice #(\n      .OpGroup       ( OpGroup          ),\n      .Width         ( Width            ),\n      .FpFmtConfig   ( FpFmtMask        ),\n      .IntFmtConfig  ( IntFmtMask       ),\n      .EnableVectors ( EnableVectors    ),\n      .PulpDivsqrt   ( PulpDivsqrt      ),\n      .NumPipeRegs   ( REG              ),\n      .PipeConfig    ( PipeConfig       ),\n      .TagType       ( TagType          )\n    ) i_multifmt_slice (\n      .clk_i,\n      .rst_ni,\n      .operands_i,\n      .is_boxed_i,\n      .rnd_mode_i,\n      .op_i,\n      .op_mod_i,\n      .src_fmt_i,\n      .dst_fmt_i,\n      .int_fmt_i,\n      .vectorial_op_i,\n      .tag_i,\n      .simd_mask_i     ( simd_mask_i              ),\n      .in_valid_i      ( in_valid                 ),\n      .in_ready_o      ( fmt_in_ready[FMT]        ),\n      .flush_i,\n      .result_o        ( fmt_outputs[FMT].result  ),\n      .status_o        ( fmt_outputs[FMT].status  ),\n      .extension_bit_o ( fmt_outputs[FMT].ext_bit ),\n      .tag_o           ( fmt_outputs[FMT].tag     ),\n      .out_valid_o     ( fmt_out_valid[FMT]       ),\n      .out_ready_i     ( fmt_out_ready[FMT]       ),\n      .busy_o          ( fmt_busy[FMT]            ),\n      .reg_ena_i       ( '0                       )\n    );\n\n  end\n\n  // ------------------\n  // Arbitrate Outputs\n  // ------------------\n  output_t arbiter_output;\n\n  // Round-Robin arbiter to decide which result to use\n  rr_arb_tree #(\n    .NumIn     ( NUM_FORMATS ),\n    .DataType  ( output_t    ),\n    .AxiVldRdy ( 1'b1        )\n  ) i_arbiter (\n    .clk_i,\n    .rst_ni,\n    .flush_i,\n    .rr_i   ( '0             ),\n    .req_i  ( fmt_out_valid  ),\n    .gnt_o  ( fmt_out_ready  ),\n    .data_i ( fmt_outputs    ),\n    .gnt_i  ( out_ready_i    ),\n    .req_o  ( out_valid_o    ),\n    .data_o ( arbiter_output ),\n    .idx_o  ( /* unused */   )\n  );\n\n  // Unpack output\n  assign result_o        = arbiter_output.result;\n  assign status_o        = arbiter_output.status;\n  assign extension_bit_o = arbiter_output.ext_bit;\n  assign tag_o           = arbiter_output.tag;\n\n  assign busy_o = (| fmt_busy);\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);