var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/lib/uvm_agents/uvma_obi_memory/src/uvma_obi_memory_assert.sv","src":"// Copyright 2020 OpenHW Group\n// Copyright 2020 Datum Technology Corporation\n// Copyright 2020 Silicon Labs, Inc.\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://solderpad.org/licenses/\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmodule uvma_obi_memory_assert\n  import uvm_pkg::*;\n  #(\n    parameter int unsigned ADDR_WIDTH  = 32,\n    parameter int unsigned DATA_WIDTH  = 32,\n    parameter int unsigned AUSER_WIDTH = 0,\n    parameter int unsigned WUSER_WIDTH = 0,\n    parameter int unsigned RUSER_WIDTH = 0,\n    parameter int unsigned ID_WIDTH    = 0,\n    parameter int unsigned ACHK_WIDTH  = 0,\n    parameter int unsigned RCHK_WIDTH  = 0,\n    parameter bit          IS_1P2      = 0\n  )\n  (\n    input                    clk,\n    input                    reset_n,\n\n    // A bus 1P1\n    input                    req,\n    input                    gnt,\n    input [ADDR_WIDTH-1:0]   addr,\n    input                    we,\n    input [DATA_WIDTH/8-1:0] be,\n    input [DATA_WIDTH-1:0]   wdata,\n\n    // A bus 1P2\n    input [((AUSER_WIDTH == 0) ? 0 : AUSER_WIDTH - 1) : 0] auser,\n    input [((WUSER_WIDTH == 0) ? 0 : WUSER_WIDTH - 1) : 0] wuser,\n    input [((ID_WIDTH == 0) ? 0 : ID_WIDTH - 1) : 0]       aid,\n    input [5:0]              atop,\n    input [1:0]              memtype,\n    input [2:0]              prot,\n    input                    reqpar,\n    input                    gntpar,\n    input [((ACHK_WIDTH == 0) ? 0 : ACHK_WIDTH - 1) : 0] achk,\n\n    // R bus 1P1\n    input [DATA_WIDTH-1:0]   rdata,\n    input                    rvalid,\n\n    // R bus 1P2\n    input                    rready,\n    input                    err,\n    input [((RUSER_WIDTH == 0) ? 0 : RUSER_WIDTH - 1) : 0] ruser,\n    input [((ID_WIDTH == 0) ? 0 : ID_WIDTH - 1) : 0]       rid,\n    input                    exokay,\n    input                    rvalidpar,\n    input                    rreadypar,\n    input [((RCHK_WIDTH == 0) ? 0 : RCHK_WIDTH - 1) : 0] rchk\n  );\n\n  // ---------------------------------------------------------------------------\n  // Local parameters\n  // ---------------------------------------------------------------------------\n\n  // ---------------------------------------------------------------------------\n  // Local variables\n  // ---------------------------------------------------------------------------\n  string info_tag = \"OBIMEMASRT\";\n\n  wire valid_a_phase;\n  wire valid_r_phase;\n\n  // ---------------------------------------------------------------------------\n  // Clocking blocks\n  // ---------------------------------------------------------------------------\n\n  // Single clock, single reset design, use default clocking\n  default clocking @(posedge clk); endclocking\n  default disable iff !(reset_n);\n\n  // ---------------------------------------------------------------------------\n  // Begin module code\n  // ---------------------------------------------------------------------------\n\n  // If this is 1P2 generate the 1p2 assertion module\n  generate if (IS_1P2) begin : gen_1p2\n    uvma_obi_memory_1p2_assert#(\n      .ADDR_WIDTH(ADDR_WIDTH),\n      .DATA_WIDTH(DATA_WIDTH),\n      .AUSER_WIDTH(AUSER_WIDTH),\n      .WUSER_WIDTH(WUSER_WIDTH),\n      .RUSER_WIDTH(RUSER_WIDTH),\n      .ID_WIDTH(ID_WIDTH),\n      .ACHK_WIDTH(ACHK_WIDTH),\n      .RCHK_WIDTH(RCHK_WIDTH)\n    ) u_1p2_assert(.atop   ('0), // todo: remove a-ext related signals\n                   .exokay ('0), //\n                   .*);\n  end\n  endgenerate\n\n  // Modeling logic and common decoding\n  assign valid_a_phase = req && gnt;\n  assign valid_r_phase = rvalid;\n\n  // R-3.1.1 : A phase signals stable during address phase\n  property p_addr_signal_stable(sig);\n    req ##0 !gnt |=> $stable(sig);\n  endproperty : p_addr_signal_stable\n\n  a_addr_stable: assert property(p_addr_signal_stable(addr))\n  else\n    `uvm_error(info_tag, \"addr signal not stable in address phase\")\n\n  a_we_stable: assert property(p_addr_signal_stable(we))\n  else\n    `uvm_error(info_tag, \"we signal not stable in address phase\")\n\n  a_wdata_stable: assert property(p_addr_signal_stable(wdata))\n  else\n    `uvm_error(info_tag, \"wdata signal not stable in address phase\")\n\n  a_be_stable: assert property(p_addr_signal_stable(be))\n  else\n    `uvm_error(info_tag, \"be signal not stable in address phase\")\n\n  // R-3.1.2 : Req may not deassewrt until the gnt is asserted\n  property p_req_until_gnt;\n    req ##0 !gnt |=> req;\n  endproperty : p_req_until_gnt\n  a_req_until_gnt : assert property(p_req_until_gnt)\n  else\n    `uvm_error(info_tag, \"req may not deassert until gnt asserted\")\n\n  // These next 2 are not strictly a functional requirement, but the testbench should simulate this\n  // Therefore these are coded as a set of cover properties\n\n  // R-3.2.1 : slave shall be allowed to de-assert (retract) gnt at any time even if req is deasserted\n  property p_gnt_assert_no_req;\n    !req ##0 !gnt ##1 !req ##0 gnt;\n  endproperty : p_gnt_assert_no_req\n  c_gnt_assert_no_req : cover property(p_gnt_assert_no_req);\n\n  // R-3.2.2 : slave shall be allowed to de-assert (retract) gnt at any time even if req is deasserted\n  property p_gnt_deassert_no_req;\n    !req ##0 gnt ##1 !req ##0 !gnt;\n  endproperty : p_gnt_deassert_no_req\n  c_gnt_deassert_no_req : cover property(p_gnt_deassert_no_req);\n\n  // R-5 ensure that rvalid is never asserted before or coincident to its address phase\n  // Model outstanding accepted addresses\n  bit [3:0] outstanding_trn_cnt;\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      outstanding_trn_cnt <= 0;\n    end\n    else begin\n      if (valid_a_phase && !valid_r_phase)\n        outstanding_trn_cnt <= outstanding_trn_cnt + 4'h1;\n      else if (!valid_a_phase && valid_r_phase)\n        outstanding_trn_cnt <= outstanding_trn_cnt - 4'h1;\n    end\n  end\n\n  property p_r_after_a;\n    rvalid |-> outstanding_trn_cnt != 0;\n  endproperty : p_r_after_a\n  a_r_after_a : assert property(p_r_after_a)\n  else\n    `uvm_error(info_tag, \"response phase started before address phase\")\n\n  // R-7 At least one byte enable must be set\n  property p_be_not_zero;\n    req ##0 we |-> be != 0;\n  endproperty : p_be_not_zero\n  a_be_not_zero : assert property(p_be_not_zero)\n  else\n    `uvm_error(info_tag, \"be was zero during an address cycle\")\n\n  // R-7 All ones must be contiguous in writes\n  reg[3:0] contiguous_be[] = {\n    4'b0001,\n    4'b0011,\n    4'b0111,\n    4'b1111,\n    4'b0010,\n    4'b0110,\n    4'b1110,\n    4'b0100,\n    4'b1100,\n    4'b1000\n  };\n  bit be_inside_contiguous_be;\n  always_comb begin\n    be_inside_contiguous_be = be inside {contiguous_be};\n  end\n  property p_be_contiguous;\n    req ##0 we |-> be_inside_contiguous_be;\n  endproperty : p_be_contiguous\n  a_be_contiguous : assert property(p_be_contiguous)\n  else\n    `uvm_error(info_tag, $sformatf(\"be of 0x%0x was not contiguous\", $sampled(be)));\n\n  // R-8 Data address LSBs must be consistent with byte enables on writes\n  function bit [1:0] get_addr_lsb(bit[3:0] be);\n    casex (be)\n      4'b???1: return 0;\n      4'b??10: return 1;\n      4'b?100: return 2;\n      4'b1000: return 3;\n    endcase\n  endfunction : get_addr_lsb\n\n  property p_addr_be_consistent;\n    req |-> addr[1:0] == get_addr_lsb(be);\n  endproperty : p_addr_be_consistent\n  a_addr_be_consistent: assert property(p_addr_be_consistent)\n  else\n    `uvm_error(info_tag, $sformatf(\"be of 0x%01x not consistent with addr 0x%08x\", $sampled(be), $sampled(addr)));\n\n\nendmodule : uvma_obi_memory_assert\n\n","lang":"verilog"};
processSrcData(g_data);