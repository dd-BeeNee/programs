var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_load_store_unit.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Igor Loi - igor.loi@unibo.it                               //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                                                                            //\n// Design Name:    Load Store Unit                                            //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Load Store Unit, used to eliminate multiple access during  //\n//                 processor stalls, and to align bytes and halfwords         //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_load_store_unit #(\n    parameter PULP_OBI = 0  // Legacy PULP OBI behavior\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // output to data memory\n    output logic data_req_o,\n    input logic data_gnt_i,\n    input logic data_rvalid_i,\n    input  logic         data_err_i,           // External bus error (validity defined by data_rvalid_i) (not used yet)\n    input logic data_err_pmp_i,  // PMP error (validity defined by data_gnt_i)\n\n    output logic [31:0] data_addr_o,\n    output logic        data_we_o,\n    output logic [ 3:0] data_be_o,\n    output logic [31:0] data_wdata_o,\n    input  logic [31:0] data_rdata_i,\n\n    // signals from ex stage\n    input logic        data_we_ex_i,  // write enable                      -> from ex stage\n    input logic [ 1:0] data_type_ex_i,  // Data type word, halfword, byte    -> from ex stage\n    input logic [31:0] data_wdata_ex_i,  // data to write to memory           -> from ex stage\n    input logic [ 1:0] data_reg_offset_ex_i,  // offset inside register for stores -> from ex stage\n    input logic        data_load_event_ex_i,  // load event                        -> from ex stage\n    input logic [ 1:0] data_sign_ext_ex_i,  // sign extension                    -> from ex stage\n\n    output logic [31:0] data_rdata_ex_o,  // requested data                    -> to ex stage\n    input  logic        data_req_ex_i,  // data request                      -> from ex stage\n    input  logic [31:0] operand_a_ex_i,  // operand a from RF for address     -> from ex stage\n    input  logic [31:0] operand_b_ex_i,  // operand b from RF for address     -> from ex stage\n    input  logic        addr_useincr_ex_i,  // use a + b or just a for address   -> from ex stage\n\n    input  logic data_misaligned_ex_i,  // misaligned access in last ld/st   -> from ID/EX pipeline\n    output logic data_misaligned_o,  // misaligned access was detected    -> to controller\n\n    input  logic [5:0] data_atop_ex_i,  // atomic instructions signal        -> from ex stage\n    output logic [5:0] data_atop_o,  // atomic instruction signal         -> core output\n\n    output logic p_elw_start_o,  // load event starts\n    output logic p_elw_finish_o,  // load event finishes\n\n    // stall signal\n    output logic lsu_ready_ex_o,  // LSU ready for new data in EX stage\n    output logic lsu_ready_wb_o,  // LSU ready for new data in WB stage\n\n    output logic busy_o\n);\n\n  localparam DEPTH = 2;  // Maximum number of outstanding transactions\n\n  // Transaction request (to cv32e40p_obi_interface)\n  logic trans_valid;\n  logic trans_ready;\n  logic [31:0] trans_addr;\n  logic trans_we;\n  logic [3:0] trans_be;\n  logic [31:0] trans_wdata;\n  logic [5:0] trans_atop;\n\n  // Transaction response interface (from cv32e40p_obi_interface)\n  logic resp_valid;\n  logic [31:0] resp_rdata;\n  logic resp_err;  // Unused for now\n\n  // Counter to count maximum number of outstanding transactions\n  logic [1:0] cnt_q;  // Transaction counter\n  logic [1:0] next_cnt;  // Next value for cnt_q\n  logic         count_up;               // Increment outstanding transaction count by 1 (can happen at same time as count_down)\n  logic         count_down;             // Decrement outstanding transaction count by 1 (can happen at same time as count_up)\n\n  logic ctrl_update;  // Update load/store control info in WB stage\n\n  logic [31:0] data_addr_int;\n\n  // registers for data_rdata alignment and sign extension\n  logic [1:0] data_type_q;\n  logic [1:0] rdata_offset_q;\n  logic [1:0] data_sign_ext_q;\n  logic data_we_q;\n  logic data_load_event_q;\n\n  logic [1:0] wdata_offset;  // mux control for data to be written to memory\n\n  logic [3:0] data_be;\n  logic [31:0] data_wdata;\n\n  logic misaligned_st;  // high if we are currently performing the second part of a misaligned store\n  logic load_err_o, store_err_o;\n\n  logic [31:0] rdata_q;\n\n  ///////////////////////////////// BE generation ////////////////////////////////\n  always_comb begin\n    case (data_type_ex_i)  // Data type 00 Word, 01 Half word, 11,10 byte\n      2'b00: begin  // Writing a word\n        if (misaligned_st == 1'b0) begin  // non-misaligned case\n          case (data_addr_int[1:0])\n            2'b00:   data_be = 4'b1111;\n            2'b01:   data_be = 4'b1110;\n            2'b10:   data_be = 4'b1100;\n            default: data_be = 4'b1000;\n          endcase\n          ;  // case (data_addr_int[1:0])\n        end else begin  // misaligned case\n          case (data_addr_int[1:0])\n            2'b01:   data_be = 4'b0001;\n            2'b10:   data_be = 4'b0011;\n            2'b11:   data_be = 4'b0111;\n            default: data_be = 4'b0000;  // this is not used, but included for completeness\n          endcase\n          ;  // case (data_addr_int[1:0])\n        end\n      end\n\n      2'b01: begin  // Writing a half word\n        if (misaligned_st == 1'b0) begin  // non-misaligned case\n          case (data_addr_int[1:0])\n            2'b00:   data_be = 4'b0011;\n            2'b01:   data_be = 4'b0110;\n            2'b10:   data_be = 4'b1100;\n            default: data_be = 4'b1000;\n          endcase\n          ;  // case (data_addr_int[1:0])\n        end else begin  // misaligned case\n          data_be = 4'b0001;\n        end\n      end\n\n      2'b10, 2'b11: begin  // Writing a byte\n        case (data_addr_int[1:0])\n          2'b00:   data_be = 4'b0001;\n          2'b01:   data_be = 4'b0010;\n          2'b10:   data_be = 4'b0100;\n          default: data_be = 4'b1000;\n        endcase\n        ;  // case (data_addr_int[1:0])\n      end\n    endcase\n    ;  // case (data_type_ex_i)\n  end\n\n  // prepare data to be written to the memory\n  // we handle misaligned accesses, half word and byte accesses and\n  // register offsets here\n  assign wdata_offset = data_addr_int[1:0] - data_reg_offset_ex_i[1:0];\n  always_comb begin\n    case (wdata_offset)\n      2'b00: data_wdata = data_wdata_ex_i[31:0];\n      2'b01: data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};\n      2'b10: data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};\n      2'b11: data_wdata = {data_wdata_ex_i[7:0], data_wdata_ex_i[31:8]};\n    endcase\n    ;  // case (wdata_offset)\n  end\n\n\n  // FF for rdata alignment and sign-extension\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      data_type_q       <= '0;\n      rdata_offset_q    <= '0;\n      data_sign_ext_q   <= '0;\n      data_we_q         <= 1'b0;\n      data_load_event_q <= 1'b0;\n    end\n    else if (ctrl_update) // request was granted, we wait for rvalid and can continue to WB\n    begin\n      data_type_q       <= data_type_ex_i;\n      rdata_offset_q    <= data_addr_int[1:0];\n      data_sign_ext_q   <= data_sign_ext_ex_i;\n      data_we_q         <= data_we_ex_i;\n      data_load_event_q <= data_load_event_ex_i;\n    end\n  end\n\n  // Load event starts when request is sent and finishes when (final) rvalid is received\n  assign p_elw_start_o  = data_load_event_ex_i && data_req_o;\n  assign p_elw_finish_o = data_load_event_q && data_rvalid_i && !data_misaligned_ex_i;\n\n  ////////////////////////////////////////////////////////////////////////\n  //  ____  _               _____      _                 _              //\n  // / ___|(_) __ _ _ __   | ____|_  _| |_ ___ _ __  ___(_) ___  _ __   //\n  // \\___ \\| |/ _` | '_ \\  |  _| \\ \\/ / __/ _ \\ '_ \\/ __| |/ _ \\| '_ \\  //\n  //  ___) | | (_| | | | | | |___ >  <| ||  __/ | | \\__ \\ | (_) | | | | //\n  // |____/|_|\\__, |_| |_| |_____/_/\\_\\\\__\\___|_| |_|___/_|\\___/|_| |_| //\n  //          |___/                                                     //\n  ////////////////////////////////////////////////////////////////////////\n\n  logic [31:0] data_rdata_ext;\n\n  logic [31:0] rdata_w_ext;  // sign extension for words, actually only misaligned assembly\n  logic [31:0] rdata_h_ext;  // sign extension for half words\n  logic [31:0] rdata_b_ext;  // sign extension for bytes\n\n  // take care of misaligned words\n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: rdata_w_ext = resp_rdata[31:0];\n      2'b01: rdata_w_ext = {resp_rdata[7:0], rdata_q[31:8]};\n      2'b10: rdata_w_ext = {resp_rdata[15:0], rdata_q[31:16]};\n      2'b11: rdata_w_ext = {resp_rdata[23:0], rdata_q[31:24]};\n    endcase\n  end\n\n  // sign extension for half words\n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q == 2'b00) rdata_h_ext = {16'h0000, resp_rdata[15:0]};\n        else if (data_sign_ext_q == 2'b10) rdata_h_ext = {16'hffff, resp_rdata[15:0]};\n        else rdata_h_ext = {{16{resp_rdata[15]}}, resp_rdata[15:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q == 2'b00) rdata_h_ext = {16'h0000, resp_rdata[23:8]};\n        else if (data_sign_ext_q == 2'b10) rdata_h_ext = {16'hffff, resp_rdata[23:8]};\n        else rdata_h_ext = {{16{resp_rdata[23]}}, resp_rdata[23:8]};\n      end\n\n      2'b10: begin\n        if (data_sign_ext_q == 2'b00) rdata_h_ext = {16'h0000, resp_rdata[31:16]};\n        else if (data_sign_ext_q == 2'b10) rdata_h_ext = {16'hffff, resp_rdata[31:16]};\n        else rdata_h_ext = {{16{resp_rdata[31]}}, resp_rdata[31:16]};\n      end\n\n      2'b11: begin\n        if (data_sign_ext_q == 2'b00) rdata_h_ext = {16'h0000, resp_rdata[7:0], rdata_q[31:24]};\n        else if (data_sign_ext_q == 2'b10)\n          rdata_h_ext = {16'hffff, resp_rdata[7:0], rdata_q[31:24]};\n        else rdata_h_ext = {{16{resp_rdata[7]}}, resp_rdata[7:0], rdata_q[31:24]};\n      end\n    endcase  // case (rdata_offset_q)\n  end\n\n  // sign extension for bytes\n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q == 2'b00) rdata_b_ext = {24'h00_0000, resp_rdata[7:0]};\n        else if (data_sign_ext_q == 2'b10) rdata_b_ext = {24'hff_ffff, resp_rdata[7:0]};\n        else rdata_b_ext = {{24{resp_rdata[7]}}, resp_rdata[7:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q == 2'b00) rdata_b_ext = {24'h00_0000, resp_rdata[15:8]};\n        else if (data_sign_ext_q == 2'b10) rdata_b_ext = {24'hff_ffff, resp_rdata[15:8]};\n        else rdata_b_ext = {{24{resp_rdata[15]}}, resp_rdata[15:8]};\n      end\n\n      2'b10: begin\n        if (data_sign_ext_q == 2'b00) rdata_b_ext = {24'h00_0000, resp_rdata[23:16]};\n        else if (data_sign_ext_q == 2'b10) rdata_b_ext = {24'hff_ffff, resp_rdata[23:16]};\n        else rdata_b_ext = {{24{resp_rdata[23]}}, resp_rdata[23:16]};\n      end\n\n      2'b11: begin\n        if (data_sign_ext_q == 2'b00) rdata_b_ext = {24'h00_0000, resp_rdata[31:24]};\n        else if (data_sign_ext_q == 2'b10) rdata_b_ext = {24'hff_ffff, resp_rdata[31:24]};\n        else rdata_b_ext = {{24{resp_rdata[31]}}, resp_rdata[31:24]};\n      end\n    endcase  // case (rdata_offset_q)\n  end\n\n  // select word, half word or byte sign extended version\n  always_comb begin\n    case (data_type_q)\n      2'b00:        data_rdata_ext = rdata_w_ext;\n      2'b01:        data_rdata_ext = rdata_h_ext;\n      2'b10, 2'b11: data_rdata_ext = rdata_b_ext;\n    endcase  //~case(rdata_type_q)\n  end\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      rdata_q <= '0;\n    end else begin\n      if (resp_valid && (~data_we_q)) begin\n        // if we have detected a misaligned access, and we are\n        // currently doing the first part of this access, then\n        // store the data coming from memory in rdata_q.\n        // In all other cases, rdata_q gets the value that we are\n        // writing to the register file\n        if ((data_misaligned_ex_i == 1'b1) || (data_misaligned_o == 1'b1)) rdata_q <= resp_rdata;\n        else rdata_q <= data_rdata_ext;\n      end\n    end\n  end\n\n  // output to register file\n  assign data_rdata_ex_o = (resp_valid == 1'b1) ? data_rdata_ext : rdata_q;\n\n  assign misaligned_st   = data_misaligned_ex_i;\n\n  // Note: PMP is not fully supported at the moment (not even if USE_PMP = 1)\n  assign load_err_o      = data_gnt_i && data_err_pmp_i && ~data_we_o;  // Not currently used\n  assign store_err_o     = data_gnt_i && data_err_pmp_i && data_we_o;  // Not currently used\n\n\n  // check for misaligned accesses that need a second memory access\n  // If one is detected, this is signaled with data_misaligned_o to\n  // the controller which selectively stalls the pipeline\n  always_comb begin\n    data_misaligned_o = 1'b0;\n\n    if ((data_req_ex_i == 1'b1) && (data_misaligned_ex_i == 1'b0)) begin\n      case (data_type_ex_i)\n        2'b00: // word\n        begin\n          if (data_addr_int[1:0] != 2'b00) data_misaligned_o = 1'b1;\n        end\n        2'b01: // half word\n        begin\n          if (data_addr_int[1:0] == 2'b11) data_misaligned_o = 1'b1;\n        end\n      endcase  // case (data_type_ex_i)\n    end\n  end\n\n  // generate address from operands\n  assign data_addr_int = (addr_useincr_ex_i) ? (operand_a_ex_i + operand_b_ex_i) : operand_a_ex_i;\n\n  // Busy if there are ongoing (or potentially outstanding) transfers\n  assign busy_o = (cnt_q != 2'b00) || trans_valid;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Transaction request generation\n  //\n  // Assumes that corresponding response is at least 1 cycle after request\n  //\n  // - Only request transaction when EX stage requires data transfer (data_req_ex_i), and\n  // - maximum number of outstanding transactions will not be exceeded (cnt_q < DEPTH)\n  //////////////////////////////////////////////////////////////////////////////\n\n  // For last phase of misaligned transfer the address needs to be word aligned (as LSB of data_be will be set)\n  assign trans_addr = data_misaligned_ex_i ? {data_addr_int[31:2], 2'b00} : data_addr_int;\n  assign trans_we = data_we_ex_i;\n  assign trans_be = data_be;\n  assign trans_wdata = data_wdata;\n  assign trans_atop = data_atop_ex_i;\n\n  // Transaction request generation\n  generate\n    if (PULP_OBI == 0) begin : gen_no_pulp_obi\n      // OBI compatible (avoids combinatorial path from data_rvalid_i to data_req_o).\n      // Multiple trans_* transactions can be issued (and accepted) before a response\n      // (resp_*) is received.\n      assign trans_valid = data_req_ex_i && (cnt_q < DEPTH);\n    end else begin : gen_pulp_obi\n      // Legacy PULP OBI behavior, i.e. only issue subsequent transaction if preceding transfer\n      // is about to finish (re-introducing timing critical path from data_rvalid_i to data_req_o)\n      assign trans_valid = (cnt_q == 2'b00) ? data_req_ex_i && (cnt_q < DEPTH) :\n                                              data_req_ex_i && (cnt_q < DEPTH) && resp_valid;\n    end\n  endgenerate\n\n  // LSU WB stage is ready if it is not being used (i.e. no outstanding transfers, cnt_q = 0),\n  // or if it WB stage is being used and the awaited response arrives (resp_rvalid).\n  assign lsu_ready_wb_o = (cnt_q == 2'b00) ? 1'b1 : resp_valid;\n\n  // LSU EX stage readyness requires two criteria to be met:\n  // \n  // - A data request (data_req_ex_i) has been forwarded/accepted (trans_valid && trans_ready)\n  // - The LSU WB stage is available such that EX and WB can be updated in lock step\n  //\n  // Default (if there is not even a data request) LSU EX is signaled to be ready, else\n  // if there are no outstanding transactions the EX stage is ready again once the transaction\n  // request is accepted (at which time this load/store will move to the WB stage), else\n  // in case there is already at least one outstanding transaction (so WB is full) the EX \n  // and WB stage can only signal readiness in lock step (so resp_valid is used as well).\n\n  assign lsu_ready_ex_o = (data_req_ex_i == 1'b0) ? 1'b1 :\n                          (cnt_q == 2'b00) ? (              trans_valid && trans_ready) : \n                          (cnt_q == 2'b01) ? (resp_valid && trans_valid && trans_ready) : \n                                              resp_valid;\n\n  // Update signals for EX/WB registers (when EX has valid data itself and is ready for next)\n  assign ctrl_update = lsu_ready_ex_o && data_req_ex_i;\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Counter (cnt_q, next_cnt) to count number of outstanding OBI transactions \n  // (maximum = DEPTH)\n  // \n  // Counter overflow is prevented by limiting the number of outstanding transactions\n  // to DEPTH. Counter underflow is prevented by the assumption that resp_valid = 1 \n  // will only occur in response to accepted transfer request (as per the OBI protocol).\n  //////////////////////////////////////////////////////////////////////////////\n\n  assign count_up = trans_valid && trans_ready;  // Increment upon accepted transfer request\n  assign count_down = resp_valid;  // Decrement upon accepted transfer response\n\n  always_comb begin\n    unique case ({\n      count_up, count_down\n    })\n      2'b00: begin\n        next_cnt = cnt_q;\n      end\n      2'b01: begin\n        next_cnt = cnt_q - 1'b1;\n      end\n      2'b10: begin\n        next_cnt = cnt_q + 1'b1;\n      end\n      2'b11: begin\n        next_cnt = cnt_q;\n      end\n    endcase\n  end\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Registers\n  //////////////////////////////////////////////////////////////////////////////\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      cnt_q <= '0;\n    end else begin\n      cnt_q <= next_cnt;\n    end\n  end\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // OBI interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_obi_interface #(\n      .TRANS_STABLE(1)\n  ) data_obi_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .trans_valid_i(trans_valid),\n      .trans_ready_o(trans_ready),\n      .trans_addr_i (trans_addr),\n      .trans_we_i   (trans_we),\n      .trans_be_i   (trans_be),\n      .trans_wdata_i(trans_wdata),\n      .trans_atop_i (trans_atop),\n\n      .resp_valid_o(resp_valid),\n      .resp_rdata_o(resp_rdata),\n      .resp_err_o  (resp_err),  // Unused for now\n\n      .obi_req_o   (data_req_o),\n      .obi_gnt_i   (data_gnt_i),\n      .obi_addr_o  (data_addr_o),\n      .obi_we_o    (data_we_o),\n      .obi_be_o    (data_be_o),\n      .obi_wdata_o (data_wdata_o),\n      .obi_atop_o  (data_atop_o),  // Not (yet) defined in OBI 1.0 spec\n      .obi_rdata_i (data_rdata_i),\n      .obi_rvalid_i(data_rvalid_i),\n      .obi_err_i   (data_err_i)  // External bus error (validity defined by obi_rvalid_i)\n  );\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Assertions\n  //////////////////////////////////////////////////////////////////////////////\n\n`ifdef CV32E40P_ASSERT_ON\n\n  // External data bus errors are not supported yet. PMP errors are not supported yet.\n  // \n  // Note: Once PMP is re-introduced please consider to make data_err_pmp_i a 'data' signal\n  // that is qualified with data_req_o && data_gnt_i (instead of suppressing data_gnt_i \n  // as is currently done. This will keep the data_req_o/data_gnt_i protocol intact.\n  //\n  // JUST RE-ENABLING the PMP VIA ITS USE_PMP LOCALPARAM WILL NOT WORK AS DATA_ERR_PMP_I \n  // NO LONGER FEEDS INTO LSU_READY_EX_O.\n\n  property p_no_error;\n    @(posedge clk) (1'b1) |-> ((data_err_i == 1'b0) && (data_err_pmp_i == 1'b0));\n  endproperty\n\n  a_no_error :\n  assert property (p_no_error);\n\n  // Check that outstanding transaction count will not overflow DEPTH\n  property p_no_transaction_count_overflow_0;\n    @(posedge clk) (1'b1) |-> (cnt_q <= DEPTH);\n  endproperty\n\n  a_no_transaction_count_overflow_0 :\n  assert property (p_no_transaction_count_overflow_0);\n\n  property p_no_transaction_count_overflow_1;\n    @(posedge clk) (cnt_q == DEPTH) |-> (!count_up || count_down);\n  endproperty\n\n  a_no_transaction_count_overflow_1 :\n  assert property (p_no_transaction_count_overflow_1);\n\n  // Check that an rvalid only occurs when there are outstanding transaction(s)\n  property p_no_spurious_rvalid;\n    @(posedge clk) (data_rvalid_i == 1'b1) |-> (cnt_q > 0);\n  endproperty\n\n  a_no_spurious_rvalid :\n  assert property (p_no_spurious_rvalid);\n\n  // Check that the address/we/be/atop does not contain X when request is sent\n  property p_address_phase_signals_defined;\n    @(posedge clk) (data_req_o == 1'b1) |-> (!($isunknown(\n        data_addr_o\n    ) || $isunknown(\n        data_we_o\n    ) || $isunknown(\n        data_be_o\n    ) || $isunknown(\n        data_atop_o\n    )));\n  endproperty\n\n  a_address_phase_signals_defined :\n  assert property (p_address_phase_signals_defined);\n\n`endif\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);