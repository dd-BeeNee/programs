var g_data = {"name":"/shark0/processing/cv32e40p/users/processing/PRODUCTS_DIGITAL_DESIGN/PANTHER/PANTHER_1.0/CV32/NR/CFG_P_Z0/NR_QUESTA_INT_DEBUG_LONG/workdir/core-v-cores/cv32e40p/rtl/cv32e40p_mult.sv","src":"// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Matthias Baer - baermatt@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Subword multiplier and MAC                                 //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Advanced MAC unit for PULP.                                //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_mult\n  import cv32e40p_pkg::*;\n(\n    input logic clk,\n    input logic rst_n,\n\n    input logic        enable_i,\n    input mul_opcode_e operator_i,\n\n    // integer and short multiplier\n    input logic       short_subword_i,\n    input logic [1:0] short_signed_i,\n\n    input logic [31:0] op_a_i,\n    input logic [31:0] op_b_i,\n    input logic [31:0] op_c_i,\n\n    input logic [4:0] imm_i,\n\n\n    // dot multiplier\n    input logic [ 1:0] dot_signed_i,\n    input logic [31:0] dot_op_a_i,\n    input logic [31:0] dot_op_b_i,\n    input logic [31:0] dot_op_c_i,\n    input logic        is_clpx_i,\n    input logic [ 1:0] clpx_shift_i,\n    input logic        clpx_img_i,\n\n    output logic [31:0] result_o,\n\n    output logic multicycle_o,\n    output logic mulh_active_o,\n    output logic ready_o,\n    input  logic ex_ready_i\n);\n\n  ///////////////////////////////////////////////////////////////\n  //  ___ _  _ _____ ___ ___ ___ ___   __  __ _   _ _  _____   //\n  // |_ _| \\| |_   _| __/ __| __| _ \\ |  \\/  | | | | ||_   _|  //\n  //  | || .  | | | | _| (_ | _||   / | |\\/| | |_| | |__| |    //\n  // |___|_|\\_| |_| |___\\___|___|_|_\\ |_|  |_|\\___/|____|_|    //\n  //                                                           //\n  ///////////////////////////////////////////////////////////////\n\n  logic [16:0] short_op_a;\n  logic [16:0] short_op_b;\n  logic [32:0] short_op_c;\n  logic [33:0] short_mul;\n  logic [33:0] short_mac;\n  logic [31:0] short_round, short_round_tmp;\n  logic [33:0] short_result;\n\n  logic        short_mac_msb1;\n  logic        short_mac_msb0;\n\n  logic [ 4:0] short_imm;\n  logic [ 1:0] short_subword;\n  logic [ 1:0] short_signed;\n  logic        short_shift_arith;\n  logic [ 4:0] mulh_imm;\n  logic [ 1:0] mulh_subword;\n  logic [ 1:0] mulh_signed;\n  logic        mulh_shift_arith;\n  logic        mulh_carry_q;\n  logic        mulh_save;\n  logic        mulh_clearcarry;\n  logic        mulh_ready;\n\n  mult_state_e mulh_CS, mulh_NS;\n\n  // prepare the rounding value\n  assign short_round_tmp = (32'h00000001) << imm_i;\n  assign short_round = (operator_i == MUL_IR) ? {1'b0, short_round_tmp[31:1]} : '0;\n\n  // perform subword selection and sign extensions\n  assign short_op_a[15:0] = short_subword[0] ? op_a_i[31:16] : op_a_i[15:0];\n  assign short_op_b[15:0] = short_subword[1] ? op_b_i[31:16] : op_b_i[15:0];\n\n  assign short_op_a[16] = short_signed[0] & short_op_a[15];\n  assign short_op_b[16] = short_signed[1] & short_op_b[15];\n\n  assign short_op_c = mulh_active_o ? $signed({mulh_carry_q, op_c_i}) : $signed(op_c_i);\n\n  assign short_mul = $signed(short_op_a) * $signed(short_op_b);\n  assign short_mac = $signed(short_op_c) + $signed(short_mul) + $signed(short_round);\n\n  //we use only short_signed_i[0] as it cannot be short_signed_i[1] 1 and short_signed_i[0] 0\n  assign short_result = $signed(\n      {short_shift_arith & short_mac_msb1, short_shift_arith & short_mac_msb0, short_mac[31:0]}\n  ) >>> short_imm;\n\n  // choose between normal short multiplication operation and mulh operation\n  assign short_imm = mulh_active_o ? mulh_imm : imm_i;\n  assign short_subword = mulh_active_o ? mulh_subword : {2{short_subword_i}};\n  assign short_signed = mulh_active_o ? mulh_signed : short_signed_i;\n  assign short_shift_arith = mulh_active_o ? mulh_shift_arith : short_signed_i[0];\n\n  assign short_mac_msb1 = mulh_active_o ? short_mac[33] : short_mac[31];\n  assign short_mac_msb0 = mulh_active_o ? short_mac[32] : short_mac[31];\n\n\n  always_comb begin\n    mulh_NS          = mulh_CS;\n    mulh_imm         = 5'd0;\n    mulh_subword     = 2'b00;\n    mulh_signed      = 2'b00;\n    mulh_shift_arith = 1'b0;\n    mulh_ready       = 1'b0;\n    mulh_active_o    = 1'b1;\n    mulh_save        = 1'b0;\n    mulh_clearcarry  = 1'b0;\n    multicycle_o     = 1'b0;\n\n    case (mulh_CS)\n      IDLE_MULT: begin\n        mulh_active_o = 1'b0;\n        mulh_ready    = 1'b1;\n        mulh_save     = 1'b0;\n        if ((operator_i == MUL_H) && enable_i) begin\n          mulh_ready = 1'b0;\n          mulh_NS    = STEP0;\n        end\n      end\n\n      STEP0: begin\n        multicycle_o  = 1'b1;\n        mulh_imm      = 5'd16;\n        mulh_active_o = 1'b1;\n        //AL*BL never overflows\n        mulh_save     = 1'b0;\n        mulh_NS       = STEP1;\n        //Here always a 32'b unsigned result (no carry)\n      end\n\n      STEP1: begin\n        multicycle_o     = 1'b1;\n        //AL*BH is signed iff B is signed\n        mulh_signed      = {short_signed_i[1], 1'b0};\n        mulh_subword     = 2'b10;\n        mulh_save        = 1'b1;\n        mulh_shift_arith = 1'b1;\n        mulh_NS          = STEP2;\n        //Here signed 32'b + unsigned 32'b result.\n        //Result is a signed 33'b\n        //Store the carry as it will be used as sign extension, we do\n        //not shift\n      end\n\n      STEP2: begin\n        multicycle_o     = 1'b1;\n        //AH*BL is signed iff A is signed\n        mulh_signed      = {1'b0, short_signed_i[0]};\n        mulh_subword     = 2'b01;\n        mulh_imm         = 5'd16;\n        mulh_save        = 1'b1;\n        mulh_clearcarry  = 1'b1;\n        mulh_shift_arith = 1'b1;\n        mulh_NS          = FINISH;\n        //Here signed 32'b + signed 33'b result.\n        //Result is a signed 34'b\n        //We do not store the carries as the bits 34:33 are shifted back, so we clear it\n      end\n\n      FINISH: begin\n        mulh_signed  = short_signed_i;\n        mulh_subword = 2'b11;\n        mulh_ready   = 1'b1;\n        if (ex_ready_i) mulh_NS = IDLE_MULT;\n      end\n    endcase\n  end\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      mulh_CS      <= IDLE_MULT;\n      mulh_carry_q <= 1'b0;\n    end else begin\n      mulh_CS <= mulh_NS;\n\n      if (mulh_save) mulh_carry_q <= ~mulh_clearcarry & short_mac[32];\n      else if (ex_ready_i)  // clear carry when we are going to the next instruction\n        mulh_carry_q <= 1'b0;\n    end\n  end\n\n  // 32x32 = 32-bit multiplier\n  logic [31:0] int_op_a_msu;\n  logic [31:0] int_op_b_msu;\n  logic [31:0] int_result;\n\n  logic        int_is_msu;\n\n  assign int_is_msu = (operator_i == MUL_MSU32);\n\n  assign int_op_a_msu = op_a_i ^ {32{int_is_msu}};\n  assign int_op_b_msu = op_b_i & {32{int_is_msu}};\n\n  assign int_result = $signed(\n      op_c_i\n  ) + $signed(\n      int_op_b_msu\n  ) + $signed(\n      int_op_a_msu\n  ) * $signed(\n      op_b_i\n  );\n\n  ///////////////////////////////////////////////\n  //  ___   ___ _____   __  __ _   _ _  _____  //\n  // |   \\ / _ \\_   _| |  \\/  | | | | ||_   _| //\n  // | |) | (_) || |   | |\\/| | |_| | |__| |   //\n  // |___/ \\___/ |_|   |_|  |_|\\___/|____|_|   //\n  //                                           //\n  ///////////////////////////////////////////////\n\n  logic [31:0] dot_char_result;\n  logic [32:0] dot_short_result;\n  logic [31:0] accumulator;\n  logic [15:0] clpx_shift_result;\n  logic [3:0][8:0] dot_char_op_a;\n  logic [3:0][8:0] dot_char_op_b;\n  logic [3:0][17:0] dot_char_mul;\n\n  logic [1:0][16:0] dot_short_op_a;\n  logic [1:0][16:0] dot_short_op_b;\n  logic [1:0][33:0] dot_short_mul;\n  logic      [16:0] dot_short_op_a_1_neg; //to compute -rA[31:16]*rB[31:16] -> (!rA[31:16] + 1)*rB[31:16] = !rA[31:16]*rB[31:16] + rB[31:16]\n  logic [31:0] dot_short_op_b_ext;\n\n  assign dot_char_op_a[0] = {dot_signed_i[1] & dot_op_a_i[7], dot_op_a_i[7:0]};\n  assign dot_char_op_a[1] = {dot_signed_i[1] & dot_op_a_i[15], dot_op_a_i[15:8]};\n  assign dot_char_op_a[2] = {dot_signed_i[1] & dot_op_a_i[23], dot_op_a_i[23:16]};\n  assign dot_char_op_a[3] = {dot_signed_i[1] & dot_op_a_i[31], dot_op_a_i[31:24]};\n\n  assign dot_char_op_b[0] = {dot_signed_i[0] & dot_op_b_i[7], dot_op_b_i[7:0]};\n  assign dot_char_op_b[1] = {dot_signed_i[0] & dot_op_b_i[15], dot_op_b_i[15:8]};\n  assign dot_char_op_b[2] = {dot_signed_i[0] & dot_op_b_i[23], dot_op_b_i[23:16]};\n  assign dot_char_op_b[3] = {dot_signed_i[0] & dot_op_b_i[31], dot_op_b_i[31:24]};\n\n  assign dot_char_mul[0] = $signed(dot_char_op_a[0]) * $signed(dot_char_op_b[0]);\n  assign dot_char_mul[1] = $signed(dot_char_op_a[1]) * $signed(dot_char_op_b[1]);\n  assign dot_char_mul[2] = $signed(dot_char_op_a[2]) * $signed(dot_char_op_b[2]);\n  assign dot_char_mul[3] = $signed(dot_char_op_a[3]) * $signed(dot_char_op_b[3]);\n\n  assign dot_char_result = $signed(\n      dot_char_mul[0]\n  ) + $signed(\n      dot_char_mul[1]\n  ) + $signed(\n      dot_char_mul[2]\n  ) + $signed(\n      dot_char_mul[3]\n  ) + $signed(\n      dot_op_c_i\n  );\n\n\n  assign dot_short_op_a[0] = {dot_signed_i[1] & dot_op_a_i[15], dot_op_a_i[15:0]};\n  assign dot_short_op_a[1] = {dot_signed_i[1] & dot_op_a_i[31], dot_op_a_i[31:16]};\n  assign dot_short_op_a_1_neg = dot_short_op_a[1] ^ {17{(is_clpx_i & ~clpx_img_i)}}; //negates whether clpx_img_i is 0 or 1, only REAL PART needs to be negated\n\n  assign dot_short_op_b[0] = (is_clpx_i & clpx_img_i) ? {\n    dot_signed_i[0] & dot_op_b_i[31], dot_op_b_i[31:16]\n  } : {\n    dot_signed_i[0] & dot_op_b_i[15], dot_op_b_i[15:0]\n  };\n  assign dot_short_op_b[1] = (is_clpx_i & clpx_img_i) ? {\n    dot_signed_i[0] & dot_op_b_i[15], dot_op_b_i[15:0]\n  } : {\n    dot_signed_i[0] & dot_op_b_i[31], dot_op_b_i[31:16]\n  };\n\n  assign dot_short_mul[0] = $signed(dot_short_op_a[0]) * $signed(dot_short_op_b[0]);\n  assign dot_short_mul[1] = $signed(dot_short_op_a_1_neg) * $signed(dot_short_op_b[1]);\n\n  assign dot_short_op_b_ext = $signed(dot_short_op_b[1]);\n  assign accumulator = is_clpx_i ? dot_short_op_b_ext & {32{~clpx_img_i}} : $signed(dot_op_c_i);\n\n  assign dot_short_result = $signed(\n      dot_short_mul[0][31:0]\n  ) + $signed(\n      dot_short_mul[1][31:0]\n  ) + $signed(\n      accumulator\n  );\n  assign clpx_shift_result = $signed(dot_short_result[31:15]) >>> clpx_shift_i;\n\n  ////////////////////////////////////////////////////////\n  //   ____                 _ _     __  __              //\n  //  |  _ \\ ___  ___ _   _| | |_  |  \\/  |_   ___  __  //\n  //  | |_) / _ \\/ __| | | | | __| | |\\/| | | | \\ \\/ /  //\n  //  |  _ <  __/\\__ \\ |_| | | |_  | |  | | |_| |>  <   //\n  //  |_| \\_\\___||___/\\__,_|_|\\__| |_|  |_|\\__,_/_/\\_\\  //\n  //                                                    //\n  ////////////////////////////////////////////////////////\n\n  always_comb begin\n    result_o = '0;\n\n    unique case (operator_i)\n      MUL_MAC32, MUL_MSU32: result_o = int_result[31:0];\n\n      MUL_I, MUL_IR, MUL_H: result_o = short_result[31:0];\n\n      MUL_DOT8: result_o = dot_char_result[31:0];\n      MUL_DOT16: begin\n        if (is_clpx_i) begin\n          if (clpx_img_i) begin\n            result_o[31:16] = clpx_shift_result;\n            result_o[15:0]  = dot_op_c_i[15:0];\n          end else begin\n            result_o[15:0]  = clpx_shift_result;\n            result_o[31:16] = dot_op_c_i[31:16];\n          end\n        end else begin\n          result_o = dot_short_result[31:0];\n        end\n      end\n\n      default: ;  // default case to suppress unique warning\n    endcase\n  end\n\n  assign ready_o = mulh_ready;\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n  // check multiplication result for mulh\n`ifdef CV32E40P_ASSERT_ON\n  assert property (\n    @(posedge clk) ((mulh_CS == FINISH) && (operator_i == MUL_H) && (short_signed_i == 2'b11))\n    |->\n    (result_o == (($signed(\n      {{32{op_a_i[31]}}, op_a_i}\n  ) * $signed(\n      {{32{op_b_i[31]}}, op_b_i}\n  )) >>> 32)));\n\n  // check multiplication result for mulhsu\n  assert property (\n    @(posedge clk) ((mulh_CS == FINISH) && (operator_i == MUL_H) && (short_signed_i == 2'b01))\n    |->\n    (result_o == (($signed(\n      {{32{op_a_i[31]}}, op_a_i}\n  ) * {\n    32'b0, op_b_i\n  }) >> 32)));\n\n  // check multiplication result for mulhu\n  assert property (\n    @(posedge clk) ((mulh_CS == FINISH) && (operator_i == MUL_H) && (short_signed_i == 2'b00))\n    |->\n    (result_o == (({\n    32'b0, op_a_i\n  } * {\n    32'b0, op_b_i\n  }) >> 32)));\n`endif\nendmodule\n","lang":"verilog"};
processSrcData(g_data);